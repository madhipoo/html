<!DOCTYPE html>
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<!-- three.js library -->
<!--script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.min.js"></script-->
<script src='../examples/vendor/three.js/build/three.min.js'></script>
<script src="../examples/vendor/three.js/examples/js/libs/stats.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5/dat.gui.min.js"></script>
<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<!-- jsartookit -->
<script src="../vendor/jsartoolkit5/build/artoolkit.min.js"></script>
<script src="../vendor/jsartoolkit5/js/artoolkit.api.js"></script>
<!-- include threex.artoolkit -->
<script src="../src/threex/threex-artoolkitsource.js"></script>
<script src="../src/threex/threex-artoolkitcontext.js"></script>
<script src="../src/threex/threex-arbasecontrols.js"></script>
<script src="../src/threex/threex-armarkercontrols.js"></script>

<script>THREEx.ArToolkitContext.baseURL = '../'</script>

<body style='margin : 0px; overflow: hidden; font-family: Monospace;'>
<div style='font-size:2em;position: absolute; top: 10px; width:100%; text-align: center; z-index: 1;'>
	<a href="https://github.com/jeromeetienne/AR.js/" target="_blank"></a>
	<br/>
	<p id='printDis'></p>
  <p id='touch'></p>
  <p id='output'> </p>
</div>
<script type="x-shader/x-fragment" id="fragmentShaderDepth">
	uniform sampler2D texture;
	varying vec2 vUv;

	vec4 pack_depth(const in float depth) {
		const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);
		const vec4 bit_mask = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);
		vec4 res = fract(depth * bit_shift);
		res -= res.xxyz * bit_mask;
		return res;
	}

	void main() {
		vec4 pixel = texture2D(texture, vUv);
		if (pixel.a < 0.5) discard;
		gl_FragData[0] = pack_depth (gl_FragCoord.z);
	}
</script>
<script type="x-shader/x-vertex" id="vertexShaderDepth">
	varying vec2 vUv;

	void main() {
		vUv = uv;
		gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
	}
</script>
<script>
class Path{
  constructor(pos1,euler1,euler2,moving){
    this.pos1 = pos1;
    this.euler1 = euler1;
    this.euler2 = euler2;
    this.turning = 0;
    this.moving = moving;
  }
}
// global variables
var renderer,stats;
var scene, camera;
var markerA, markerB,markerC,markerD,markerE,markerF;
var men = [],car = [];
var GroupA,GroupB,GroupC,GroupD,GroupE,GroupF;
var arToolKitSource, arToolKitContext;
var button = [],time = 0,flag = 0;
var k = 0.05,angle=0;
var theta = 0;
var opc = 0.5;
var pos1 = [], pos2 = [], euler1 = [], euler2 = [],quat1 = [],quat2 = [];
var moving;
var turning,alpha = [],manIn ='A';
var lastChangeTime = 0;
var keyNow='A';
var faces;
//var raycaster, pickables;
var manPos = new THREE.Vector3(),pos;
var _iOSDevice;
var Drumpose1 = {
        Dtheta1: 1.2057796021989051,
        Dtheta2: 0,
        Dtheta3: 1.5,
        Dtheta4: 1,
        Dtheta5: 0,
        Dtheta6: 0,
        Dtheta7: 0,
        Dtheta8: 0,
        Dtheta9: -0.33541054459782915,
        Dtheta10: -0.025268798743482757,
        Dtheta11: 0,
        Dtheta12: 0
	}
var Drumpose2 = {
        Dtheta1: 1.5,
        Dtheta2: 1,
        Dtheta3: 1.5,
        Dtheta4: 1,
        Dtheta5: 0,
        Dtheta6: 0,
        Dtheta7: 0,
        Dtheta8: 0,
        Dtheta9: -0.24679861721087304,
        Dtheta10: -0.06957476243696081,
        Dtheta11: 0,
        Dtheta12: 0
}
var Drumpose3 = {
        Dtheta1: 1.5,
        Dtheta2: 1,
        Dtheta3: 1.5,
        Dtheta4: 0,
        Dtheta5: 0,
        Dtheta6: 0,
        Dtheta7: 0,
        Dtheta8: 0,
        Dtheta9: 0.48424978373151495,
        Dtheta10: 0.15,
        Dtheta11: 0,
        Dtheta12: 0.6
}
var Drumpose4 = {
        Dtheta1: 1.5,
        Dtheta2: 1,
        Dtheta3: 1.5,
        Dtheta4: 1,
        Dtheta5: 0,
        Dtheta6: 0,
        Dtheta7: 0,
        Dtheta8: 0,
        Dtheta9: 0.2184140015706466,
        Dtheta10: 0.17410803787716844,
        Dtheta11: 0,
        Dtheta12: 0
}
var Drumpose5 = {
        Dtheta1: 1.2057796021989051,
        Dtheta2: 0,
        Dtheta3: 1.5,
        Dtheta4: 1,
        Dtheta5: 0,
        Dtheta6: 0,
        Dtheta7: 0,
        Dtheta8: 0,
        Dtheta9: -0.33541054459782915,
        Dtheta10: -0.025268798743482757,
        Dtheta11: 0,
        Dtheta12: 0
}
var Drumpose6 = {
        Dtheta1: 1.5,
        Dtheta2: 1,
        Dtheta3: 1.09501469296521,
        Dtheta4: 0,
        Dtheta5: 0,
        Dtheta6: 0,
        Dtheta7: 0,
        Dtheta8: 0,
        Dtheta9: 0.48424978373151495,
        Dtheta10: 0.08549611049021233,
        Dtheta11: 0,
        Dtheta12: 0
}
var Drumpose7 = {
        Dtheta1: 1.5,
        Dtheta2: 0,
        Dtheta3: 1.5,
        Dtheta4: 1,
        Dtheta5: 0,
        Dtheta6: 0,
        Dtheta7: 0,
        Dtheta8: 0,
        Dtheta9: -0.33541054459782915,
        Dtheta10: -0.15,
        Dtheta11: -0.6,
        Dtheta12: 0
}
var Drumpose8 = {
        Dtheta1: 1.5,
        Dtheta2: 1,
        Dtheta3: 1.5,
        Dtheta4: 1,
        Dtheta5: 0,
        Dtheta6: 0,
        Dtheta7: 0,
        Dtheta8: 0,
        Dtheta9: -0.24679861721087304,
        Dtheta10: -0.06957476243696081,
        Dtheta11: 0,
        Dtheta12: 0
}
var Drumpose9 = {
        Dtheta1: 1.5,
        Dtheta2: 1,
        Dtheta3: 1.09501469296521,
        Dtheta4: 0,
        Dtheta5: 0,
        Dtheta6: 0,
        Dtheta7: 0,
        Dtheta8: 0,
        Dtheta9: 0.48424978373151495,
        Dtheta10: 0.08549611049021233,
        Dtheta11: 0,
        Dtheta12: 0
	}
var Drumpose10 = {
        Dtheta1: 1.5,
        Dtheta2: 1,
        Dtheta3: 1.5,
        Dtheta4: 1,
        Dtheta5: 0,
        Dtheta6: 0,
        Dtheta7: 0,
        Dtheta8: 0,
        Dtheta9: 0.2184140015706466,
        Dtheta10: 0.17410803787716844,
        Dtheta11: 0,
        Dtheta12: 0
}
var Drumpose11 = {
        Dtheta1: 1.5,
        Dtheta2: 0,
        Dtheta3: 1.5,
        Dtheta4: 1,
        Dtheta5: 0,
        Dtheta6: 0,
        Dtheta7: 0,
        Dtheta8: 0,
        Dtheta9: -0.33541054459782915,
        Dtheta10: -0.15,
        Dtheta11: -0.6,
        Dtheta12: 0
}
var Drumpose12 = {
        Dtheta1: 1.5,
        Dtheta2: 1,
        Dtheta3: 1.5,
        Dtheta4: 1,
        Dtheta5: 0,
        Dtheta6: 0,
        Dtheta7: 0,
        Dtheta8: 0,
        Dtheta9: -0.24679861721087304,
        Dtheta10: -0.06957476243696081,
        Dtheta11: 0,
        Dtheta12: 0
}
var Drumpose13 = {
        Dtheta1: 1.5,
        Dtheta2: 1,
        Dtheta3: 1.09501469296521,
        Dtheta4: 0,
        Dtheta5: 0,
        Dtheta6: 0,
        Dtheta7: 0,
        Dtheta8: 0,
        Dtheta9: 0.48424978373151495,
        Dtheta10: 0.08549611049021233,
        Dtheta11: 0,
        Dtheta12: 0
}
var Drumpose14 = {
        Dtheta1: 1.2057796021989051,
        Dtheta2: 0,
        Dtheta3: 1.5,
        Dtheta4: 1,
        Dtheta5: 0,
        Dtheta6: 0,
        Dtheta7: 0,
        Dtheta8: 0,
        Dtheta9: -0.33541054459782915,
        Dtheta10: -0.025268798743482757,
        Dtheta11: 0,
        Dtheta12: 0
}
var Drumpose15 = {
        Dtheta1: 1.5,
        Dtheta2: 1,
        Dtheta3: 1.5,
        Dtheta4: 0,
        Dtheta5: 0,
        Dtheta6: 0,
        Dtheta7: 0,
        Dtheta8: 0,
        Dtheta9: 0.48424978373151495,
        Dtheta10: 0.15,
        Dtheta11: 0,
        Dtheta12: 0.6
}
var Drumpose16 = {
        Dtheta1: 1.5,
        Dtheta2: 1,
        Dtheta3: 1.5,
        Dtheta4: 1,
        Dtheta5: 0,
        Dtheta6: 0,
        Dtheta7: 0,
        Dtheta8: 0,
        Dtheta9: 0.2184140015706466,
        Dtheta10: 0.17410803787716844,
        Dtheta11: 0,
        Dtheta12: 0
}

var Cymbalpose1 = {
        Ctheta1: 0.7,
        Ctheta2: 1,
        Ctheta3: 0.7,
        Ctheta4: 1,
        Ctheta5: 0,
        Ctheta6: 0,
        Ctheta7: 0,
        Ctheta8: 0,
        Ctheta9: 0,
        Ctheta10: 0,
        Ctheta11: 0.7500855658923833,
        Ctheta12:  -0.7500855658923833,
	}
var Cymbalpose2 = {
        Ctheta1: 0.7,
        Ctheta2: 1,
        Ctheta3: 0.7,
        Ctheta4: 1,
        Ctheta5: 0,
        Ctheta6: 0,
        Ctheta7: 0,
        Ctheta8: 0,
        Ctheta9: 0,
        Ctheta10: 0,
				Ctheta11: 0.37348487449781986,
        Ctheta12: -0.33541054459782915
}
var Cymbalpose3 = {
        Ctheta1: 0.7,
        Ctheta2: 1,
        Ctheta3: 0.7,
        Ctheta4: 1,
        Ctheta5: 0,
        Ctheta6: 0,
        Ctheta7: 0,
        Ctheta8: 0,
        Ctheta9: 0,
        Ctheta10: 0,
        Ctheta11: 0,
        Ctheta12: 0
}
var Cymbalpose4 = {
        Ctheta1: 0.7,
        Ctheta2: 1,
        Ctheta3: 0.7,
        Ctheta4: 1,
        Ctheta5: 0,
        Ctheta6: 0,
        Ctheta7: 0,
        Ctheta8: 0,
        Ctheta9: 0,
        Ctheta10: 0,
        Ctheta11:  0.24056698341738558,
        Ctheta12: -0.268951599057612
}

var Smalldrumpose1 = {
        Stheta1: 1.2,
        Stheta2: 0.4,
        Stheta3: 1.2,
        Stheta4: 0.4,
        Stheta5: 0,
        Stheta6: 0,
        Stheta7: 0,
        Stheta8: 0,
        Stheta9: -0.33541054459782915,
        Stheta10: -0.025268798743482757,
        Stheta11: -1.903427398586418,
        Stheta12: -1.202492653517395,
        Stheta13: 0,
        Stheta14: -1.7341642178391317
	}
var Smalldrumpose2 = {
        Stheta1: 1.2,
        Stheta2: 0.4,
        Stheta3: 1.2,
        Stheta4: 0.4,
        Stheta5: 0,
        Stheta6: 0,
        Stheta7: 0,
        Stheta8: 0,
        Stheta9: -0.24679861721087304,
        Stheta10: -0.06957476243696081,
        Stheta11: -1.903427398586418,
        Stheta12: -1.202492653517395,
        Stheta13: 0.797507346482605,
        Stheta14: -1.1581866898239168
}
var Smalldrumpose3 = {
        Stheta1: 1.2,
        Stheta2: 0.4,
        Stheta3: 1.2,
        Stheta4: 0.4,
        Stheta5: 0,
        Stheta6: 0,
        Stheta7: 0,
        Stheta8: 0,
        Stheta9: 0.48424978373151495,
        Stheta10: 0.08549611049021233,
        Stheta11: -1.903427398586418,
        Stheta12: -1.202492653517395,
        Stheta13: 1.7057796021989051,
        Stheta14: 0
}
var Smalldrumpose4 = {
        Stheta1: 1.2,
        Stheta2: 0.4,
        Stheta3: 1.2,
        Stheta4: 0.4,
        Stheta5: 0,
        Stheta6: 0,
        Stheta7: 0,
        Stheta8: 0,
        Stheta9: 0.2184140015706466,
        Stheta10: 0.17410803787716844,
        Stheta11: -1.903427398586418,
        Stheta12: -1.202492653517395,
        Stheta13: 1.1962610197239076,
        Stheta14: -0.7815859984293534
}

var Drumkeys = [
  [0, Drumpose16],
  [0.0625, Drumpose1],
  [0.1250, Drumpose2],
  [0.1875, Drumpose3],
  [0.2500, Drumpose4],
  [0.3125, Drumpose5],
  [0.3750, Drumpose6],
  [0.4375, Drumpose7],
  [0.5000, Drumpose8],
  [0.5625, Drumpose9],
  [0.6250, Drumpose10],
  [0.6875, Drumpose11],
  [0.7500, Drumpose12],
  [0.8125, Drumpose13],
  [0.8750, Drumpose14],
  [0.9375, Drumpose15],
  [1, Drumpose16]
];
var Cymbalkeys = [
  [0, Cymbalpose4],
  [0.250, Cymbalpose1],
  [0.500, Cymbalpose2],
  [0.750, Cymbalpose3],
  [1, Cymbalpose4]
];
var Smalldrumkeys = [
  [0, Smalldrumpose4],
  [0.250, Smalldrumpose1],
  [0.500, Smalldrumpose2],
  [0.750, Smalldrumpose3],
  [1, Smalldrumpose4]
];

var clock = new THREE.Clock();
var ts = clock.getElapsedTime(),tss = clock.getElapsedTime();  // start time
var intKey1 = [], intKey2 = [],intKey3 = [];
var soundTrack;
var isDimming = false, soundVal = 1.0, sign = 1.0;
var line;
var L = 1,kk = 80/3; 
var pathA = [],alpha;
////////////////////////
init();
animate();

function init() {
	let _iOSDevice = !!navigator.platform.match(/iPhone|iPod|iPad/);
	console.log ('iOS: ' + _iOSDevice)

	renderer	= new THREE.WebGLRenderer({
		// antialias	: true,
		alpha: true
	});
	renderer.setClearColor(new THREE.Color('lightgrey'), 0)
	// renderer.setPixelRatio( 1/2 );
	renderer.setSize( window.innerWidth, window.innerHeight );
	renderer.domElement.style.position = 'absolute'
	renderer.domElement.style.top = '0px'
	renderer.domElement.style.left = '0px'
	document.body.appendChild( renderer.domElement );

	renderer.autoClear = false;
	// init scene and camera
	scene	= new THREE.Scene();
	// Create a camera
	camera = new THREE.Camera();
	scene.add(camera);
  //currentPlane = 'PX';

	arToolkitSource = new THREEx.ArToolkitSource({
		// to read from the webcam 
		sourceType : 'webcam',

	})

	arToolkitSource.init(function onReady(){
		onResize()
	})
	
	// handle resize

	arToolkitContext = new THREEx.ArToolkitContext({
		cameraParametersUrl: THREEx.ArToolkitContext.baseURL + '../data/data/camera_para.dat',
		detectionMode: 'mono',
		maxDetectionRate: 30,
		canvasWidth: 80*3,
		canvasHeight: 60*3,
	})
	// initialize it
	arToolkitContext.init(function onCompleted(){
		// copy projection matrix to camera
		camera.projectionMatrix.copy( arToolkitContext.getProjectionMatrix() );
	})
	renderer.shadowMap.type = THREE.PCFSoftShadowMap
    renderer.shadowMap.enabled = true;

	markerA = new THREE.Group();
	var markerControlsA = new THREEx.ArMarkerControls(arToolkitContext, markerA, {
		type : 'pattern',
		patternUrl : THREEx.ArToolkitContext.baseURL + '../data/data/patt.Aletter',
	})
	scene.add (markerA);
	
  GroupA = new THREE.Group();
	markerA.add(GroupA);
  men[0] = buildDrumMan();
  car[0] = buildcar();
  men[0][0].position.set(0,0.1,0);
  car[0].add(men[0][0]);
  car[0].rotation.y = Math.PI/2;
  car[0].rotation.order = 'ZYX';
  GroupA.add(car[0]);
  GroupA.children[0].position.copy (new THREE.Vector3(0,0,0));
  GroupA.children[0].rotation.copy (new THREE.Euler(0, Math.PI/2, 0, 'ZYX'));
  let inA = addMarkerA();
	GroupA.add(inA[0],inA[1]);
  let drum = buildDrum();
  drum.rotation.y = Math.PI/2;
	GroupA.add(drum);

	markerB = new THREE.Group();
	var markerControlsB = new THREEx.ArMarkerControls(arToolkitContext, markerB, {
		type : 'pattern',
		patternUrl : THREEx.ArToolkitContext.baseURL + '../data/data/patt.Bletter',
	})
	scene.add (markerB);
	GroupB = new THREE.Group();
	markerB.add(GroupB);
  men[1] = buildCymbalMan();
  car[1] = buildcar();
  men[1][0].position.set(0,0.1,0);
  car[1].add(men[1][0]);
  car[1].rotation.y = -Math.PI/2;
  GroupB.add(car[1]);
  GroupB.children[0].position.set(0,- L/2, L/2);
  GroupB.children[0].rotation.copy(new THREE.Euler (-Math.PI/2, Math.PI, 0, 'ZYX'));
  let inB = addMarkerB();
	GroupB.add(inB[0],inB[1]);

	markerC = new THREE.Group();
	var markerControlsC = new THREEx.ArMarkerControls(arToolkitContext, markerC, {
		type : 'pattern',
		patternUrl : THREEx.ArToolkitContext.baseURL + '../data/data/patt.Cletter',
	})
	scene.add (markerC);
	GroupC = new THREE.Group();
	markerC.add(GroupC);
  men[2] = buildSmalldrumMan();
  car[2] = buildcar();
  men[2][0].position.set(0,0.1,0);
  car[2].add(men[2][0]);
  car[2].rotation.y = -Math.PI/2;
  GroupC.add(car[2]);
  GroupC.children[0].position.set(0,-L, 0);
  GroupC.children[0].rotation.copy(new THREE.Euler (0, -Math.PI/2, Math.PI, 'ZYX'));
  let inC = addMarkerC();
	GroupC.add(inC[0],inC[1]);

  markerD = new THREE.Group();
  var markerControlsD = new THREEx.ArMarkerControls(arToolkitContext, markerD, {
		type : 'pattern',
		patternUrl : THREEx.ArToolkitContext.baseURL + '../data/data/patt.Dletter',
	})
	scene.add (markerD);
	GroupD = new THREE.Group();
	markerD.add(GroupD);
  men[3] = buildCymbalMan();
  car[3] = buildcar();
  men[3][0].position.set(0,0.1,0);
  car[3].add(men[3][0]);
  car[3].rotation.y = -Math.PI/2;
  GroupD.add(car[3]);
  GroupD.children[0].position.set(0,-L/2, L/2);
  GroupD.children[0].rotation.copy(new THREE.Euler (Math.PI/2, 0, 0, 'ZYX'));
  let inD = addMarkerD();
	GroupD.add(inD[0],inD[1]);

  markerE = new THREE.Group();
  var markerControlsE = new THREEx.ArMarkerControls(arToolkitContext, markerE, {
		type : 'pattern',
		patternUrl : THREEx.ArToolkitContext.baseURL + '../data/data/patt.Eletter',
	})
	scene.add (markerE);
	GroupE = new THREE.Group();
	markerE.add(GroupE);
  men[4] = buildCymbalMan();
  car[4] = buildcar();
  men[4][0].position.set(0,0.1,0);
  car[4].add(men[4][0]);
  car[4].rotation.y = -Math.PI/2;
  GroupE.add(car[4]);
  GroupE.children[0].position.set(0,-L/2, L/2);
  GroupE.children[0].rotation.copy(new THREE.Euler (Math.PI/2, 0, Math.PI/2, 'ZYX'));
  let inE = addMarkerE();
	GroupE.add(inE[0],inE[1]);


  markerF = new THREE.Group();
  var markerControlsF = new THREEx.ArMarkerControls(arToolkitContext, markerF, {
		type : 'pattern',
		patternUrl : THREEx.ArToolkitContext.baseURL + '../data/data/patt.Fletter',
	})
	scene.add (markerF);
	GroupF = new THREE.Group();
	markerF.add(GroupF);
  men[5] = buildCymbalMan();
  car[5] = buildcar();
  men[5][0].position.set(0,0.1,0);
  car[5].add(men[5][0]);
  car[5].rotation.y = -Math.PI/2;
  GroupF.add(car[5]);
  GroupF.children[0].position.set(0,-L/2, -L/2);
  GroupF.children[0].rotation.copy(new THREE.Euler (-Math.PI/2, 0, -Math.PI/2, 'ZYX'));
  let inF = addMarkerF();
  GroupF.add(inF[0],inF[1]);
  ///////////////////////////////////////
  

	var ambient = new THREE.AmbientLight( 0x666666 );
	scene.add(ambient)

	let light = new THREE.PointLight( 0xffffff, 1, 1000 );
	light.position.set(1.5,3,1.5 ); // default; light shining from top
	light.castShadow = true;
	scene.add(light)

	stats = new Stats();
	document.body.appendChild( stats.dom );

	window.addEventListener('resize', function(){
		onResize()
	})
	faces = {'B': GroupB.children[0], 'E':GroupE.children[0],'A':GroupA.children[0]
  ,'D':GroupD.children[0],'F':GroupF.children[0],'C':GroupC.children[0]};
  /*if (_iOSDevice)
    	window.addEventListener('touchstart', onTouchStart, false);
	else
		window.addEventListener ('mousedown', onMouseDown, false);*/
}
function onResize(){
		arToolkitSource.onResize()	
		arToolkitSource.copySizeTo(renderer.domElement)	
		if( arToolkitContext.arController !== null ){
			arToolkitSource.copySizeTo(arToolkitContext.arController.canvas)	
		}
	}	
  function buildDrum(){
    box = new THREE.Group();
    var loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    var colormap = loader.load ('https://i.imgur.com/MTtMccq.jpg');
    var points = [];
    for ( var i = 0; i < 10; i ++ ) {
      points.push( new THREE.Vector2( Math.sin( i * 0.2 ) * 2 + 18, ( i - 5 ) * 2 ) );
    }
    var geometry = new THREE.LatheGeometry( points );
    var material = new THREE.MeshLambertMaterial( { map: colormap} );
    var lathe1 = new THREE.Mesh( geometry, material );
    lathe1.rotation.z=Math.PI/2;
    lathe1.position.set(0.48,0.45,0);
    scene.add( lathe1 );
    for ( var i = 0; i < 10; i ++ ) {
      points.push( new THREE.Vector2( Math.sin( i * 0.2 ) * 2 + 18, ( i - 5 ) * 2 ) );
    }

    var lathe2 = new THREE.Mesh( geometry, material );
    lathe2.rotation.z=-Math.PI/2;
    lathe2.position.set(0.33,0.45,0);
    scene.add( lathe2 );


    var geometry = new THREE.CylinderBufferGeometry(0.18, 0.18, 1, 64 );
    var material = new THREE.MeshLambertMaterial( {color: 0xeba434} );
    cylinder2 = new THREE.Mesh( geometry, material );
    cylinder2.position.set(0.23,0.45,0);
    cylinder2.rotation.z=-Math.PI/2;
    cylinder3 = new THREE.Mesh( geometry, material );
    cylinder3.position.set(0.58,0.45,0);
    cylinder3.rotation.z=-Math.PI/2;
    var loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    var colormap = loader.load ('https://i.imgur.com/rMKI0rA.jpg');
    var geometry = new THREE.CylinderBufferGeometry(1, 1, 50, 32 );
    var material = new THREE.MeshLambertMaterial( {map: colormap} );
    cylinder4 = new THREE.Mesh( geometry, material );
    cylinder4.position.set(0.51,0.18,0);
    cylinder4.rotation.x=-Math.PI/4;
    cylinder5 = new THREE.Mesh( geometry, material );
    cylinder5.position.set(0.51,0.18,0);
    cylinder5.rotation.x=Math.PI/4;
    cylinder6 = new THREE.Mesh( geometry, material );
    cylinder6.position.set(0.30,0.18,0);
    cylinder6.rotation.x=-Math.PI/4;
    cylinder7 = new THREE.Mesh( geometry, material );
    cylinder7.position.set(0.30,0.18,0);
    cylinder7.rotation.x=Math.PI/4;
    box.add(lathe1,lathe2,cylinder2,cylinder3,cylinder4,cylinder5,cylinder6,cylinder7);
    lathe1.castShadow = true;
    lathe1.receiveShadow = true;
    lathe2.castShadow = true;
    lathe2.receiveShadow = true;
    cylinder2.castShadow = true;
    cylinder2.receiveShadow = true;
    cylinder3.castShadow = true;
    cylinder3.receiveShadow = true;
    cylinder4.castShadow = true;
    cylinder4.receiveShadow = true;
    cylinder5.castShadow = true;
    cylinder5.receiveShadow = true;
    cylinder6.castShadow = true;
    cylinder6.receiveShadow = true;
    cylinder7.castShadow = true;
    cylinder7.receiveShadow = true;
    return box;
    }
  function buildDrumMan(){
    let man = new THREE.Group();
    //GroupA.add(mine);
    let head = makeDrumHead();
    let torso = makeDrumTorso();
    man.add(torso);
    head.position.y = 7.57*k-4.09*k;
    torso.position.y = 4.09*k;
    torso.add(head);

    let leftarm = makeDrumArm();
    leftarm[0].position.set (-1.88*k, 7.57*k-4.09*k, 0);
    leftarm[0].add(leftarm[1]);
    torso.add (leftarm[0]);
    let rightarm = makeDrumArm();
    rightarm[0].position.set (1.88*k, 7.57*k-4.09*k, 0);
    rightarm[0].add(rightarm[1]);
    torso.add(rightarm[0]);


    let leftleg = makeDrumLeg();
    leftleg[0].position.set  (-0.63*k, 4.09*k-4.09*k, 0);
    leftleg[0].add(leftleg[1]);
    torso.add(leftleg[0]);


    let rightleg = makeDrumLeg();
    rightleg[0].position.set (0.63*k, 4.09*k-4.09*k, 0);
    rightleg[0].add(rightleg[1]);
    torso.add(rightleg[0]);

    man.rotation.y=-Math.PI/2;	
    man.position.y=0.01;
    leftarm[0].rotation.z = -Math.PI/2;
    rightarm[0].rotation.z = -Math.PI/2;
    leftleg[0].rotation.z = -Math.PI/2;
    rightleg[0].rotation.z = -Math.PI/2;
    
    leftarm[0].rotation.order = 'ZYX';
    rightarm[0].rotation.order = 'ZYX';
    leftleg[0].rotation.order = 'ZYX';
    rightleg[0].rotation.order = 'ZYX';
    man.rotation.order = 'ZYX';
    return [man,head,torso,leftarm[0],leftarm[1],rightarm[0],rightarm[1],leftleg[0],leftleg[1],rightleg[0],rightleg[1],leftarm[2],rightarm[2]];
  }

  function makeDrumArm() {
    var group = new THREE.Group();
    var group2 = new THREE.Group();
    var geometry = new THREE.CylinderBufferGeometry(0.01, 0.01, 0.1, 32 );
    var material = new THREE.MeshLambertMaterial( {color: 0x803d0a} );
    let stick= new THREE.Mesh( geometry, material );
    let body3=buildDrumarm();
    body3.rotation.z=Math.PI/2;
    body3.position.x = 1.92*k;
    let body6=buildDrumarm2();
    body6.rotation.z=Math.PI/2;
    body6.position.x = 1.92*k;
    stick.position.set(2*k,0,-0.05);
    stick.rotation.x=Math.PI/2;
    group2.add(stick,body6);
    group.add (group2,body3);
    group2.position.x =2*k;
    
    body3.castShadow = true;
    body3.receiveShadow = true;
    body6.castShadow = true;
    body6.receiveShadow = true;
    stick.castShadow = true;
    stick.receiveShadow = true;
    //group.add (new THREE.AxesHelper (k));
    //group2.add (new THREE.AxesHelper (k));
    return [group,group2,stick];
  }
  function makeDrumLeg() {
    var group = new THREE.Group();
    var group2 = new THREE.Group();
    
    let body7=buildDrumleg();
    body7.rotation.z=Math.PI/2;
    body7.position.x = 2.046*k;
    let body8=buildDrumleg2();
    body8.rotation.z=Math.PI/2;
    body8.position.x = 2.046*k;
    group2.add(body8);
    group.add (group2,body7);
    group2.position.x =2.045*k;
    
    body7.castShadow = true;
    body7.receiveShadow = true;
    body8.castShadow = true;
    body8.receiveShadow = true;
    //group.add (new THREE.AxesHelper (k));
    //group2.add (new THREE.AxesHelper (k));
    return [group,group2];
  }
  function makeDrumHead() {
    var headGroup = new THREE.Group();
    let headBody2=buildDrumface();
    headBody2.rotation.y=Math.PI;
    headGroup.add (headBody2);
    
    headBody2.castShadow = true;
    headBody2.receiveShadow = true;
    //headGroup.add (new THREE.AxesHelper (k));
    return headGroup;
  }
  function makeDrumTorso () {
    var group = new THREE.Group();
    let Torsobody2=buildDrumTorso();
    Torsobody2.rotation.y=Math.PI;
    group.add (Torsobody2);
    
    Torsobody2.castShadow = true;
    Torsobody2.receiveShadow = true;
    //group.add (new THREE.AxesHelper (2*k));
  return group;

  }
  function buildDrumface() {
    let geometry = new THREE.Geometry();
    geometry.vertices.push(
      new THREE.Vector3(-2.53*k/2, 0, 2.53*k/2),
      new THREE.Vector3(2.53*k/2, 0, 2.53*k/2),
      new THREE.Vector3(2.53*k/2, 2.53*k, 2.53*k/2),
      new THREE.Vector3(-2.53*k/2, 2.53*k, 2.53*k/2),
      new THREE.Vector3(2.53*k/2, 0, -2.53*k/2),
      new THREE.Vector3(2.53*k/2, 2.53*k, -2.53*k/2),
      new THREE.Vector3(-2.53*k/2, 0, -2.53*k/2),
      new THREE.Vector3(-2.53*k/2, 2.53*k, -2.53*k/2),
    );


    let face;
    face = new THREE.Face3(0, 1, 2);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(2, 3, 0);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 4, 5);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 2, 1);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(4, 6, 7);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(7, 5, 4);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 0, 3);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 7, 6);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 2, 5);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 7, 3);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 4, 1);
    face.materialIndex = 5;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 0, 6);
    face.materialIndex = 5;
    geometry.faces.push(face);
    
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();

    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    let texture = loader.load('https://i.imgur.com/3d2gw9B.png');
    let texture1 = loader.load('https://i.imgur.com/XDyw0Rs.png');
    let texture2 = loader.load('https://i.imgur.com/8oxlNMA.png');
    let texture3 = loader.load('https://i.imgur.com/WjEobnE.png');
    let texture4 = loader.load('https://i.imgur.com/TLdR62i.png');
    let texture5 = loader.load('https://i.imgur.com/E57CwUJ.png');
    materialArray = [];
    materialArray.push(new THREE.MeshLambertMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture1
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }),
      new THREE.MeshPhongMaterial({
        map: texture3
      }),
      new THREE.MeshPhongMaterial({
        map: texture4
      }),
      new THREE.MeshPhongMaterial({
        map: texture5
      }));
    return new THREE.Mesh(geometry, materialArray);
  }
  function buildDrumTorso() {
    let geometry = new THREE.Geometry();
    geometry.vertices.push(
      new THREE.Vector3(-2.53*k/2, 0, 1.27*k/2),
      new THREE.Vector3(2.53*k/2, 0, 1.27*k/2),
      new THREE.Vector3(2.53*k/2, 3.48*k, 1.27*k/2),
      new THREE.Vector3(-2.53*k/2, 3.48*k, 1.27*k/2),
      new THREE.Vector3(2.53*k/2, 0, -1.27*k/2),
      new THREE.Vector3(2.53*k/2, 3.48*k, -1.27*k/2),
      new THREE.Vector3(-2.53*k/2, 0, -1.27*k/2),
      new THREE.Vector3(-2.53*k/2, 3.48*k, -1.27*k/2),
    );


    let face;
    face = new THREE.Face3(0, 1, 2);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(2, 3, 0);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 4, 5);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 2, 1);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(4, 6, 7);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(7, 5, 4);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 0, 3);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 7, 6);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 2, 5);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 7, 3);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 4, 1);
    face.materialIndex = 5;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 0, 6);
    face.materialIndex = 5;
    geometry.faces.push(face);
    
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();

    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    let texture = loader.load('https://i.imgur.com/SFPQbvU.png');
    let texture1 = loader.load('https://i.imgur.com/srIZpsC.png');
    let texture2 = loader.load('https://i.imgur.com/zgO9YE0.png');
    let texture3 = loader.load('https://i.imgur.com/srIZpsC.png');
    let texture4 = loader.load('https://i.imgur.com/iADRREk.png');
    let texture5 = loader.load('https://i.imgur.com/ZPH1PVI.png');
    materialArray = [];
    materialArray.push(new THREE.MeshLambertMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture1
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }),
      new THREE.MeshPhongMaterial({
        map: texture3
      }),
      new THREE.MeshPhongMaterial({
        map: texture4
      }),
      new THREE.MeshPhongMaterial({
        map: texture5
      }));
    return new THREE.Mesh(geometry, materialArray);
  }

  function buildDrumarm() {
    let geometry = new THREE.Geometry();
    geometry.vertices.push(
      new THREE.Vector3(-1.25*k/2, 0, 1.25*k/2),
      new THREE.Vector3(1.25*k/2, 0, 1.25*k/2),
      new THREE.Vector3(1.25*k/2, 1.93*k, 1.25*k/2),
      new THREE.Vector3(-1.25*k/2, 1.93*k, 1.25*k/2),
      new THREE.Vector3(1.25*k/2, 0, -1.25*k/2),
      new THREE.Vector3(1.25*k/2, 1.93*k, -1.25*k/2),
      new THREE.Vector3(-1.25*k/2, 0, -1.25*k/2),
      new THREE.Vector3(-1.25*k/2, 1.93*k, -1.25*k/2),
    );


    let face;
    face = new THREE.Face3(0, 1, 2);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(2, 3, 0);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 4, 5);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 2, 1);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(4, 6, 7);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(7, 5, 4);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 0, 3);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 7, 6);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 2, 5);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 7, 3);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 4, 1);
    face.materialIndex = 5;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 0, 6);
    face.materialIndex = 5;
    geometry.faces.push(face);
    
    
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();


    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    let texture = loader.load('https://i.imgur.com/GBmTa4L.png');
    let texture2 = loader.load('https://i.imgur.com/xWC8zfg.png');
    let texture3 = loader.load('https://i.imgur.com/eA5BB9i.png');
    materialArray = [];
    materialArray.push(new THREE.MeshLambertMaterial({
        map: texture
      }), 
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }),
      new THREE.MeshPhongMaterial({
        map: texture3
      }));
    return new THREE.Mesh(geometry, materialArray);
  }
  function buildDrumarm2() {
    let geometry = new THREE.Geometry();
    geometry.vertices.push(
      new THREE.Vector3(-1.25*k/2, 0, 1.25*k/2),
      new THREE.Vector3(1.25*k/2, 0, 1.25*k/2),
      new THREE.Vector3(1.25*k/2, 1.93*k, 1.25*k/2),
      new THREE.Vector3(-1.25*k/2, 1.93*k, 1.25*k/2),
      new THREE.Vector3(1.25*k/2, 0, -1.25*k/2),
      new THREE.Vector3(1.25*k/2, 1.93*k, -1.25*k/2),
      new THREE.Vector3(-1.25*k/2, 0, -1.25*k/2),
      new THREE.Vector3(-1.25*k/2, 1.93*k, -1.25*k/2),
    );


    let face;
    face = new THREE.Face3(0, 1, 2);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(2, 3, 0);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 4, 5);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 2, 1);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(4, 6, 7);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(7, 5, 4);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 0, 3);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 7, 6);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 2, 5);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 7, 3);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 4, 1);
    face.materialIndex = 5;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 0, 6);
    face.materialIndex = 5;
    geometry.faces.push(face);
    
    
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();


    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    let texture = loader.load('https://i.imgur.com/eA5BB9i.png');
    materialArray = [];
    materialArray.push(new THREE.MeshLambertMaterial({
        map: texture
      }), 
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }));
    return new THREE.Mesh(geometry, materialArray);
  }

  function buildDrumleg() {
    let geometry = new THREE.Geometry();
    geometry.vertices.push(
      new THREE.Vector3(-1.27*k/2, 0, 1.27*k/2),
      new THREE.Vector3(1.27*k/2, 0, 1.27*k/2),
      new THREE.Vector3(1.27*k/2, 2.046*k, 1.27*k/2),
      new THREE.Vector3(-1.27*k/2, 2.046*k, 1.27*k/2),
      new THREE.Vector3(1.27*k/2, 0, -1.27*k/2),
      new THREE.Vector3(1.27*k/2, 2.046*k, -1.27*k/2),
      new THREE.Vector3(-1.27*k/2, 0, -1.27*k/2),
      new THREE.Vector3(-1.27*k/2, 2.046*k, -1.27*k/2),
    );


    let face;
    face = new THREE.Face3(0, 1, 2);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(2, 3, 0);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 4, 5);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 2, 1);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(4, 6, 7);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(7, 5, 4);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 0, 3);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 7, 6);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 2, 5);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 7, 3);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 4, 1);
    face.materialIndex = 5;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 0, 6);
    face.materialIndex = 5;
    geometry.faces.push(face);
    
    
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();


    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    let texture = loader.load('https://i.imgur.com/HdgeyBu.png');
    let texture2 = loader.load('https://i.imgur.com/6mpD0ol.png');
    let texture3 = loader.load('https://i.imgur.com/eA5BB9i.png');
    materialArray = [];
    materialArray.push(new THREE.MeshLambertMaterial({
        map: texture
      }), 
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }),
      new THREE.MeshPhongMaterial({
        map: texture3
      }));
    return new THREE.Mesh(geometry, materialArray);
  }
  function buildDrumleg2() {
    let geometry = new THREE.Geometry();
    geometry.vertices.push(
      new THREE.Vector3(-1.27*k/2, 0, 1.27*k/2),
      new THREE.Vector3(1.27*k/2, 0, 1.27*k/2),
      new THREE.Vector3(1.27*k/2, 2.046*k, 1.27*k/2),
      new THREE.Vector3(-1.27*k/2, 2.046*k, 1.27*k/2),
      new THREE.Vector3(1.27*k/2, 0, -1.27*k/2),
      new THREE.Vector3(1.27*k/2, 2.046*k, -1.27*k/2),
      new THREE.Vector3(-1.27*k/2, 0, -1.27*k/2),
      new THREE.Vector3(-1.27*k/2, 2.046*k, -1.27*k/2),
    );


    let face;
    face = new THREE.Face3(0, 1, 2);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(2, 3, 0);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 4, 5);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 2, 1);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(4, 6, 7);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(7, 5, 4);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 0, 3);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 7, 6);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 2, 5);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 7, 3);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 4, 1);
    face.materialIndex = 5;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 0, 6);
    face.materialIndex = 5;
    geometry.faces.push(face);
    
    
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();


    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    let texture = loader.load('https://i.imgur.com/4ojGjEo.png');
    let texture2 = loader.load('https://i.imgur.com/eA5BB9i.png');
    let texture3 = loader.load('https://i.imgur.com/Xsw5JHL.png');
    materialArray = [];
    materialArray.push(new THREE.MeshLambertMaterial({
        map: texture
      }), 
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }),
      new THREE.MeshPhongMaterial({
        map: texture3
      }));
    return new THREE.Mesh(geometry, materialArray);
  }

  function buildCymbalMan(){
    let man = new THREE.Group();
    //GroupA.add(mine);
    let head = makeCymbalHead();
    let torso = makeCymbalTorso();
    man.add(torso);
    head.position.y = 7.57*k-4.09*k;
    torso.position.y = 4.09*k;
    torso.add(head);
    var loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    var colormap = loader.load ('https://i.imgur.com/54uWXuj.jpg');
    var geometry = new THREE.CylinderBufferGeometry(0.05, 0.1, 0.01, 32 );
    var material = new THREE.MeshLambertMaterial( {map: colormap} );
    let stick= new THREE.Mesh( geometry, material );
    let stick2= new THREE.Mesh( geometry, material );
    var geometry = new THREE.BoxGeometry(0.02, 0.01, 0.01, 32 );
    var material = new THREE.MeshLambertMaterial( {color: 'red'} );
    line= new THREE.Mesh( geometry, material );
    line2= new THREE.Mesh( geometry, material );
    
    let leftarm = makeCymbalArm();
    stick.position.set(2*k,0.03,0);
    stick.rotation.z+=Math.PI*3/4;
    line.position.set(2*k,0.01,0);
    line.rotation.z=Math.PI/4;
    let cymbal1 = new THREE.Group();
    cymbal1.add(stick,line);
    leftarm[0].position.set (-1.88*k, 7.57*k-4.09*k, 0);
    leftarm[0].add(leftarm[1]);
    leftarm[1].add(cymbal1);
    torso.add (leftarm[0]);
    stick.castShadow = true;
    stick.receiveShadow = true;
    line.castShadow = true;
    line.receiveShadow = true;
    
    let rightarm = makeCymbalArm();
    stick2.position.set(2*k,-0.03,0);
    stick2.rotation.z=Math.PI/5;
    line2.position.set(2*k,-0.01,0);
    line2.rotation.z=-Math.PI/4;
    let cymbal2 = new THREE.Group();
    cymbal2.add(stick2,line2);
    rightarm[0].position.set (1.88*k, 7.57*k-4.09*k, 0);
    rightarm[0].add(rightarm[1]);
    rightarm[1].add(cymbal2);
    torso.add(rightarm[0]);
    stick2.castShadow = true;
    stick2.receiveShadow = true;
    line2.castShadow = true;
    line2.receiveShadow = true;
    
    
    let leftleg = makeCymbalLeg();
    leftleg[0].position.set  (-0.63*k, 4.09*k-4.09*k, 0);
    leftleg[0].add(leftleg[1]);
    torso.add(leftleg[0]);


    let rightleg = makeCymbalLeg();
    rightleg[0].position.set (0.63*k, 4.09*k-4.09*k, 0);
    rightleg[0].add(rightleg[1]);
    torso.add(rightleg[0]);

    man.rotation.y=-Math.PI/2;	
    man.position.y=0.01;
    leftarm[0].rotation.z = -Math.PI/2;
    rightarm[0].rotation.z = -Math.PI/2;
    leftleg[0].rotation.z = -Math.PI/2;
    rightleg[0].rotation.z = -Math.PI/2;
    
    leftarm[0].rotation.order = 'ZYX';
    rightarm[0].rotation.order = 'ZYX';
    leftleg[0].rotation.order = 'ZYX';
    rightleg[0].rotation.order = 'ZYX';
    man.rotation.order = 'ZYX';
    return [man,head,torso,leftarm[0],leftarm[1],rightarm[0],rightarm[1],leftleg[0],leftleg[1],rightleg[0],rightleg[1],cymbal1,cymbal2];
  }

  function makeCymbalArm() {
    var group = new THREE.Group();
    var group2 = new THREE.Group();
    body3=buildCymbalarm();
    body3.rotation.z=Math.PI/2;
    body3.position.x = 1.92*k;
    body8=buildCymbalarm2();
    body8.rotation.z=Math.PI/2;
    body8.position.x = 1.92*k;
    group2.add(body8);
    group.add (group2,body3);
    group2.position.x =2*k;
    
    
    body3.castShadow = true;
    body3.receiveShadow = true;
    body8.castShadow = true;
    body8.receiveShadow = true;

    //group.add (new THREE.AxesHelper (k));
    //group2.add (new THREE.AxesHelper (k));
    return [group,group2];
  }
  function makeCymbalLeg() {
    var group = new THREE.Group();
    var group2 = new THREE.Group();
    body7=buildCymballeg();
    body7.rotation.z=Math.PI/2;
    body7.position.x = 2.046*k;
    body8=buildCymballeg2();
    body8.rotation.z=Math.PI/2;
    body8.position.x = 2.046*k;
    group2.add(body8);
    group.add (group2,body7);
    group2.position.x =2.045*k;
    
    body7.castShadow = true;
    body7.receiveShadow = true;
    body8.castShadow = true;
    body8.receiveShadow = true;
    //group.add (new THREE.AxesHelper (k));
    //group2.add (new THREE.AxesHelper (k));
    return [group,group2];
  }
  function makeCymbalHead() {
    var headGroup = new THREE.Group();
    headBody2=buildCymbalface();
    headBody2.rotation.y=Math.PI;
    headGroup.add (headBody2);

    headBody2.castShadow = true;
    headBody2.receiveShadow = true;
    //headGroup.add (new THREE.AxesHelper (k));
    return headGroup;
  }
  function makeCymbalTorso () {
    var group = new THREE.Group();
    var material = new THREE.MeshLambertMaterial( { color:0xd0d0c,side:THREE.DoubleSide } );
    Torsobody2=buildCymbalTorso();
    Torsobody2.rotation.y=Math.PI;
    group.add (Torsobody2);
      
    Torsobody2.castShadow = true;
    Torsobody2.receiveShadow = true;
    //group.add (new THREE.AxesHelper (2*k));
  return group;

  }
  function buildCymbalface() {
    let geometry = new THREE.Geometry();
    geometry.vertices.push(
      new THREE.Vector3(-2.53*k/2, 0, 2.53*k/2),
      new THREE.Vector3(2.53*k/2, 0, 2.53*k/2),
      new THREE.Vector3(2.53*k/2, 2.53*k, 2.53*k/2),
      new THREE.Vector3(-2.53*k/2, 2.53*k, 2.53*k/2),
      new THREE.Vector3(2.53*k/2, 0, -2.53*k/2),
      new THREE.Vector3(2.53*k/2, 2.53*k, -2.53*k/2),
      new THREE.Vector3(-2.53*k/2, 0, -2.53*k/2),
      new THREE.Vector3(-2.53*k/2, 2.53*k, -2.53*k/2),
    );


    let face;
    face = new THREE.Face3(0, 1, 2);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(2, 3, 0);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 4, 5);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 2, 1);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(4, 6, 7);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(7, 5, 4);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 0, 3);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 7, 6);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 2, 5);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 7, 3);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 4, 1);
    face.materialIndex = 5;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 0, 6);
    face.materialIndex = 5;
    geometry.faces.push(face);
    
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();

    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    let texture = loader.load('https://i.imgur.com/IYkzEoo.png');
    let texture1 = loader.load('https://i.imgur.com/UyF6RiR.png');
    let texture2 = loader.load('https://i.imgur.com/3vfswFa.png');
    let texture3 = loader.load('https://i.imgur.com/UQYNSe6.png');
    let texture4 = loader.load('https://i.imgur.com/TLdR62i.png');
    let texture5 = loader.load('https://i.imgur.com/E57CwUJ.png');
    materialArray = [];
    materialArray.push(new THREE.MeshLambertMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture1
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }),
      new THREE.MeshPhongMaterial({
        map: texture3
      }),
      new THREE.MeshPhongMaterial({
        map: texture4
      }),
      new THREE.MeshPhongMaterial({
        map: texture5
      }));
    return new THREE.Mesh(geometry, materialArray);
  }
  function buildCymbalTorso() {
    let geometry = new THREE.Geometry();
    geometry.vertices.push(
      new THREE.Vector3(-2.53*k/2, 0, 1.27*k/2),
      new THREE.Vector3(2.53*k/2, 0, 1.27*k/2),
      new THREE.Vector3(2.53*k/2, 3.48*k, 1.27*k/2),
      new THREE.Vector3(-2.53*k/2, 3.48*k, 1.27*k/2),
      new THREE.Vector3(2.53*k/2, 0, -1.27*k/2),
      new THREE.Vector3(2.53*k/2, 3.48*k, -1.27*k/2),
      new THREE.Vector3(-2.53*k/2, 0, -1.27*k/2),
      new THREE.Vector3(-2.53*k/2, 3.48*k, -1.27*k/2),
    );


    let face;
    face = new THREE.Face3(0, 1, 2);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(2, 3, 0);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 4, 5);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 2, 1);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(4, 6, 7);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(7, 5, 4);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 0, 3);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 7, 6);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 2, 5);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 7, 3);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 4, 1);
    face.materialIndex = 5;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 0, 6);
    face.materialIndex = 5;
    geometry.faces.push(face);
    
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();

    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    let texture = loader.load('https://i.imgur.com/Cx06iy5.png');
    let texture1 = loader.load('https://i.imgur.com/X7OW52g.png');
    let texture2 = loader.load('https://i.imgur.com/9DKgJ8s.png');
    let texture3 = loader.load('https://i.imgur.com/X7OW52g.png');
    let texture4 = loader.load('https://i.imgur.com/wXgv152.png');
    let texture5 = loader.load('https://i.imgur.com/9DKgJ8s.png');
    materialArray = [];
    materialArray.push(new THREE.MeshLambertMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture1
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }),
      new THREE.MeshPhongMaterial({
        map: texture3
      }),
      new THREE.MeshPhongMaterial({
        map: texture4
      }),
      new THREE.MeshPhongMaterial({
        map: texture5
      }));
    return new THREE.Mesh(geometry, materialArray);
  }
  function buildCymbalarm() {
    let geometry = new THREE.Geometry();
    geometry.vertices.push(
      new THREE.Vector3(-1.25*k/2, 0, 1.25*k/2),
      new THREE.Vector3(1.25*k/2, 0, 1.25*k/2),
      new THREE.Vector3(1.25*k/2, 1.93*k, 1.25*k/2),
      new THREE.Vector3(-1.25*k/2, 1.93*k, 1.25*k/2),
      new THREE.Vector3(1.25*k/2, 0, -1.25*k/2),
      new THREE.Vector3(1.25*k/2, 1.93*k, -1.25*k/2),
      new THREE.Vector3(-1.25*k/2, 0, -1.25*k/2),
      new THREE.Vector3(-1.25*k/2, 1.93*k, -1.25*k/2),
    );


    let face;
    face = new THREE.Face3(0, 1, 2);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(2, 3, 0);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 4, 5);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 2, 1);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(4, 6, 7);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(7, 5, 4);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 0, 3);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 7, 6);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 2, 5);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 7, 3);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 4, 1);
    face.materialIndex = 5;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 0, 6);
    face.materialIndex = 5;
    geometry.faces.push(face);
    
    
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();


    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    let texture = loader.load('https://i.imgur.com/Reypdny.png');
    let texture2 = loader.load('https://i.imgur.com/UHYXfSO.png');
    let texture3 = loader.load('https://i.imgur.com/zDr6SGt.png');
    materialArray = [];
    materialArray.push(new THREE.MeshLambertMaterial({
        map: texture
      }), 
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }),
      new THREE.MeshPhongMaterial({
        map: texture3
      }));
    return new THREE.Mesh(geometry, materialArray);
  }
  function buildCymbalarm2() {
    let geometry = new THREE.Geometry();
    geometry.vertices.push(
      new THREE.Vector3(-1.25*k/2, 0, 1.25*k/2),
      new THREE.Vector3(1.25*k/2, 0, 1.25*k/2),
      new THREE.Vector3(1.25*k/2, 1.93*k, 1.25*k/2),
      new THREE.Vector3(-1.25*k/2, 1.93*k, 1.25*k/2),
      new THREE.Vector3(1.25*k/2, 0, -1.25*k/2),
      new THREE.Vector3(1.25*k/2, 1.93*k, -1.25*k/2),
      new THREE.Vector3(-1.25*k/2, 0, -1.25*k/2),
      new THREE.Vector3(-1.25*k/2, 1.93*k, -1.25*k/2),
    );


    let face;
    face = new THREE.Face3(0, 1, 2);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(2, 3, 0);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 4, 5);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 2, 1);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(4, 6, 7);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(7, 5, 4);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 0, 3);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 7, 6);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 2, 5);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 7, 3);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 4, 1);
    face.materialIndex = 5;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 0, 6);
    face.materialIndex = 5;
    geometry.faces.push(face);
    
    
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();


    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    let texture = loader.load('https://i.imgur.com/iAEsM2q.png');
    let texture2 = loader.load('https://i.imgur.com/zDr6SGt.png');
    materialArray = [];
    materialArray.push(new THREE.MeshLambertMaterial({
        map: texture
      }), 
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }));
    return new THREE.Mesh(geometry, materialArray);
  }
  function buildCymballeg() {
    let geometry = new THREE.Geometry();
    geometry.vertices.push(
      new THREE.Vector3(-1.27*k/2, 0, 1.27*k/2),
      new THREE.Vector3(1.27*k/2, 0, 1.27*k/2),
      new THREE.Vector3(1.27*k/2, 2.046*k, 1.27*k/2),
      new THREE.Vector3(-1.27*k/2, 2.046*k, 1.27*k/2),
      new THREE.Vector3(1.27*k/2, 0, -1.27*k/2),
      new THREE.Vector3(1.27*k/2, 2.046*k, -1.27*k/2),
      new THREE.Vector3(-1.27*k/2, 0, -1.27*k/2),
      new THREE.Vector3(-1.27*k/2, 2.046*k, -1.27*k/2),
    );


    let face;
    face = new THREE.Face3(0, 1, 2);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(2, 3, 0);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 4, 5);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 2, 1);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(4, 6, 7);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(7, 5, 4);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 0, 3);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 7, 6);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 2, 5);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 7, 3);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 4, 1);
    face.materialIndex = 5;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 0, 6);
    face.materialIndex = 5;
    geometry.faces.push(face);
    
    
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();


    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    let texture = loader.load('https://i.imgur.com/Reypdny.png');
    let texture2 = loader.load('https://i.imgur.com/UHYXfSO.png');
    let texture3 = loader.load('https://i.imgur.com/zDr6SGt.png');
    materialArray = [];
    materialArray.push(new THREE.MeshLambertMaterial({
        map: texture
      }), 
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }),
      new THREE.MeshPhongMaterial({
        map: texture3
      }));
    return new THREE.Mesh(geometry, materialArray);
  }
  function buildCymballeg2() {
    let geometry = new THREE.Geometry();
    geometry.vertices.push(
      new THREE.Vector3(-1.27*k/2, 0, 1.27*k/2),
      new THREE.Vector3(1.27*k/2, 0, 1.27*k/2),
      new THREE.Vector3(1.27*k/2, 2.046*k, 1.27*k/2),
      new THREE.Vector3(-1.27*k/2, 2.046*k, 1.27*k/2),
      new THREE.Vector3(1.27*k/2, 0, -1.27*k/2),
      new THREE.Vector3(1.27*k/2, 2.046*k, -1.27*k/2),
      new THREE.Vector3(-1.27*k/2, 0, -1.27*k/2),
      new THREE.Vector3(-1.27*k/2, 2.046*k, -1.27*k/2),
    );


    let face;
    face = new THREE.Face3(0, 1, 2);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(2, 3, 0);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 4, 5);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 2, 1);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(4, 6, 7);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(7, 5, 4);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 0, 3);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 7, 6);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 2, 5);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 7, 3);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 4, 1);
    face.materialIndex = 5;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 0, 6);
    face.materialIndex = 5;
    geometry.faces.push(face);
    
    
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();


    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    let texture = loader.load('https://i.imgur.com/Reypdny.png');
    let texture2 = loader.load('https://i.imgur.com/zDr6SGt.png');
    materialArray = [];
    materialArray.push(new THREE.MeshLambertMaterial({
        map: texture
      }), 
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }));
    return new THREE.Mesh(geometry, materialArray);
  }

  function buildSmalldrum(){
    box = new THREE.Group();
    var geometry = new THREE.CylinderBufferGeometry(10, 10, 13.1, 32 );
    var material = new THREE.MeshLambertMaterial( {color: 'white'} );
    cylinder1 = new THREE.Mesh( geometry, material );
    cylinder1.position.set(0,-1,-2.8*k);
    var geometry = new THREE.CylinderBufferGeometry(10.1, 10.1, 13, 32 );
    var material = new THREE.MeshLambertMaterial( {color: 'blue'} );
    cylinder2 = new THREE.Mesh( geometry, material );
    cylinder2.position.set(0,-1,-2.8*k);
    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    let texture = loader.load('https://i.imgur.com/DvME6OT.jpg');
    var geometry = new THREE.TorusBufferGeometry( 10.1, 0.5, 32, 100 );
    var material = new THREE.MeshLambertMaterial( { map: texture } );
    cylinder3 = new THREE.Mesh( geometry, material );
    cylinder3.rotation.x=Math.PI/2;
    cylinder3.position.set(0,6,-2.8*k);
    cylinder4 = new THREE.Mesh( geometry, material );
    cylinder4.rotation.x=Math.PI/2;
    cylinder4.position.set(0,-8,-2.8*k);
    var geometry = new THREE.BoxBufferGeometry( 14, 1, 1 );
    var material = new THREE.MeshLambertMaterial( {map: texture } );
    BoxBuffer1= new THREE.Mesh( geometry, material );
    BoxBuffer1.rotation.z=Math.PI/2;
    BoxBuffer1.position.set(10,-1,-2.8*k);
    BoxBuffer2= new THREE.Mesh( geometry, material );
    BoxBuffer2.rotation.z=Math.PI/2;
    BoxBuffer2.position.set(7.5,-1,-4.1*k);
    BoxBuffer3= new THREE.Mesh( geometry, material );
    BoxBuffer3.rotation.z=Math.PI/2;
    BoxBuffer3.position.set(0,-1,-4.8*k);
    BoxBuffer4= new THREE.Mesh( geometry, material );
    BoxBuffer4.rotation.z=Math.PI/2;
    BoxBuffer4.position.set(-7.5,-1,-4.1*k);
    BoxBuffer5= new THREE.Mesh( geometry, material );
    BoxBuffer5.rotation.z=Math.PI/2;
    BoxBuffer5.position.set(-10,-1,-2.8*k);
    BoxBuffer6= new THREE.Mesh( geometry, material );
    BoxBuffer6.rotation.z=Math.PI/2;
    BoxBuffer6.position.set(-7.5,-1,-1.5*k);
    BoxBuffer7= new THREE.Mesh( geometry, material );
    BoxBuffer7.rotation.z=Math.PI/2;
    BoxBuffer7.position.set(0,-1,-0.8*k);
    BoxBuffer8= new THREE.Mesh( geometry, material );
    BoxBuffer8.rotation.z=Math.PI/2;
    BoxBuffer8.position.set(7.5,-1,-1.5*k);
    var material = new THREE.MeshLambertMaterial( { color: 'white',side:THREE.DoubleSide } );
    line1 = new THREE.Mesh (new THREE.BoxGeometry(25, 1,1), material); 
    line1.position.set(-1.6*k,12,-1.2*k);
    line1.rotation.set(0,-Math.PI/2.6,Math.PI/4);
    line2 = new THREE.Mesh (new THREE.BoxGeometry(25, 1, 1), material); 
    line2.position.set(1.6*k,12,-1.2*k);
    line2.rotation.set(0,Math.PI/2.6,-Math.PI/4);
    var material = new THREE.MeshLambertMaterial( { color: 'white',side:THREE.DoubleSide } );
    line3 = new THREE.Mesh (new THREE.BoxGeometry(14, 1, 1), material); 
    line3.position.set(0,17,1);
    line3.rotation.y=Math.PI;
    box.add(cylinder1,cylinder2,cylinder3,cylinder4,BoxBuffer1,BoxBuffer2,BoxBuffer3,BoxBuffer4,BoxBuffer5,BoxBuffer6,BoxBuffer7,BoxBuffer8,line1,line2,line3);
    cylinder1.castShadow = true;
    cylinder1.receiveShadow = true;
    cylinder2.castShadow = true;
    cylinder2.receiveShadow = true;
    cylinder3.castShadow = true;
    cylinder3.receiveShadow = true;
    cylinder4.castShadow = true;
    cylinder4.receiveShadow = true;
    BoxBuffer1.castShadow = true;
    BoxBuffer1.receiveShadow = true;
    BoxBuffer2.castShadow = true;
    BoxBuffer2.receiveShadow = true;
    BoxBuffer3.castShadow = true;
    BoxBuffer3.receiveShadow = true;
    BoxBuffer4.castShadow = true;
    BoxBuffer4.receiveShadow = true;
    BoxBuffer5.castShadow = true;
    BoxBuffer5.receiveShadow = true;
    BoxBuffer6.castShadow = true;
    BoxBuffer6.receiveShadow = true;
    BoxBuffer7.castShadow = true;
    BoxBuffer7.receiveShadow = true;
    BoxBuffer8.castShadow = true;
    BoxBuffer8.receiveShadow = true;
    line1.castShadow = true;
    line1.receiveShadow = true;
    line2.castShadow = true;
    line2.receiveShadow = true;
    line3.castShadow = true;
    line3.receiveShadow = true;
    return box;
    }
  function buildSmalldrumMan(){
    let man = new THREE.Group();
    //GroupA.add(mine);
    let head = makeSmalldrumHead();
    let torso = makeSmalldrumTorso();
    let drum=buildSmalldrum();
    man.add(torso);
    head.position.y = 7.57*k-4.09*k;
    torso.position.y = 4.09*k;
    torso.add(head,drum);

    let leftarm = makeSmalldrumArm();
    leftarm[0].position.set (-1.88*k, 7.57*k-4.09*k, 0);
    leftarm[0].add(leftarm[1]);
    torso.add (leftarm[0]);
    let rightarm = makeSmalldrumArm();
    rightarm[0].position.set (1.88*k, 7.57*k-4.09*k, 0);
    rightarm[0].add(rightarm[1]);
    torso.add(rightarm[0]);


    let leftleg = makeSmalldrumLeg();
    leftleg[0].position.set  (-0.63*k, 4.09*k-4.09*k, 0);
    leftleg[0].add(leftleg[1]);
    torso.add(leftleg[0]);


    let rightleg = makeSmalldrumLeg();
    rightleg[0].position.set (0.63*k, 4.09*k-4.09*k, 0);
    rightleg[0].add(rightleg[1]);
    torso.add(rightleg[0]);

    man.rotation.y=-Math.PI/2;	
    man.position.y=0.01;
    leftarm[0].rotation.z = -Math.PI/2;
    rightarm[0].rotation.z = -Math.PI/2;
    leftleg[0].rotation.z = -Math.PI/2;
    rightleg[0].rotation.z = -Math.PI/2;
    
    leftarm[0].rotation.order = 'ZYX';
    rightarm[0].rotation.order = 'ZYX';
    leftleg[0].rotation.order = 'ZYX';
    rightleg[0].rotation.order = 'ZYX';
    man.rotation.order = 'ZYX';
    return [man,head,torso,leftarm[0],leftarm[1],rightarm[0],rightarm[1],leftleg[0],leftleg[1],rightleg[0],rightleg[1],leftarm[2],rightarm[2],drum];
  }
  function makeSmalldrumArm() {
    var group = new THREE.Group();
    var group2 = new THREE.Group();
    var stick = new THREE.Group();
    var geometry = new THREE.CylinderBufferGeometry(1, 0.5, 10, 32 );
    var material = new THREE.MeshLambertMaterial( {color: 0xcc7818} );
    box= new THREE.Mesh( geometry, material );
    var geometry = new THREE.DodecahedronBufferGeometry(1,5 );
    var material = new THREE.MeshLambertMaterial( {color: 0xcc7818} );
    ball= new THREE.Mesh( geometry, material );
    body3=buildSmalldrumarm();
    body3.rotation.z=Math.PI/2;
    body3.position.x = 1.92*k;
    body6=buildSmalldrumarm2();
    body6.rotation.z=Math.PI/2;
    body6.position.x = 1.92*k;
    box.position.set(2*k,0,-5);
    box.rotation.x=Math.PI/2;
    ball.position.set(2*k,0,-10);
    stick.add(ball,box);
    group2.add(stick,body6);
    group.add (group2,body3);

    group2.position.x =2*k;
    body3.castShadow = true;
    body3.receiveShadow = true;
    body6.castShadow = true;
    body6.receiveShadow = true;
    stick.castShadow = true;
    stick.receiveShadow = true;
    //group.add (new THREE.AxesHelper (k));
    //group2.add (new THREE.AxesHelper (k));
    return [group,group2,stick];
  }
  function makeSmalldrumLeg() {
    var group = new THREE.Group();
    var group2 = new THREE.Group();
    body7=buildSmalldrumleg();
    body7.rotation.z=Math.PI/2;
    body7.position.x = 2.046*k;
    body8=buildSmalldrumleg2();
    body8.rotation.z=Math.PI/2;
    body8.position.x = 2.046*k;
    group2.add(body8);
    group.add (group2,body7);
    group2.position.x =2.045*k;
    
    body7.castShadow = true;
    body7.receiveShadow = true;
    body8.castShadow = true;
    body8.receiveShadow = true;
    //group.add (new THREE.AxesHelper (k));
    //group2.add (new THREE.AxesHelper (k));
    return [group,group2];
  }
  function makeSmalldrumHead() {
    var headGroup = new THREE.Group();
    headBody2=buildSmalldrumface();
    headBody2.rotation.y=Math.PI;
    headGroup.add (headBody2);
    
    headBody2.castShadow = true;
    headBody2.receiveShadow = true;
    //headGroup.add (new THREE.AxesHelper (k));
    return headGroup;
  }
  function makeSmalldrumTorso () {
    var group = new THREE.Group();
    Torsobody2=buildSmalldrumTorso();
    Torsobody2.rotation.y=Math.PI;
    group.add (Torsobody2);
    
    Torsobody2.castShadow = true;
    Torsobody2.receiveShadow = true;
    //group.add (new THREE.AxesHelper (2*k));
  return group;

  }
  function buildSmalldrumface() {
    let geometry = new THREE.Geometry();
    geometry.vertices.push(
      new THREE.Vector3(-2.53*k/2, 0, 2.53*k/2),
      new THREE.Vector3(2.53*k/2, 0, 2.53*k/2),
      new THREE.Vector3(2.53*k/2, 2.53*k, 2.53*k/2),
      new THREE.Vector3(-2.53*k/2, 2.53*k, 2.53*k/2),
      new THREE.Vector3(2.53*k/2, 0, -2.53*k/2),
      new THREE.Vector3(2.53*k/2, 2.53*k, -2.53*k/2),
      new THREE.Vector3(-2.53*k/2, 0, -2.53*k/2),
      new THREE.Vector3(-2.53*k/2, 2.53*k, -2.53*k/2),
    );


    let face;
    face = new THREE.Face3(0, 1, 2);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(2, 3, 0);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 4, 5);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 2, 1);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(4, 6, 7);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(7, 5, 4);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 0, 3);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 7, 6);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 2, 5);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 7, 3);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 4, 1);
    face.materialIndex = 5;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 0, 6);
    face.materialIndex = 5;
    geometry.faces.push(face);
    
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();

    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    let texture = loader.load('https://i.imgur.com/IYkzEoo.png');
    let texture1 = loader.load('https://i.imgur.com/UyF6RiR.png');
    let texture2 = loader.load('https://i.imgur.com/3vfswFa.png');
    let texture3 = loader.load('https://i.imgur.com/UQYNSe6.png');
    let texture4 = loader.load('https://i.imgur.com/TLdR62i.png');
    let texture5 = loader.load('https://i.imgur.com/E57CwUJ.png');
    materialArray = [];
    materialArray.push(new THREE.MeshLambertMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture1
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }),
      new THREE.MeshPhongMaterial({
        map: texture3
      }),
      new THREE.MeshPhongMaterial({
        map: texture4
      }),
      new THREE.MeshPhongMaterial({
        map: texture5
      }));
    return new THREE.Mesh(geometry, materialArray);
  }
  function buildSmalldrumTorso() {
    let geometry = new THREE.Geometry();
    geometry.vertices.push(
      new THREE.Vector3(-2.53*k/2, 0, 1.27*k/2),
      new THREE.Vector3(2.53*k/2, 0, 1.27*k/2),
      new THREE.Vector3(2.53*k/2, 3.48*k, 1.27*k/2),
      new THREE.Vector3(-2.53*k/2, 3.48*k, 1.27*k/2),
      new THREE.Vector3(2.53*k/2, 0, -1.27*k/2),
      new THREE.Vector3(2.53*k/2, 3.48*k, -1.27*k/2),
      new THREE.Vector3(-2.53*k/2, 0, -1.27*k/2),
      new THREE.Vector3(-2.53*k/2, 3.48*k, -1.27*k/2),
    );


    let face;
    face = new THREE.Face3(0, 1, 2);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(2, 3, 0);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 4, 5);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 2, 1);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(4, 6, 7);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(7, 5, 4);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 0, 3);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 7, 6);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 2, 5);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 7, 3);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 4, 1);
    face.materialIndex = 5;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 0, 6);
    face.materialIndex = 5;
    geometry.faces.push(face);
    
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();

    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    let texture = loader.load('https://i.imgur.com/9dP72Qr.png');
    let texture1 = loader.load('https://i.imgur.com/aOHqblB.png');
    let texture2 = loader.load('https://i.imgur.com/8khnPtP.png');
    let texture3 = loader.load('https://i.imgur.com/aOHqblB.png');
    let texture4 = loader.load('https://i.imgur.com/zhr9X0w.png');
    let texture5 = loader.load('https://i.imgur.com/2wd7fMD.png');
    materialArray = [];
    materialArray.push(new THREE.MeshLambertMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture1
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }),
      new THREE.MeshPhongMaterial({
        map: texture3
      }),
      new THREE.MeshPhongMaterial({
        map: texture4
      }),
      new THREE.MeshPhongMaterial({
        map: texture5
      }));
    return new THREE.Mesh(geometry, materialArray);
  }
  function buildSmalldrumarm() {
    let geometry = new THREE.Geometry();
    geometry.vertices.push(
      new THREE.Vector3(-1.25*k/2, 0, 1.25*k/2),
      new THREE.Vector3(1.25*k/2, 0, 1.25*k/2),
      new THREE.Vector3(1.25*k/2, 1.93*k, 1.25*k/2),
      new THREE.Vector3(-1.25*k/2, 1.93*k, 1.25*k/2),
      new THREE.Vector3(1.25*k/2, 0, -1.25*k/2),
      new THREE.Vector3(1.25*k/2, 1.93*k, -1.25*k/2),
      new THREE.Vector3(-1.25*k/2, 0, -1.25*k/2),
      new THREE.Vector3(-1.25*k/2, 1.93*k, -1.25*k/2),
    );


    let face;
    face = new THREE.Face3(0, 1, 2);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(2, 3, 0);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 4, 5);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 2, 1);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(4, 6, 7);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(7, 5, 4);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 0, 3);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 7, 6);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 2, 5);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 7, 3);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 4, 1);
    face.materialIndex = 5;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 0, 6);
    face.materialIndex = 5;
    geometry.faces.push(face);
    
    
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();


    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    let texture = loader.load('https://i.imgur.com/aANTmBw.png');
    let texture2 = loader.load('https://i.imgur.com/APu9VDq.png');
    let texture3 = loader.load('https://i.imgur.com/zDr6SGt.png');
    materialArray = [];
    materialArray.push(new THREE.MeshLambertMaterial({
        map: texture
      }), 
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }),
      new THREE.MeshPhongMaterial({
        map: texture3
      }));
    return new THREE.Mesh(geometry, materialArray);
  }
  function buildSmalldrumarm2() {
    let geometry = new THREE.Geometry();
    geometry.vertices.push(
      new THREE.Vector3(-1.25*k/2, 0, 1.25*k/2),
      new THREE.Vector3(1.25*k/2, 0, 1.25*k/2),
      new THREE.Vector3(1.25*k/2, 1.93*k, 1.25*k/2),
      new THREE.Vector3(-1.25*k/2, 1.93*k, 1.25*k/2),
      new THREE.Vector3(1.25*k/2, 0, -1.25*k/2),
      new THREE.Vector3(1.25*k/2, 1.93*k, -1.25*k/2),
      new THREE.Vector3(-1.25*k/2, 0, -1.25*k/2),
      new THREE.Vector3(-1.25*k/2, 1.93*k, -1.25*k/2),
    );


    let face;
    face = new THREE.Face3(0, 1, 2);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(2, 3, 0);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 4, 5);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 2, 1);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(4, 6, 7);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(7, 5, 4);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 0, 3);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 7, 6);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 2, 5);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 7, 3);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 4, 1);
    face.materialIndex = 5;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 0, 6);
    face.materialIndex = 5;
    geometry.faces.push(face);
    
    
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();


    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    let texture = loader.load('https://i.imgur.com/eA5BB9i.png');
    let texture2 = loader.load('https://i.imgur.com/zDr6SGt.png');
    materialArray = [];
    materialArray.push(new THREE.MeshLambertMaterial({
        map: texture
      }), 
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }));
    return new THREE.Mesh(geometry, materialArray);
  }
  function buildSmalldrumleg() {
    let geometry = new THREE.Geometry();
    geometry.vertices.push(
      new THREE.Vector3(-1.27*k/2, 0, 1.27*k/2),
      new THREE.Vector3(1.27*k/2, 0, 1.27*k/2),
      new THREE.Vector3(1.27*k/2, 2.046*k, 1.27*k/2),
      new THREE.Vector3(-1.27*k/2, 2.046*k, 1.27*k/2),
      new THREE.Vector3(1.27*k/2, 0, -1.27*k/2),
      new THREE.Vector3(1.27*k/2, 2.046*k, -1.27*k/2),
      new THREE.Vector3(-1.27*k/2, 0, -1.27*k/2),
      new THREE.Vector3(-1.27*k/2, 2.046*k, -1.27*k/2),
    );


    let face;
    face = new THREE.Face3(0, 1, 2);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(2, 3, 0);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 4, 5);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 2, 1);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(4, 6, 7);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(7, 5, 4);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 0, 3);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 7, 6);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 2, 5);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 7, 3);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 4, 1);
    face.materialIndex = 5;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 0, 6);
    face.materialIndex = 5;
    geometry.faces.push(face);
    
    
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();


    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    let texture = loader.load('https://i.imgur.com/CZughnT.png');
    let texture2 = loader.load('https://i.imgur.com/UmnQd9g.png');
    let texture3 = loader.load('https://i.imgur.com/zDr6SGt.png');
    materialArray = [];
    materialArray.push(new THREE.MeshLambertMaterial({
        map: texture
      }), 
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }),
      new THREE.MeshPhongMaterial({
        map: texture3
      }));
    return new THREE.Mesh(geometry, materialArray);
  }
  function buildSmalldrumleg2() {
    let geometry = new THREE.Geometry();
    geometry.vertices.push(
      new THREE.Vector3(-1.27*k/2, 0, 1.27*k/2),
      new THREE.Vector3(1.27*k/2, 0, 1.27*k/2),
      new THREE.Vector3(1.27*k/2, 2.046*k, 1.27*k/2),
      new THREE.Vector3(-1.27*k/2, 2.046*k, 1.27*k/2),
      new THREE.Vector3(1.27*k/2, 0, -1.27*k/2),
      new THREE.Vector3(1.27*k/2, 2.046*k, -1.27*k/2),
      new THREE.Vector3(-1.27*k/2, 0, -1.27*k/2),
      new THREE.Vector3(-1.27*k/2, 2.046*k, -1.27*k/2),
    );


    let face;
    face = new THREE.Face3(0, 1, 2);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(2, 3, 0);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 4, 5);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 2, 1);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(4, 6, 7);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(7, 5, 4);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 0, 3);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 7, 6);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 2, 5);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 7, 3);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 4, 1);
    face.materialIndex = 5;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 0, 6);
    face.materialIndex = 5;
    geometry.faces.push(face);
    
    
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();


    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    let texture = loader.load('https://i.imgur.com/DuEEa4x.png');
    let texture2 = loader.load('https://i.imgur.com/zDr6SGt.png');
    materialArray = [];
    materialArray.push(new THREE.MeshLambertMaterial({
        map: texture
      }), 
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }));
    return new THREE.Mesh(geometry, materialArray);
  }

function addMarkerB () {
	let planematerial = new THREE.MeshLambertMaterial({color:0xffffff, side:THREE.DoubleSide});
	planematerial.opacity = 0.6; 
	let planegeometry = new THREE.PlaneGeometry(1, 1)
	let planeMesh = new THREE.Mesh( planegeometry, planematerial);
	planeMesh.receiveShadow = true;
	planeMesh.depthWrite = false;
	planeMesh.rotation.x = -Math.PI/2
	/// add gridhelper
  let geometry = new THREE.CircleBufferGeometry( 0.01, 32 );
	let material = new THREE.MeshBasicMaterial( { color: 'red',side:THREE.DoubleSide});
	let circle = new THREE.Mesh( geometry, material );
	circle.rotation.x=-Math.PI/2;
	circle.position.y=0.01;
	var gridXZ = new THREE.GridHelper(1,10);
	//markerRootKanji.add (gridXZ);
	return [planeMesh,circle];
}
function addMarkerA(){
	let planematerial = new THREE.MeshLambertMaterial({color:0xffffff, side:THREE.DoubleSide});
	planematerial.opacity = 0.6; 
	let planegeometry = new THREE.PlaneGeometry(1, 1)
	let planeMesh = new THREE.Mesh( planegeometry, planematerial);
	planeMesh.receiveShadow = true;
	planeMesh.depthWrite = false;
	planeMesh.rotation.x = -Math.PI/2
  let geometry = new THREE.CircleBufferGeometry( 0.01, 32 );
	let material = new THREE.MeshBasicMaterial( { color: 'red',side:THREE.DoubleSide});
	let circle = new THREE.Mesh( geometry, material );
	circle.rotation.x=-Math.PI/2;
	circle.position.y=0.01;
	return [planeMesh,circle];
}	
function addMarkerC(){
	let planematerial = new THREE.MeshLambertMaterial({color:0xffffff, side:THREE.DoubleSide});
	planematerial.opacity = 0.6; 
	let planegeometry = new THREE.PlaneGeometry(1, 1)
	let planeMesh = new THREE.Mesh( planegeometry, planematerial);
	planeMesh.receiveShadow = true;
	planeMesh.depthWrite = false;
	planeMesh.rotation.x = -Math.PI/2
    let geometry = new THREE.CircleBufferGeometry( 0.01, 32 );
	let material = new THREE.MeshBasicMaterial( { color: 'red',side:THREE.DoubleSide});
	let circle = new THREE.Mesh( geometry, material );
	circle.rotation.x=-Math.PI/2;
	circle.position.y=0.01;
	return [planeMesh,circle];
}	
function addMarkerD(){
	let planematerial = new THREE.MeshLambertMaterial({color:0xffffff, side:THREE.DoubleSide});
	planematerial.opacity = 0.6; 
	let planegeometry = new THREE.PlaneGeometry(1, 1)
	let planeMesh = new THREE.Mesh( planegeometry, planematerial);
	planeMesh.receiveShadow = true;
	planeMesh.depthWrite = false;
	planeMesh.rotation.x = -Math.PI/2
  let geometry = new THREE.CircleBufferGeometry( 0.01, 32 );
	let material = new THREE.MeshBasicMaterial( { color: 'red',side:THREE.DoubleSide});
	let circle = new THREE.Mesh( geometry, material );
	circle.rotation.x=-Math.PI/2;
	circle.position.y=0.01;
	return [planeMesh,circle];
}	
function addMarkerE(){
	let planematerial = new THREE.MeshLambertMaterial({color:0xffffff, side:THREE.DoubleSide});
	planematerial.opacity = 0.6; 
	let planegeometry = new THREE.PlaneGeometry(1, 1)
	let planeMesh = new THREE.Mesh( planegeometry, planematerial);
	planeMesh.receiveShadow = true;
	planeMesh.depthWrite = false;
	planeMesh.rotation.x = -Math.PI/2
    let geometry = new THREE.CircleBufferGeometry( 0.01, 32 );
	let material = new THREE.MeshBasicMaterial( { color: 'red',side:THREE.DoubleSide});
	let circle = new THREE.Mesh( geometry, material );
	circle.rotation.x=-Math.PI/2;
	circle.position.y=0.01;
	return [planeMesh,circle];
}	
function addMarkerF(){
	let planematerial = new THREE.MeshLambertMaterial({color:0xffffff, side:THREE.DoubleSide});
	planematerial.opacity = 0.6; 
	let planegeometry = new THREE.PlaneGeometry(1, 1)
	let planeMesh = new THREE.Mesh( planegeometry, planematerial);
	planeMesh.receiveShadow = true;
	planeMesh.depthWrite = false;
	planeMesh.rotation.x = -Math.PI/2
    let geometry = new THREE.CircleBufferGeometry( 0.01, 32 );
	let material = new THREE.MeshBasicMaterial( { color: 'red',side:THREE.DoubleSide});
	let circle = new THREE.Mesh( geometry, material );
	circle.rotation.x=-Math.PI/2;
	circle.position.y=0.01;
	return [planeMesh,circle];
}	
function update(start,end,g1,g2) {
   // o1, x1, z1
   let o1 = start.position.clone();
   let x1 = start.localToWorld (new THREE.Vector3(1,0,0)).sub(o1);
   let z1 = start.localToWorld (new THREE.Vector3(0,0,1)).sub(o1);
   
   // o2, x2, z2
   let o2 = end.position.clone();
   let x2 = end.localToWorld (new THREE.Vector3(1,0,0)).sub(o2);
   let z2 = end.localToWorld (new THREE.Vector3(0,0,1)).sub(o2);
   
  // man position (eye coord)
  manPosEye = start.localToWorld (manPos.clone());
  let manPos2 = manPosEye.sub (o2);;
	g2.children[2].position.x = manPos2.dot (x2);   
	g2.children[2].position.z = manPos2.dot (z2);
  g2.children[2].rotation.copy(g1.children[2].rotation);   
}


function Drumkeyframe(t) {
  let T = 960/87;
  var s = ((t - ts) % T) / T;

  for (var i = 1; i < Drumkeys.length; i++) {
    if (Drumkeys[i][0] > s) break;
  }
  // take i-1
  var ii = i - 1;
  var a = (s - Drumkeys[ii][0]) / (Drumkeys[ii + 1][0] - Drumkeys[ii][0]);
  intKey1 = [Drumkeys[ii][1].Dtheta1 * (1 - a) + Drumkeys[ii + 1][1].Dtheta1 * a,
            Drumkeys[ii][1].Dtheta2 * (1 - a) + Drumkeys[ii + 1][1].Dtheta2 * a,
            Drumkeys[ii][1].Dtheta3 * (1 - a) + Drumkeys[ii + 1][1].Dtheta3 * a,
            Drumkeys[ii][1].Dtheta4 * (1 - a) + Drumkeys[ii + 1][1].Dtheta4 * a,
            Drumkeys[ii][1].Dtheta5 * (1 - a) + Drumkeys[ii + 1][1].Dtheta5 * a,
            Drumkeys[ii][1].Dtheta6 * (1 - a) + Drumkeys[ii + 1][1].Dtheta6 * a,
            Drumkeys[ii][1].Dtheta7 * (1 - a) + Drumkeys[ii + 1][1].Dtheta7 * a,
            Drumkeys[ii][1].Dtheta8 * (1 - a) + Drumkeys[ii + 1][1].Dtheta8 * a,
            Drumkeys[ii][1].Dtheta9 * (1 - a) + Drumkeys[ii + 1][1].Dtheta9 * a,
            Drumkeys[ii][1].Dtheta10 * (1 - a) + Drumkeys[ii + 1][1].Dtheta10 * a,
            Drumkeys[ii][1].Dtheta11 * (1 - a) + Drumkeys[ii + 1][1].Dtheta11 * a,
            Drumkeys[ii][1].Dtheta12 * (1 - a) + Drumkeys[ii + 1][1].Dtheta12 * a
  ];

}
function Cymbalkeyframe(t) {
  let T = 240/87;
  var s = ((t - tss) % T) / T;

  for (var i = 1; i < Cymbalkeys.length; i++) {
    if (Cymbalkeys[i][0] > s) break;
  }
  // take i-1
  var ii = i - 1;
  var a = (s - Cymbalkeys[ii][0]) / (Cymbalkeys[ii + 1][0] - Cymbalkeys[ii][0]);
  intKey2 = [Cymbalkeys[ii][1].Ctheta1 * (1 - a) + Cymbalkeys[ii + 1][1].Ctheta1 * a,
            Cymbalkeys[ii][1].Ctheta2 * (1 - a) + Cymbalkeys[ii + 1][1].Ctheta2 * a,
            Cymbalkeys[ii][1].Ctheta3 * (1 - a) + Cymbalkeys[ii + 1][1].Ctheta3 * a,
            Cymbalkeys[ii][1].Ctheta4 * (1 - a) + Cymbalkeys[ii + 1][1].Ctheta4 * a,
            Cymbalkeys[ii][1].Ctheta5 * (1 - a) + Cymbalkeys[ii + 1][1].Ctheta5 * a,
            Cymbalkeys[ii][1].Ctheta6 * (1 - a) + Cymbalkeys[ii + 1][1].Ctheta6 * a,
            Cymbalkeys[ii][1].Ctheta7 * (1 - a) + Cymbalkeys[ii + 1][1].Ctheta7 * a,
            Cymbalkeys[ii][1].Ctheta8 * (1 - a) + Cymbalkeys[ii + 1][1].Ctheta8 * a,
            Cymbalkeys[ii][1].Ctheta9 * (1 - a) + Cymbalkeys[ii + 1][1].Ctheta9 * a,
            Cymbalkeys[ii][1].Ctheta10 * (1 - a) + Cymbalkeys[ii + 1][1].Ctheta10 * a,
            Cymbalkeys[ii][1].Ctheta11 * (1 - a) + Cymbalkeys[ii + 1][1].Ctheta11 * a,
            Cymbalkeys[ii][1].Ctheta12 * (1 - a) + Cymbalkeys[ii + 1][1].Ctheta12 * a
  ];
}
function Smalldrumkeyframe(t) {
  let T = 240/87;
  var s = ((t - ts) % T) / T;

  for (var i = 1; i < Smalldrumkeys.length; i++) {
    if (Smalldrumkeys[i][0] > s) break;
  }
  // take i-1
  var ii = i - 1;
  var a = (s - Smalldrumkeys[ii][0]) / (Smalldrumkeys[ii + 1][0] - Smalldrumkeys[ii][0]);
  intKey3 = [Smalldrumkeys[ii][1].Stheta1 * (1 - a) + Smalldrumkeys[ii + 1][1].Stheta1 * a,
            Smalldrumkeys[ii][1].Stheta2 * (1 - a) + Smalldrumkeys[ii + 1][1].Stheta2 * a,
            Smalldrumkeys[ii][1].Stheta3 * (1 - a) + Smalldrumkeys[ii + 1][1].Stheta3 * a,
            Smalldrumkeys[ii][1].Stheta4 * (1 - a) + Smalldrumkeys[ii + 1][1].Stheta4 * a,
            Smalldrumkeys[ii][1].Stheta5 * (1 - a) + Smalldrumkeys[ii + 1][1].Stheta5 * a,
            Smalldrumkeys[ii][1].Stheta6 * (1 - a) + Smalldrumkeys[ii + 1][1].Stheta6 * a,
            Smalldrumkeys[ii][1].Stheta7 * (1 - a) + Smalldrumkeys[ii + 1][1].Stheta7 * a,
            Smalldrumkeys[ii][1].Stheta8 * (1 - a) + Smalldrumkeys[ii + 1][1].Stheta8 * a,
            Smalldrumkeys[ii][1].Stheta9 * (1 - a) + Smalldrumkeys[ii + 1][1].Stheta9 * a,
            Smalldrumkeys[ii][1].Stheta10 * (1 - a) + Smalldrumkeys[ii + 1][1].Stheta10 * a,
            Smalldrumkeys[ii][1].Stheta11 * (1 - a) + Smalldrumkeys[ii + 1][1].Stheta11 * a,
            Smalldrumkeys[ii][1].Stheta12 * (1 - a) + Smalldrumkeys[ii + 1][1].Stheta12 * a,
            Smalldrumkeys[ii][1].Stheta13 * (1 - a) + Smalldrumkeys[ii + 1][1].Stheta13 * a,
            Smalldrumkeys[ii][1].Stheta14 * (1 - a) + Smalldrumkeys[ii + 1][1].Stheta14 * a
  ];

}


function buildtire() {

		var loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    var colormap = loader.load ('http://jyunming-chen.github.io/tutsplus/images/tire-side.png');
    var colormap2 = loader.load ('http://jyunming-chen.github.io/tutsplus/images/tire-wheel.jpg');
    
    var tire = new THREE.Object3D();
    var geometry = new THREE.CircleGeometry(0.1, 30);
    var material = new THREE.MeshBasicMaterial({
        map: colormap,
       // transparent: true,  // for cut-out texture
        alphaTest: 0.5,
        side: THREE.DoubleSide
    });
    carmesh1 = new THREE.Mesh(geometry, material);
colormap2.wrapS = colormap2.wrapT = THREE.RepeatWrapping; 
	colormap2.repeat.set( 8, 1 );
    carmesh2 = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.1, 30, 1, true), // only side
    new THREE.MeshBasicMaterial({
        map: colormap2,
        side: THREE.DoubleSide
    }));
    carmesh2.rotation.x = Math.PI / 2;
    carmesh1.position.set(0, 0, 0.05);
    carmesh0 = carmesh1.clone();
    carmesh0.position.set(0, 0, -0.05);
    carmesh0.rotation.y = Math.PI;
    tire.add (carmesh1);
    tire.add(carmesh0);
    tire.add(carmesh2);
    carmesh0.castShadow = true;
    carmesh0.receiveShadow = true;
    carmesh2.castShadow = true;
    carmesh2.receiveShadow = true;
    return tire;
}
function buildcar(){
  var c= new THREE.Group();
    tire1=buildtire();
    tire1.position.set(0,0.1,0.15);
    tire2=buildtire();
    tire2.position.set(0,0.1,-0.15);
    var material = new THREE.MeshBasicMaterial( { color:'black',side:THREE.DoubleSide } );
  	box = new THREE.Mesh (new THREE.BoxGeometry(0.2, 0.15, 0.02), material); 
    box.rotation.set(Math.PI/2,0,Math.PI/2);
    box.position.set(0,0.1,0);
    c.add(tire1,tire2,box);
  return c;
}
function buildDrum(){
  drumgroup = new THREE.Group();
  var loader = new THREE.TextureLoader();
  loader.crossOrigin = '';
  var colormap = loader.load ('https://i.imgur.com/MTtMccq.jpg');
  var points = [];
  for ( var i = 0; i < 10; i ++ ) {
    points.push( new THREE.Vector2( Math.sin( i * 0.2 ) * 0.02 + 0.18, ( i - 5 ) * 0.02 ) );
  }
  var geometry = new THREE.LatheGeometry( points );
  var material = new THREE.MeshLambertMaterial( { map: colormap} );
  var lathe1 = new THREE.Mesh( geometry, material );
  lathe1.rotation.z=Math.PI/2;
  lathe1.position.set(0.48,0.45,0);
  //scene.add( lathe1 );
  for ( var i = 0; i < 10; i ++ ) {
    points.push( new THREE.Vector2( Math.sin( i * 0.2 ) * 0.02 + 18, ( i - 5 ) * 0.02 ) );
  }

  var lathe2 = new THREE.Mesh( geometry, material );
  lathe2.rotation.z=-Math.PI/2;
  lathe2.position.set(0.33,0.45,0);
  //scene.add( lathe2 );

  var geometry = new THREE.CylinderBufferGeometry(0.18, 0.18, 0.01, 64 );
  var material = new THREE.MeshLambertMaterial( {color: 0xeba434} );
  cylinder2 = new THREE.Mesh( geometry, material );
  cylinder2.position.set(0.23,0.45,0);
  cylinder2.rotation.z=-Math.PI/2;
  cylinder3 = new THREE.Mesh( geometry, material );
  cylinder3.position.set(0.58,0.45,0);
  cylinder3.rotation.z=-Math.PI/2;
  var loader = new THREE.TextureLoader();
  loader.crossOrigin = '';
  var colormap = loader.load ('https://i.imgur.com/rMKI0rA.jpg');
  var geometry = new THREE.CylinderBufferGeometry(0.01, 0.01, 0.5, 32 );
  var material = new THREE.MeshLambertMaterial( {map: colormap} );
  cylinder4 = new THREE.Mesh( geometry, material );
  cylinder4.position.set(0.51,0.18,0);
  cylinder4.rotation.x=-Math.PI/4;
  cylinder5 = new THREE.Mesh( geometry, material );
  cylinder5.position.set(0.51,0.18,0);
  cylinder5.rotation.x=Math.PI/4;
  cylinder6 = new THREE.Mesh( geometry, material );
  cylinder6.position.set(0.3,0.18,0);
  cylinder6.rotation.x=-Math.PI/4;
  cylinder7 = new THREE.Mesh( geometry, material );
  cylinder7.position.set(0.3,0.18,0);
  cylinder7.rotation.x=Math.PI/4;
  drumgroup.add(lathe1,lathe2,cylinder2,cylinder3,cylinder4,cylinder5,cylinder6,cylinder7);
  lathe1.castShadow = true;
  lathe1.receiveShadow = true;
  lathe2.castShadow = true;
  lathe2.receiveShadow = true;
  cylinder2.castShadow = true;
  cylinder2.receiveShadow = true;
  cylinder3.castShadow = true;
  cylinder3.receiveShadow = true;
  cylinder4.castShadow = true;
  cylinder4.receiveShadow = true;
  cylinder5.castShadow = true;
  cylinder5.receiveShadow = true;
  cylinder6.castShadow = true;
  cylinder6.receiveShadow = true;
  cylinder7.castShadow = true;
  cylinder7.receiveShadow = true;
  return drumgroup;
}
function buildSmallDrum(){
  smalldrumgroup = new THREE.Group();
  var geometry = new THREE.CylinderBufferGeometry(0.1, 0.1, 0.131, 0.32 );
  var material = new THREE.MeshLambertMaterial( {color: 'white'} );
  cylinder1 = new THREE.Mesh( geometry, material );
  cylinder1.position.set(0,-0.01,-2.8*k);
  var geometry = new THREE.CylinderBufferGeometry(0.101, 0.101, 0.13, 0.32 );
  var material = new THREE.MeshLambertMaterial( {color: 'blue'} );
  cylinder2 = new THREE.Mesh( geometry, material );
  cylinder2.position.set(0,-0.01,-2.8*k);
  let loader = new THREE.TextureLoader();
  loader.crossOrigin = '';
  let texture = loader.load('https://i.imgur.com/DvME6OT.jpg');
	var geometry = new THREE.TorusBufferGeometry( 0.101, 0.005, 0.32, 100 );
	var material = new THREE.MeshLambertMaterial( { map: texture } );
	cylinder3 = new THREE.Mesh( geometry, material );
  cylinder3.rotation.x=Math.PI/2;
  cylinder3.position.set(0,0.06,-2.8*k);
	cylinder4 = new THREE.Mesh( geometry, material );
  cylinder4.rotation.x=Math.PI/2;
  cylinder4.position.set(0,-0.08,-2.8*k);
	var geometry = new THREE.BoxBufferGeometry( 0.14, 0.01, 0.01 );
	var material = new THREE.MeshLambertMaterial( {map: texture } );
  BoxBuffer1= new THREE.Mesh( geometry, material );
  BoxBuffer1.rotation.z=Math.PI/2;
  BoxBuffer1.position.set(0.1,-0.01,-2.8*k);
  BoxBuffer2= new THREE.Mesh( geometry, material );
  BoxBuffer2.rotation.z=Math.PI/2;
  BoxBuffer2.position.set(0.075,-0.01,-4.1*k);
  BoxBuffer3= new THREE.Mesh( geometry, material );
  BoxBuffer3.rotation.z=Math.PI/2;
  BoxBuffer3.position.set(0,-0.01,-4.8*k);
  BoxBuffer4= new THREE.Mesh( geometry, material );
  BoxBuffer4.rotation.z=Math.PI/2;
  BoxBuffer4.position.set(-0.075,-0.01,-4.1*k);
  BoxBuffer5= new THREE.Mesh( geometry, material );
  BoxBuffer5.rotation.z=Math.PI/2;
  BoxBuffer5.position.set(-0.1,-0.01,-2.8*k);
  BoxBuffer6= new THREE.Mesh( geometry, material );
  BoxBuffer6.rotation.z=Math.PI/2;
  BoxBuffer6.position.set(-0.075,-0.01,-1.5*k);
  BoxBuffer7= new THREE.Mesh( geometry, material );
  BoxBuffer7.rotation.z=Math.PI/2;
  BoxBuffer7.position.set(0,-0.01,-0.8*k);
  BoxBuffer8= new THREE.Mesh( geometry, material );
  BoxBuffer8.rotation.z=Math.PI/2;
  BoxBuffer8.position.set(0.075,-0.01,-0.015*k);
  var material = new THREE.MeshLambertMaterial( { color: 'white',side:THREE.DoubleSide } );
  line1 = new THREE.Mesh (new THREE.BoxGeometry(0.25, 0.01,0.01), material); 
  line1.position.set(-1.6*k,0.12,-1.2*k);
  line1.rotation.set(0,-Math.PI/2.6,Math.PI/4);
  line2 = new THREE.Mesh (new THREE.BoxGeometry(0.25, 0.01, 0.01), material); 
  line2.position.set(1.6*k,0.12,-1.2*k);
  line2.rotation.set(0,Math.PI/2.6,-Math.PI/4);
  var material = new THREE.MeshLambertMaterial( { color: 'white',side:THREE.DoubleSide } );
  line3 = new THREE.Mesh (new THREE.BoxGeometry(0.14, 0.01, 0.01), material); 
  line3.position.set(0,0.17,0.01);
  line3.rotation.y=Math.PI;
  cylinder1.castShadow = true;
  cylinder1.receiveShadow = true;
  cylinder2.castShadow = true;
  cylinder2.receiveShadow = true;
  cylinder3.castShadow = true;
  cylinder3.receiveShadow = true;
  cylinder4.castShadow = true;
  cylinder4.receiveShadow = true;
  BoxBuffer1.castShadow = true;
  BoxBuffer1.receiveShadow = true;
  BoxBuffer2.castShadow = true;
  BoxBuffer2.receiveShadow = true;
  BoxBuffer3.castShadow = true;
  BoxBuffer3.receiveShadow = true;
  BoxBuffer4.castShadow = true;
  BoxBuffer4.receiveShadow = true;
  BoxBuffer5.castShadow = true;
  BoxBuffer5.receiveShadow = true;
  BoxBuffer6.castShadow = true;
  BoxBuffer6.receiveShadow = true;
  BoxBuffer7.castShadow = true;
  BoxBuffer7.receiveShadow = true;
  BoxBuffer8.castShadow = true;
  BoxBuffer8.receiveShadow = true;
  line1.castShadow = true;
  line1.receiveShadow = true;
  line2.castShadow = true;
  line2.receiveShadow = true;
  line3.castShadow = true;
  line3.receiveShadow = true;
  smalldrumgroup.add (cylinder1,cylinder2,cylinder3,cylinder4,line1,line2,line3,BoxBuffer1,BoxBuffer2,BoxBuffer3,BoxBuffer4,BoxBuffer5,BoxBuffer6,BoxBuffer7,BoxBuffer8);
  return smalldrumgroup;
}

function searchFace () {
    var maxDot = -1;
    var which;
    var normals = {B: new THREE.Vector3(1,0,0), E: new THREE.Vector3(0,1,0),A: new THREE.Vector3(0,0,1),
    D: new THREE.Vector3(-1,0,0), F: new THREE.Vector3(0,-1,0), C: new THREE.Vector3(0,0,-1)};
    var centers = {B: new THREE.Vector3(L/2,0,0), E: new THREE.Vector3(0,L/2,0), A: new THREE.Vector3(0,0,L/2),
    D: new THREE.Vector3(-L/2,0,0), F: new THREE.Vector3(0,-L/2,0), C: new THREE.Vector3(0,0,-L/2)};
    
    let dd, point;
    point = camera.position.clone().sub (centers['B']).normalize();
    if ((dd = normals['B'].dot (point)) > maxDot) {
      maxDot = dd;
      which = 'B';
    }
    point = camera.position.clone().sub (centers['E']).normalize();
    if ((dd = normals['E'].dot (point)) > maxDot) {
      maxDot = dd;
      which = 'E';
    }
    point = camera.position.clone().sub (centers['A']).normalize();
    if ((dd = normals['A'].dot (point)) > maxDot) {
      maxDot = dd;
      which = 'A';
    }
    point = camera.position.clone().sub (centers['D']).normalize();
    if ((dd = normals['D'].dot (point)) > maxDot) {
      maxDot = dd;
      which = 'D';
    }
    point = camera.position.clone().sub (centers['F']).normalize();
    if ((dd = normals['F'].dot (point)) > maxDot) {
      maxDot = dd;
      which = 'F';
    }
    point = camera.position.clone().sub (centers['C']).normalize();
    if ((dd = normals['C'].dot (point)) > maxDot) {
      maxDot = dd;
      which = 'C';
    }
    return which;
  }

  function setAllFacesTransparent () {
    if(GroupA.children[0].position.x<L/2&&GroupA.children[0].position.x>-L/2&&
    GroupA.children[0].position.z<L/2&&GroupA.children[0].position.z>-L/2&&GroupA.children[0].position.y==0){
      faces['B'].visible = false;
      faces['E'].visible = false;
      faces['A'].visible = true;
      faces['D'].visible = false;
      faces['F'].visible = false;
      faces['C'].visible = false;
    }
    if(GroupA.children[0].position.y<0&&GroupA.children[0].position.y>-L&&
    GroupA.children[0].position.z<L/2&&GroupA.children[0].position.z>-L/2&&GroupA.children[0].position.x==L/2){
      faces['B'].visible = true;
      faces['E'].visible = false;
      faces['A'].visible = false;
      faces['D'].visible = false;
      faces['F'].visible = false;
      faces['C'].visible = false;
    }
    if(GroupA.children[0].position.x<L/2&&GroupA.children[0].position.x>-L/2&&
    GroupA.children[0].position.z<L/2&&GroupA.children[0].position.z>-L/2&&GroupA.children[0].position.y==-L){
      faces['B'].visible = false;
      faces['E'].visible = false;
      faces['A'].visible = false;
      faces['D'].visible = false;
      faces['F'].visible = false;
      faces['C'].visible = true;
    }
    if(GroupA.children[0].position.y<0&&GroupA.children[0].position.y>-L&&
    GroupA.children[0].position.z<L/2&&GroupA.children[0].position.z>-L/2&&GroupA.children[0].position.x==-L/2){
      faces['B'].visible = false;
      faces['E'].visible = false;
      faces['A'].visible = false;
      faces['D'].visible = true;
      faces['F'].visible = false;
      faces['C'].visible = false;
    }
    if(GroupA.children[0].position.y<0&&GroupA.children[0].position.y>-L&&
    GroupA.children[0].position.x<L/2&&GroupA.children[0].position.x>-L/2&&GroupA.children[0].position.z==-L/2){
      faces['B'].visible = false;
      faces['E'].visible = true;
      faces['A'].visible = false;
      faces['D'].visible = false;
      faces['F'].visible = false;
      faces['C'].visible = false;
    }
    if(GroupA.children[0].position.y<0&&GroupA.children[0].position.y>-L&&
    GroupA.children[0].position.x<L/2&&GroupA.children[0].position.x>-L/2&&GroupA.children[0].position.z==L/2){
      faces['B'].visible = false;
      faces['E'].visible = false;
      faces['A'].visible = false;
      faces['D'].visible = false;
      faces['F'].visible = true;
      faces['C'].visible = false;
    }
  }
function animate() {
	requestAnimationFrame (animate);
	if( arToolkitSource.ready === false )	return
	arToolkitContext.update( arToolkitSource.domElement )

	renderer.clear();
	renderer.render( scene, camera );
  stats.update();
	scene.visible = camera.visible
  var dt = new THREE.Clock();
  
  setAllFacesTransparent();
  let which = searchFace();
  var timeFromStart = clock.getElapsedTime();
  var eT = (timeFromStart - lastChangeTime ).toFixed(0);
  var output = `${keyNow} : ${eT}`;
  
  $('#output').text (output);
    
  if (keyNow != undefined && keyNow != which) {
    keyNow=which;
    lastChangeTime =  timeFromStart;
  }

  if(GroupA.children[0].position.distanceTo(GroupA.children[2].position)<=0.2){
    men[0][11].visible = true;
    men[0][12].visible = true;
    Drumkeyframe(clock.getElapsedTime()); 
    men[0][3].rotation.y = intKey1[0];
    men[0][4].rotation.y = intKey1[1];
    men[0][5].rotation.y = intKey1[2];
    men[0][6].rotation.y = intKey1[3];
    men[0][7].rotation.y = intKey1[4];
    men[0][8].rotation.y = intKey1[5];
    men[0][9].rotation.y = intKey1[6];
    men[0][10].rotation.y = intKey1[7];
    men[0][1].rotation.y = intKey1[8];
    men[0][2].rotation.y = intKey1[9];
    men[0][4].rotation.z = intKey1[10];
    men[0][6].rotation.z = intKey1[11];
  }
  else{
    men[0][11].visible = false;
    men[0][12].visible = false;
    GroupA.children[3].visible = false;
    men[0][3].rotation.y = 0;
    men[0][4].rotation.y = 0;
    men[0][5].rotation.y = 0;
    men[0][6].rotation.y = 0;
    men[0][7].rotation.y = 0;
    men[0][8].rotation.y = 0;
    men[0][9].rotation.y = 0;
    men[0][10].rotation.y = 0;
    men[0][1].rotation.y = 0;
    men[0][2].rotation.y = 0;
    men[0][4].rotation.z = 0;
    men[0][6].rotation.z = 0;
  }
  if(GroupB.children[0].position.distanceTo(GroupB.children[2].position)<=0.2){
    men[1][11].visible = true;
    men[1][12].visible = true;
    Cymbalkeyframe(clock.getElapsedTime()); 
    men[1][3].rotation.y = intKey2[0];
    men[1][4].rotation.y = intKey2[1];
    men[1][5].rotation.y = intKey2[2];
    men[1][6].rotation.y = intKey2[3];
    men[1][7].rotation.y = intKey2[4];
    men[1][8].rotation.y = intKey2[5];
    men[1][9].rotation.y = intKey2[6];
    men[1][10].rotation.y = intKey2[7];
    men[1][1].rotation.x = intKey2[8];
    men[1][2].rotation.y = intKey2[9];
    men[1][4].rotation.z = intKey2[10];
    men[1][6].rotation.z = intKey2[11];
  }
  else{
    men[1][11].visible = false;
    men[1][12].visible = false;
    men[1][3].rotation.y = 0;
    men[1][4].rotation.y = 0;
    men[1][5].rotation.y = 0;
    men[1][6].rotation.y = 0;
    men[1][7].rotation.y = 0;
    men[1][8].rotation.y = 0;
    men[1][9].rotation.y = 0;
    men[1][10].rotation.y = 0;
    men[1][1].rotation.x = 0;
    men[1][2].rotation.y = 0;
    men[1][4].rotation.z = 0;
    men[1][6].rotation.z = 0;
  }
  if(GroupC.children[0].position.distanceTo(GroupC.children[2].position)<=0.2){
    men[2][11].visible = true;
    men[2][12].visible = true;
    men[2][13].visible = true;
    Smalldrumkeyframe(clock.getElapsedTime()); 
    men[2][3].rotation.y = intKey3[0];
    men[2][4].rotation.y = intKey3[1];
    men[2][5].rotation.y = intKey3[2];
    men[2][6].rotation.y = intKey3[3];
    men[2][7].rotation.y = intKey3[4];
    men[2][8].rotation.y = intKey3[5];
    men[2][9].rotation.y = intKey3[6];
    men[2][10].rotation.y = intKey3[7];
    men[2][1].rotation.y = intKey3[8];
    men[2][2].rotation.y = intKey3[9];
    men[2][3].rotation.z = intKey3[10];
    men[2][5].rotation.z = intKey3[11];
    men[2][4].rotation.x = intKey3[12];
    men[2][6].rotation.x = intKey3[13];
  }
  else{
    men[2][11].visible = false;
    men[2][12].visible = false;
    men[2][13].visible = false;
    men[2][3].rotation.y = 0;
    men[2][4].rotation.y = 0;
    men[2][5].rotation.y = 0;
    men[2][6].rotation.y = 0;
    men[2][7].rotation.y = 0;
    men[2][8].rotation.y = 0;
    men[2][9].rotation.y = 0;
    men[2][10].rotation.y = 0;
    men[2][1].rotation.y = 0;
    men[2][2].rotation.y = 0;
    men[2][3].rotation.z = -Math.PI/2;
    men[2][5].rotation.z = -Math.PI/2;
    men[2][4].rotation.x = 0;
    men[2][6].rotation.x = 0;
  }


  if (eT==3&&which == 'B'&&manIn=='A') {  // Px2Pz
      //currentPlane = 'A';
      //nextPlane = 'B';
        pos1[0] = new THREE.Vector3(0, 0, 0);  // starting pos
        euler1[0] = new THREE.Euler (0, 0, 0, 'ZYX');// starting orientation
        euler2[0] = new THREE.Euler (0, 0, -Math.PI/2,'ZYX');

        pos1[1] = new THREE.Vector3(0,-L/2, L/2);
        euler1[1] = new THREE.Euler (Math.PI/2, 0, Math.PI/2, 'ZYX');
        euler2[1] = new THREE.Euler (0, Math.PI/2, 0,'ZYX');

        pos1[2] = new THREE.Vector3(0,-L, 0);
        euler1[2] = new THREE.Euler (Math.PI, 0, 0, 'ZYX');
        euler2[2] = new THREE.Euler (0, Math.PI, -Math.PI/2,'ZYX');

        pos1[3] = new THREE.Vector3(0,-L/2, L/2);
        euler1[3] = new THREE.Euler (Math.PI/2, 0, -Math.PI/2, 'ZYX');
        euler2[3] = new THREE.Euler (0, Math.PI/2, Math.PI,'ZYX');

        pos1[4] = new THREE.Vector3(0,-L/2, L/2);
        euler1[4] = new THREE.Euler (Math.PI/2, 0, 0, 'ZYX');
        euler2[4] = new THREE.Euler (0, Math.PI/2, -Math.PI/2,'ZYX');

        pos1[5] = new THREE.Vector3(0,-L/2, -L/2);
        euler1[5] = new THREE.Euler (-Math.PI/2, 0, 0, 'ZYX');
        euler2[5] = new THREE.Euler (0, -Math.PI/2, -Math.PI/2,'ZYX');

        GroupA.children[0].position.copy (pos1[0]);
        GroupA.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,0, 'ZYX'));
        GroupB.children[0].position.copy (pos1[1]);
        GroupB.children[0].rotation.copy (new THREE.Euler (-Math.PI/2, Math.PI, 0, 'ZYX'));
        GroupC.children[0].position.copy (pos1[2]);
        GroupC.children[0].rotation.copy (new THREE.Euler (0, -Math.PI/2, Math.PI, 'ZYX'));
        GroupD.children[0].position.copy (pos1[3]);
        GroupD.children[0].rotation.copy (new THREE.Euler (Math.PI/2, 0, 0, 'ZYX'));
        GroupE.children[0].position.copy (pos1[4]);
        GroupE.children[0].rotation.copy (new THREE.Euler (Math.PI/2,0, Math.PI/2, 'ZYX'));
        GroupF.children[0].position.copy (pos1[5]);
        GroupF.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0, -Math.PI/2, 'ZYX'));
        turning = 0; //not yet turning	
        manIn ='B';
        moving = 'AtoB';
      }
    if (eT==3&&which == 'E'&&manIn=='A') {  // Px2Pz
      //currentPlane = 'A';
      //nextPlane = 'E';
        pos1[0] = new THREE.Vector3(0,0, 0);
        euler1[0] = new THREE.Euler (0, Math.PI/2, 0, 'ZYX');
        euler2[0] = new THREE.Euler (-Math.PI/2,0, -Math.PI/2, 'ZYX');

        pos1[1] = new THREE.Vector3(0,- L/2, L/2);
        euler1[1] = new THREE.Euler (-Math.PI/2, Math.PI, 0, 'ZYX');
        euler2[1] = new THREE.Euler (0, Math.PI/2, Math.PI/2, 'ZYX');

        pos1[2] = new THREE.Vector3(0,-L, 0);
        euler1[2] = new THREE.Euler (0, -Math.PI/2, Math.PI, 'ZYX');
        euler2[2] = new THREE.Euler (Math.PI/2, 0, Math.PI/2, 'ZYX');

        pos1[3] = new THREE.Vector3(0,-L/2, L/2);
        euler1[3] = new THREE.Euler (Math.PI/2, 0, 0, 'ZYX');
        euler2[3] = new THREE.Euler (0, Math.PI/2, -Math.PI/2, 'ZYX');

        pos1[4] = new THREE.Vector3(0,-L/2, L/2);
        euler1[4] = new THREE.Euler (Math.PI/2,0, Math.PI/2, 'ZYX');
        euler2[4] = new THREE.Euler (0,Math.PI/2, 0, 'ZYX');

        pos1[5] = new THREE.Vector3(0,-L/2, -L/2);
        euler1[5] = new THREE.Euler (-Math.PI/2,0, -Math.PI/2, 'ZYX');
        euler2[5] = new THREE.Euler (0,-Math.PI/2, Math.PI, 'ZYX');

        GroupA.children[0].position.copy (pos1[0]);
        GroupA.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,0, 'ZYX'));
        GroupB.children[0].position.copy (pos1[1]);
        GroupB.children[0].rotation.copy (new THREE.Euler (-Math.PI/2, Math.PI, 0, 'ZYX'));
        GroupC.children[0].position.copy (pos1[2]);
        GroupC.children[0].rotation.copy (new THREE.Euler (0, -Math.PI/2, Math.PI, 'ZYX'));
        GroupD.children[0].position.copy (pos1[3]);
        GroupD.children[0].rotation.copy (new THREE.Euler (Math.PI/2, 0, 0, 'ZYX'));
        GroupE.children[0].position.copy (pos1[4]);
        GroupE.children[0].rotation.copy (new THREE.Euler (Math.PI/2,0, Math.PI/2, 'ZYX'));
        GroupF.children[0].position.copy (pos1[5]);
        GroupF.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0, -Math.PI/2, 'ZYX'));
        turning = 0; //not yet turning		
        manIn = 'E';
        moving = 'AtoE';
      }
    if (eT==3&&which == 'D'&&manIn=='A') {  // Px2Pz
      //currentPlane = 'A';
      //nextPlane = 'D';
        pos1[0] = new THREE.Vector3(0, 0, 0);
        euler1[0] = new THREE.Euler (0,Math.PI,0, 'ZYX');
        euler2[0] = new THREE.Euler (0,Math.PI,Math.PI/2,'ZYX');

        pos1[1] = new THREE.Vector3(0,-L/2, L/2);
        euler1[1] = new THREE.Euler (Math.PI/2, 0, -Math.PI/2, 'ZYX');
        euler2[1] = new THREE.Euler (0, Math.PI/2, Math.PI,'ZYX');

        pos1[2] = new THREE.Vector3(0,-L, 0);
        euler1[2] = new THREE.Euler (0, 0, Math.PI, 'ZYX');
        euler2[2] = new THREE.Euler (0, 0, Math.PI/2,'ZYX');

        pos1[3] = new THREE.Vector3(0,-L/2, L/2);
        euler1[3] = new THREE.Euler (Math.PI/2, 0, Math.PI/2, 'ZYX');
        euler2[3] = new THREE.Euler (0, Math.PI/2, 0,'ZYX');

        pos1[4] = new THREE.Vector3(0,-L/2, L/2);
        euler1[4] = new THREE.Euler (-Math.PI/2, Math.PI, 0, 'ZYX');
        euler2[4] = new THREE.Euler (0, Math.PI/2, Math.PI/2,'ZYX');

        pos1[5] = new THREE.Vector3(0,-L/2, -L/2);
        euler1[5] = new THREE.Euler (Math.PI/2, Math.PI, 0, 'ZYX');
        euler2[5] = new THREE.Euler (0, -Math.PI/2, Math.PI/2,'ZYX');

        GroupA.children[0].position.copy (pos1[0]);
        GroupA.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,0, 'ZYX'));
        GroupB.children[0].position.copy (pos1[1]);
        GroupB.children[0].rotation.copy (new THREE.Euler (-Math.PI/2, Math.PI, 0, 'ZYX'));
        GroupC.children[0].position.copy (pos1[2]);
        GroupC.children[0].rotation.copy (new THREE.Euler (0, -Math.PI/2, Math.PI, 'ZYX'));
        GroupD.children[0].position.copy (pos1[3]);
        GroupD.children[0].rotation.copy (new THREE.Euler (Math.PI/2, 0, 0, 'ZYX'));
        GroupE.children[0].position.copy (pos1[4]);
        GroupE.children[0].rotation.copy (new THREE.Euler (Math.PI/2,0, Math.PI/2, 'ZYX'));
        GroupF.children[0].position.copy (pos1[5]);
        GroupF.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0, -Math.PI/2, 'ZYX'));
        turning = 0; //not yet turning		
        manIn = 'D';
        moving = 'AtoD';
      }
    if (eT==3&&which == 'F'&&manIn=='A') {  // Px2Pz
      //currentPlane = 'A';
      //nextPlane = 'F';
        pos1[0] = new THREE.Vector3(0, 0, 0);
        euler1[0] = new THREE.Euler (0, -Math.PI/2, 0, 'ZYX');
        euler2[0] = new THREE.Euler (Math.PI/2, 0, -Math.PI/2,'ZYX');

        pos1[1] = new THREE.Vector3(0,-L/2, L/2);
        euler1[1] = new THREE.Euler (Math.PI/2, 0, 0, 'ZYX');
        euler2[1] = new THREE.Euler (0, Math.PI/2, -Math.PI/2,'ZYX');

        pos1[2] = new THREE.Vector3(0,-L, 0);
        euler1[2] = new THREE.Euler (0, Math.PI/2, -Math.PI, 'ZYX');
        euler2[2] = new THREE.Euler (-Math.PI/2, 0, Math.PI/2,'ZYX');

        pos1[3] = new THREE.Vector3(0,-L/2, L/2);
        euler1[3] = new THREE.Euler (-Math.PI/2, Math.PI, 0, 'ZYX');
        euler2[3] = new THREE.Euler (0, Math.PI/2, Math.PI/2,'ZYX');

        pos1[4] = new THREE.Vector3(0,-L/2, L/2);
        euler1[4] = new THREE.Euler (Math.PI/2, 0, -Math.PI/2, 'ZYX');
        euler2[4] = new THREE.Euler (0, Math.PI/2, Math.PI,'ZYX');

        pos1[5] = new THREE.Vector3(0,-L/2, -L/2);
        euler1[5] = new THREE.Euler (-Math.PI/2, 0, Math.PI/2, 'ZYX');
        euler2[5] = new THREE.Euler (0, -Math.PI/2, 0,'ZYX');

        GroupA.children[0].position.copy (pos1[0]);
        GroupA.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,0, 'ZYX'));
        GroupB.children[0].position.copy (pos1[1]);
        GroupB.children[0].rotation.copy (new THREE.Euler (-Math.PI/2, Math.PI, 0, 'ZYX'));
        GroupC.children[0].position.copy (pos1[2]);
        GroupC.children[0].rotation.copy (new THREE.Euler (0, -Math.PI/2, Math.PI, 'ZYX'));
        GroupD.children[0].position.copy (pos1[3]);
        GroupD.children[0].rotation.copy (new THREE.Euler (Math.PI/2, 0, 0, 'ZYX'));
        GroupE.children[0].position.copy (pos1[4]);
        GroupE.children[0].rotation.copy (new THREE.Euler (Math.PI/2,0, Math.PI/2, 'ZYX'));
        GroupF.children[0].position.copy (pos1[5]);
        GroupF.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0, -Math.PI/2, 'ZYX'));
        turning = 0; //not yet turning	
        manIn = 'F';
        moving = 'AtoF';
      }
    /////////////
    if (eT==3&&which == 'C'&&manIn=='B') {  // Px2Pz
      //currentPlane = 'B';
      //nextPlane = 'C';
        pos1[0] = new THREE.Vector3(L/2, -L/2, 0);
        euler1[0] = new THREE.Euler (0, 0, -Math.PI/2, 'ZYX'); 
        euler2[0] = new THREE.Euler (0, 0, -Math.PI, 'ZYX');

        pos1[1] = new THREE.Vector3(0,0, 0);
        euler1[1] = new THREE.Euler (0, Math.PI/2, 0, 'ZYX');
        euler2[1] = new THREE.Euler (-Math.PI/2, 0, -Math.PI/2,'ZYX');

        pos1[2] = new THREE.Vector3(L/2,-L/2, 0);
        euler1[2] = new THREE.Euler (0, Math.PI, -Math.PI/2, 'ZYX');
        euler2[2] = new THREE.Euler (0, Math.PI, 0,'ZYX');

        pos1[3] = new THREE.Vector3(0,-L, 0);
        euler1[3] = new THREE.Euler (0, Math.PI/2, Math.PI, 'ZYX');
        euler2[3] = new THREE.Euler (-Math.PI/2, 0, Math.PI/2,'ZYX');

        pos1[4] = new THREE.Vector3(L/2,-L/2, 0);
        euler1[4] = new THREE.Euler (0, Math.PI/2, -Math.PI/2, 'ZYX');
        euler2[4] = new THREE.Euler (Math.PI/2, Math.PI, 0,'ZYX');

        pos1[5] = new THREE.Vector3(L/2,-L/2, 0);
        euler1[5] = new THREE.Euler (0, -Math.PI/2, -Math.PI/2, 'ZYX');
        euler2[5] = new THREE.Euler (-Math.PI/2, Math.PI, 0,'ZYX');

        GroupA.children[0].position.copy (pos1[0]);
        GroupA.children[0].rotation.copy (new THREE.Euler (0, Math.PI/2, -Math.PI/2, 'ZYX'));
        GroupB.children[0].position.copy (pos1[1]);
        GroupB.children[0].rotation.copy (new THREE.Euler (0, Math.PI,0, 'ZYX'));
        GroupC.children[0].position.copy (pos1[2]);
        GroupC.children[0].rotation.copy (new THREE.Euler (0, -Math.PI/2, -Math.PI/2, 'ZYX'));
        GroupD.children[0].position.copy (pos1[3]);
        GroupD.children[0].rotation.copy (new THREE.Euler (0, Math.PI, Math.PI, 'ZYX'));
        GroupE.children[0].position.copy (pos1[4]);
        GroupE.children[0].rotation.copy (new THREE.Euler (0, Math.PI, -Math.PI/2, 'ZYX'));
        GroupF.children[0].position.copy (pos1[5]);
        GroupF.children[0].rotation.copy (new THREE.Euler (0,0, -Math.PI/2, 'ZYX'));

        turning = 0; //not yet turning	
        manIn = 'C';
        moving = 'BtoC';
      }
    if (eT==3&&which == 'E'&&manIn=='B') {  // Px2Pz
      //currentPlane = 'B';
      //nextPlane = 'E';
        pos1[0] = new THREE.Vector3(L/2, -L/2, 0);
        euler1[0] = new THREE.Euler (0, Math.PI/2, -Math.PI/2, 'ZYX');
        euler2[0] = new THREE.Euler (-Math.PI/2, 0, Math.PI, 'ZYX');

        pos1[1] = new THREE.Vector3(0, 0, 0);
        euler1[1] = new THREE.Euler (0, Math.PI,0, 'ZYX');
        euler2[1] = new THREE.Euler (0,Math.PI, Math.PI/2, 'ZYX');

        pos1[2] = new THREE.Vector3(L/2, -L/2, 0);
        euler1[2] = new THREE.Euler (0, -Math.PI/2, -Math.PI/2, 'ZYX');
        euler2[2] = new THREE.Euler (Math.PI/2, 0, Math.PI, 'ZYX');

        pos1[3] = new THREE.Vector3(0,-L, 0);
        euler1[3] = new THREE.Euler (0, Math.PI, Math.PI, 'ZYX');
        euler2[3] = new THREE.Euler (0, Math.PI, -Math.PI/2, 'ZYX');

        pos1[4] = new THREE.Vector3(L/2,-L/2, 0);
        euler1[4] = new THREE.Euler (0, Math.PI, -Math.PI/2, 'ZYX');
        euler2[4] = new THREE.Euler (0, Math.PI, 0, 'ZYX');

        pos1[5] = new THREE.Vector3(L/2,-L/2, 0);
        euler1[5] = new THREE.Euler (0,0, -Math.PI/2, 'ZYX');
        euler2[5] = new THREE.Euler (0,0, -Math.PI, 'ZYX');

        GroupA.children[0].position.copy (pos1[0]);
        GroupA.children[0].rotation.copy (new THREE.Euler (0, Math.PI/2, -Math.PI/2, 'ZYX'));
        GroupB.children[0].position.copy (pos1[1]);
        GroupB.children[0].rotation.copy (new THREE.Euler (0, Math.PI,0, 'ZYX'));
        GroupC.children[0].position.copy (pos1[2]);
        GroupC.children[0].rotation.copy (new THREE.Euler (0, -Math.PI/2, -Math.PI/2, 'ZYX'));
        GroupD.children[0].position.copy (pos1[3]);
        GroupD.children[0].rotation.copy (new THREE.Euler (0, Math.PI, Math.PI, 'ZYX'));
        GroupE.children[0].position.copy (pos1[4]);
        GroupE.children[0].rotation.copy (new THREE.Euler (0, Math.PI, -Math.PI/2, 'ZYX'));
        GroupF.children[0].position.copy (pos1[5]);
        GroupF.children[0].rotation.copy (new THREE.Euler (0,0, -Math.PI/2, 'ZYX'));
        turning = 0; //not yet turning		
        moving = 'BtoE';
        manIn = 'E';
      }
    if (eT==3&&which == 'A'&&manIn=='B') {  // Px2Pz
      //currentPlane = 'B';
      //nextPlane = 'A';
        pos1[0] = new THREE.Vector3(L/2, -L/2, 0);
        euler1[0] = new THREE.Euler (0,Math.PI, -Math.PI/2, 'ZYX');
        euler2[0] = new THREE.Euler (0,Math.PI, 0, 'ZYX');

        pos1[1] = new THREE.Vector3(0, 0, 0);
        euler1[1] = new THREE.Euler (0,-Math.PI/2, 0, 'ZYX');
        euler2[1] = new THREE.Euler (Math.PI/2,0, -Math.PI/2, 'ZYX');

        pos1[2] = new THREE.Vector3(L/2, -L/2, 0);
        euler1[2] = new THREE.Euler (0, 0, -Math.PI/2, 'ZYX');
        euler2[2] = new THREE.Euler (0, 0, -Math.PI, 'ZYX');

        pos1[3] = new THREE.Vector3(0,-L, 0);
        euler1[3] = new THREE.Euler (0, -Math.PI/2, Math.PI, 'ZYX');
        euler2[3] = new THREE.Euler (Math.PI/2, 0, Math.PI/2, 'ZYX');

        pos1[4] = new THREE.Vector3(L/2,-L/2, 0);
        euler1[4] = new THREE.Euler (0, -Math.PI/2, -Math.PI/2, 'ZYX');
        euler2[4] = new THREE.Euler (Math.PI/2, 0, -Math.PI, 'ZYX');

        pos1[5] = new THREE.Vector3(L/2,-L/2, 0);
        euler1[5] = new THREE.Euler (0, Math.PI/2, -Math.PI/2, 'ZYX');
        euler2[5] = new THREE.Euler (-Math.PI/2, 0, Math.PI, 'ZYX');

        GroupA.children[0].position.copy (pos1[0]);
        GroupA.children[0].rotation.copy (new THREE.Euler (0, Math.PI/2, -Math.PI/2, 'ZYX'));
        GroupB.children[0].position.copy (pos1[1]);
        GroupB.children[0].rotation.copy (new THREE.Euler (0, Math.PI,0, 'ZYX'));
        GroupC.children[0].position.copy (pos1[2]);
        GroupC.children[0].rotation.copy (new THREE.Euler (0, -Math.PI/2, -Math.PI/2, 'ZYX'));
        GroupD.children[0].position.copy (pos1[3]);
        GroupD.children[0].rotation.copy (new THREE.Euler (0, Math.PI, Math.PI, 'ZYX'));
        GroupE.children[0].position.copy (pos1[4]);
        GroupE.children[0].rotation.copy (new THREE.Euler (0, Math.PI, -Math.PI/2, 'ZYX'));
        GroupF.children[0].position.copy (pos1[5]);
        GroupF.children[0].rotation.copy (new THREE.Euler (0,0, -Math.PI/2, 'ZYX'));
        turning = 0; //not yet turning	
        manIn ='A';
        moving = 'BtoA';
      }
    if (eT==3&&which == 'F'&&manIn=='B') {  // Px2Pz
      //currentPlane = 'B';
      //nextPlane = 'F';
        pos1[0] = new THREE.Vector3(L/2, -L/2, 0);
        euler1[0] = new THREE.Euler (0, -Math.PI/2, -Math.PI/2, 'ZYX');
        euler2[0] = new THREE.Euler (Math.PI/2, 0, Math.PI, 'ZYX');

        pos1[1] = new THREE.Vector3(0, 0, 0);
        euler1[1] = new THREE.Euler (0, 0,0, 'ZYX');
        euler2[1] = new THREE.Euler (0, 0,-Math.PI/2, 'ZYX');

        pos1[2] = new THREE.Vector3(L/2, -L/2, 0);
        euler1[2] = new THREE.Euler (0, Math.PI/2,-Math.PI/2, 'ZYX');
        euler2[2] = new THREE.Euler (-Math.PI/2, 0,Math.PI, 'ZYX');

        pos1[3] = new THREE.Vector3(0,-L, 0);
        euler1[3] = new THREE.Euler (0, 0, Math.PI, 'ZYX');
        euler2[3] = new THREE.Euler (0, 0,Math.PI/2, 'ZYX');

        pos1[4] = new THREE.Vector3(L/2,-L/2, 0);
        euler1[4] = new THREE.Euler (0,0 ,-Math.PI/2, 'ZYX');
        euler2[4] = new THREE.Euler (0,0 ,-Math.PI, 'ZYX');

        pos1[5] = new THREE.Vector3(L/2,-L/2, 0);
        euler1[5] = new THREE.Euler (0,Math.PI,-Math.PI/2, 'ZYX');
        euler2[5] = new THREE.Euler (0,Math.PI,0, 'ZYX');

        GroupA.children[0].position.copy (pos1[0]);
        GroupA.children[0].rotation.copy (new THREE.Euler (0, Math.PI/2, -Math.PI/2, 'ZYX'));
        GroupB.children[0].position.copy (pos1[1]);
        GroupB.children[0].rotation.copy (new THREE.Euler (0, Math.PI,0, 'ZYX'));
        GroupC.children[0].position.copy (pos1[2]);
        GroupC.children[0].rotation.copy (new THREE.Euler (0, -Math.PI/2, -Math.PI/2, 'ZYX'));
        GroupD.children[0].position.copy (pos1[3]);
        GroupD.children[0].rotation.copy (new THREE.Euler (0, Math.PI, Math.PI, 'ZYX'));
        GroupE.children[0].position.copy (pos1[4]);
        GroupE.children[0].rotation.copy (new THREE.Euler (0, Math.PI, -Math.PI/2, 'ZYX'));
        GroupF.children[0].position.copy (pos1[5]);
        GroupF.children[0].rotation.copy (new THREE.Euler (0,0, -Math.PI/2, 'ZYX'));
        turning = 0; //not yet turning		
        manIn = 'F';
        moving = 'BtoF';
      }
    //////////////
    if (eT==3&&which == 'D'&&manIn=='C') {  // Px2Pz
      //currentPlane = 'C';
      //nextPlane = 'D';
        pos1[0] = new THREE.Vector3(0,-L, 0);
        euler1[0] = new THREE.Euler (0,0,Math.PI, 'ZYX');
        euler2[0] = new THREE.Euler (0,0,Math.PI/2, 'ZYX');

        pos1[1] = new THREE.Vector3(0,-L/2, -L/2);
        euler1[1] = new THREE.Euler (-Math.PI/2,0,-Math.PI/2, 'ZYX');
        euler2[1] = new THREE.Euler (0,-Math.PI/2,Math.PI, 'ZYX');

        pos1[2] = new THREE.Vector3(0, 0, 0);
        euler1[2] = new THREE.Euler (0,Math.PI,0, 'ZYX');
        euler2[2] = new THREE.Euler (0,Math.PI,Math.PI/2, 'ZYX');

        pos1[3] = new THREE.Vector3(0,-L/2, -L/2);
        euler1[3] = new THREE.Euler (-Math.PI/2,0,Math.PI/2, 'ZYX');
        euler2[3] = new THREE.Euler (0,-Math.PI/2,0, 'ZYX');

        pos1[4] = new THREE.Vector3(0,-L/2, -L/2);
        euler1[4] = new THREE.Euler (-Math.PI/2,0,Math.PI, 'ZYX');
        euler2[4] = new THREE.Euler (0,-Math.PI/2,Math.PI/2, 'ZYX');

        pos1[5] = new THREE.Vector3(0,-L/2, L/2);
        euler1[5] = new THREE.Euler (Math.PI/2,0,Math.PI, 'ZYX');
        euler2[5] = new THREE.Euler (0,Math.PI/2,Math.PI/2, 'ZYX');

        GroupA.children[0].position.copy (pos1[0]);
        GroupA.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,Math.PI, 'ZYX'));
        GroupB.children[0].position.copy (pos1[1]);
        GroupB.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0,Math.PI, 'ZYX'));
        GroupC.children[0].position.copy (pos1[2]);
        GroupC.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,0, 'ZYX'));
        GroupD.children[0].position.copy (pos1[3]);
        GroupD.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0,0, 'ZYX'));
        GroupE.children[0].position.copy (pos1[4]);
        GroupE.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0,Math.PI/2, 'ZYX'));
        GroupF.children[0].position.copy (pos1[5]);
        GroupF.children[0].rotation.copy (new THREE.Euler (Math.PI/2,0,-Math.PI/2, 'ZYX'));
        turning = 0; //not yet turning		
        manIn ='D'
        moving = 'CtoD';
      }
    if (eT==3&&which == 'E'&&manIn=='C') {  // Px2Pz
      //currentPlane = 'C';
      //nextPlane = 'E';
        pos1[0] = new THREE.Vector3(0,-L, 0);
        euler1[0] = new THREE.Euler (0,Math.PI/2,Math.PI, 'ZYX');
        euler2[0] = new THREE.Euler (-Math.PI/2,0,Math.PI/2, 'ZYX');

        pos1[1] = new THREE.Vector3(0,-L/2, -L/2);
        euler1[1] = new THREE.Euler (-Math.PI/2,0,Math.PI, 'ZYX');
        euler2[1] = new THREE.Euler (0,-Math.PI/2,Math.PI/2, 'ZYX');

        pos1[2] = new THREE.Vector3(0, 0, 0);
        euler1[2] = new THREE.Euler (0,-Math.PI/2,0, 'ZYX');
        euler2[2] = new THREE.Euler (Math.PI/2,0,-Math.PI/2, 'ZYX');

        pos1[3] = new THREE.Vector3(0,-L/2, -L/2);
        euler1[3] = new THREE.Euler (-Math.PI/2,0,0, 'ZYX');
        euler2[3] = new THREE.Euler (0,-Math.PI/2,-Math.PI/2, 'ZYX');

        pos1[4] = new THREE.Vector3(0,-L/2, -L/2);
        euler1[4] = new THREE.Euler (-Math.PI/2,0,Math.PI/2, 'ZYX');
        euler2[4] = new THREE.Euler (0,-Math.PI/2,0, 'ZYX');

        pos1[5] = new THREE.Vector3(0,-L/2, L/2);
        euler1[5] = new THREE.Euler (Math.PI/2,0,-Math.PI/2, 'ZYX');
        euler2[5] = new THREE.Euler (0,Math.PI/2,Math.PI, 'ZYX');

        GroupA.children[0].position.copy (pos1[0]);
        GroupA.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,Math.PI, 'ZYX'));
        GroupB.children[0].position.copy (pos1[1]);
        GroupB.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0,Math.PI, 'ZYX'));
        GroupC.children[0].position.copy (pos1[2]);
        GroupC.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,0, 'ZYX'));
        GroupD.children[0].position.copy (pos1[3]);
        GroupD.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0,0, 'ZYX'));
        GroupE.children[0].position.copy (pos1[4]);
        GroupE.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0,Math.PI/2, 'ZYX'));
        GroupF.children[0].position.copy (pos1[5]);
        GroupF.children[0].rotation.copy (new THREE.Euler (Math.PI/2,0,-Math.PI/2, 'ZYX'));
        turning = 0; //not yet turning		
        manIn = 'E';
        moving = 'CtoE';
      }
    if (eT==3&&which == 'B'&&manIn=='C') {  // Px2Pz
      //currentPlane = 'C';
      //nextPlane = 'B';
      pos1[0] = new THREE.Vector3(0,-L, 0);
      euler1[0] = new THREE.Euler (0,Math.PI,Math.PI, 'ZYX');
      euler2[0] = new THREE.Euler (0,Math.PI,-Math.PI/2, 'ZYX');

      pos1[1] = new THREE.Vector3(0,-L/2, -L/2);
      euler1[1] = new THREE.Euler (-Math.PI/2,0,Math.PI/2, 'ZYX');
      euler2[1] = new THREE.Euler (0,-Math.PI/2,0, 'ZYX');
      
      pos1[2] = new THREE.Vector3(0, 0, 0);
      euler1[2] = new THREE.Euler (0,0,0, 'ZYX');
      euler2[2] = new THREE.Euler (0,0,-Math.PI/2, 'ZYX');
      
      pos1[3] = new THREE.Vector3(0,-L/2, -L/2);
      euler1[3] = new THREE.Euler (-Math.PI/2,0,-Math.PI/2, 'ZYX');
      euler2[3] = new THREE.Euler (0,-Math.PI/2,Math.PI, 'ZYX');
      
      pos1[4] = new THREE.Vector3(0,-L/2, -L/2);
      euler1[4] = new THREE.Euler (-Math.PI/2,0,0, 'ZYX');
      euler2[4] = new THREE.Euler (0,-Math.PI/2,-Math.PI/2, 'ZYX');
      
      pos1[5] = new THREE.Vector3(0,-L/2, L/2);
      euler1[5] = new THREE.Euler (Math.PI/2,0,0, 'ZYX');
      euler2[5] = new THREE.Euler (0,Math.PI/2,-Math.PI/2, 'ZYX');

      GroupA.children[0].position.copy (pos1[0]);
        GroupA.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,Math.PI, 'ZYX'));
        GroupB.children[0].position.copy (pos1[1]);
        GroupB.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0,Math.PI, 'ZYX'));
        GroupC.children[0].position.copy (pos1[2]);
        GroupC.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,0, 'ZYX'));
        GroupD.children[0].position.copy (pos1[3]);
        GroupD.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0,0, 'ZYX'));
        GroupE.children[0].position.copy (pos1[4]);
        GroupE.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0,Math.PI/2, 'ZYX'));
        GroupF.children[0].position.copy (pos1[5]);
        GroupF.children[0].rotation.copy (new THREE.Euler (Math.PI/2,0,-Math.PI/2, 'ZYX'));
      turning = 0; //not yet turning		
      manIn = 'B';
      moving = 'CtoB'; 
    }
    if (eT==3&&which == 'F'&&manIn=='C'){  // Px2Pz
      //currentPlane = 'C';
      //nextPlane = 'F';
      pos1[0] = new THREE.Vector3(0,-L, 0);
      euler1[0] = new THREE.Euler (0,-Math.PI/2,Math.PI, 'ZYX');
      euler2[0] = new THREE.Euler (Math.PI/2,0,Math.PI/2, 'ZYX');

      pos1[1] = new THREE.Vector3(0,-L/2, -L/2);
      euler1[1] = new THREE.Euler (-Math.PI/2,0,0, 'ZYX');
      euler2[1] = new THREE.Euler (0,-Math.PI/2,-Math.PI/2, 'ZYX');
      
      pos1[2] = new THREE.Vector3(0, 0, 0);
      euler1[2] = new THREE.Euler (0,Math.PI/2,0, 'ZYX');
      euler2[2] = new THREE.Euler (-Math.PI/2,0,-Math.PI/2, 'ZYX');
      
      pos1[3] = new THREE.Vector3(0,-L/2, -L/2);
      euler1[3] = new THREE.Euler (-Math.PI/2,0,Math.PI, 'ZYX');
      euler2[3] = new THREE.Euler (0,-Math.PI/2,Math.PI/2, 'ZYX');
      
      pos1[4] = new THREE.Vector3(0,-L/2, -L/2);
      euler1[4] = new THREE.Euler (-Math.PI/2,0,-Math.PI/2, 'ZYX');
      euler2[4] = new THREE.Euler (0,-Math.PI/2,Math.PI, 'ZYX');
      
      pos1[5] = new THREE.Vector3(0,-L/2, L/2);
      euler1[5] = new THREE.Euler (Math.PI/2,0,Math.PI/2, 'ZYX');
      euler2[5] = new THREE.Euler (0,Math.PI/2,0, 'ZYX');

      GroupA.children[0].position.copy (pos1[0]);
        GroupA.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,Math.PI, 'ZYX'));
        GroupB.children[0].position.copy (pos1[1]);
        GroupB.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0,Math.PI, 'ZYX'));
        GroupC.children[0].position.copy (pos1[2]);
        GroupC.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,0, 'ZYX'));
        GroupD.children[0].position.copy (pos1[3]);
        GroupD.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0,0, 'ZYX'));
        GroupE.children[0].position.copy (pos1[4]);
        GroupE.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0,Math.PI/2, 'ZYX'));
        GroupF.children[0].position.copy (pos1[5]);
        GroupF.children[0].rotation.copy (new THREE.Euler (Math.PI/2,0,-Math.PI/2, 'ZYX'));
      turning = 0; //not yet turning		
      manIn = 'F';
      moving = 'CtoF'; 
    }
    //////////////
    if (eT==3&&which == 'A'&&manIn=='D') {
      //currentPlane = 'D';
      //nextPlane = 'A';
      pos1[0] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[0] = new THREE.Euler (0,0,Math.PI/2, 'ZYX');
      euler2[0] = new THREE.Euler (0,0,0, 'ZYX');

      pos1[1] = new THREE.Vector3(0,-L, 0);
      euler1[1] = new THREE.Euler (0,-Math.PI/2,Math.PI, 'ZYX');
      euler2[1] = new THREE.Euler (Math.PI/2,0,Math.PI/2, 'ZYX');
      
      pos1[2] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[2] = new THREE.Euler (0,Math.PI,Math.PI/2, 'ZYX');
      euler2[2] = new THREE.Euler (Math.PI,0,0, 'ZYX');
      
      pos1[3] = new THREE.Vector3(0,0,0);
      euler1[3] = new THREE.Euler (0,-Math.PI/2,0, 'ZYX');
      euler2[3] = new THREE.Euler (Math.PI/2,0,-Math.PI/2, 'ZYX');
      
      pos1[4] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[4] = new THREE.Euler (0,-Math.PI/2,Math.PI/2, 'ZYX');
      euler2[4] = new THREE.Euler (Math.PI/2,0,0, 'ZYX');
      
      pos1[5] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[5] = new THREE.Euler (0,Math.PI/2,Math.PI/2, 'ZYX');
      euler2[5] = new THREE.Euler (-Math.PI/2,0,0, 'ZYX');

      GroupA.children[0].position.copy (pos1[0]);
      GroupA.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,Math.PI/2, 'ZYX'));
      GroupB.children[0].position.copy (pos1[1]);
      GroupB.children[0].rotation.copy (new THREE.Euler (0,0,Math.PI, 'ZYX'));
      GroupC.children[0].position.copy (pos1[2]);
      GroupC.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,Math.PI/2, 'ZYX'));
      GroupD.children[0].position.copy (pos1[3]);
      GroupD.children[0].rotation.copy (new THREE.Euler (0,0,0, 'ZYX'));
      GroupE.children[0].position.copy (pos1[4]);
      GroupE.children[0].rotation.copy (new THREE.Euler (0,0,Math.PI/2, 'ZYX'));
      GroupF.children[0].position.copy (pos1[5]);
      GroupF.children[0].rotation.copy (new THREE.Euler (0,Math.PI,Math.PI/2, 'ZYX'));
      turning = 0; //not yet turning		
      manIn='A';
      moving = 'DtoA'; 
    }
    if (eT==3&&which == 'E'&&manIn=='D') {
      //currentPlane = 'D';
      //nextPlane = 'E';
      pos1[0] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[0] = new THREE.Euler (0,Math.PI/2,Math.PI/2, 'ZYX');
      euler2[0] = new THREE.Euler (-Math.PI/2,0,0, 'ZYX');

      pos1[1] = new THREE.Vector3(0,-L, 0);
      euler1[1] = new THREE.Euler (0,0,Math.PI, 'ZYX');
      euler2[1] = new THREE.Euler (0,0,Math.PI/2, 'ZYX');
      
      pos1[2] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[2] = new THREE.Euler (0,-Math.PI/2,Math.PI/2, 'ZYX');
      euler2[2] = new THREE.Euler (Math.PI/2,0,0, 'ZYX');
      
      pos1[3] = new THREE.Vector3(0,0,0);
      euler1[3] = new THREE.Euler (0,0,0, 'ZYX');
      euler2[3] = new THREE.Euler (0,0,-Math.PI/2, 'ZYX');
      
      pos1[4] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[4] = new THREE.Euler (0,0,Math.PI/2, 'ZYX');
      euler2[4] = new THREE.Euler (0,0,0, 'ZYX');
      
      pos1[5] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[5] = new THREE.Euler (0,Math.PI,Math.PI/2, 'ZYX');
      euler2[5] = new THREE.Euler (Math.PI,0,0, 'ZYX');

      GroupA.children[0].position.copy (pos1[0]);
      GroupA.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,Math.PI/2, 'ZYX'));
      GroupB.children[0].position.copy (pos1[1]);
      GroupB.children[0].rotation.copy (new THREE.Euler (0,0,Math.PI, 'ZYX'));
      GroupC.children[0].position.copy (pos1[2]);
      GroupC.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,Math.PI/2, 'ZYX'));
      GroupD.children[0].position.copy (pos1[3]);
      GroupD.children[0].rotation.copy (new THREE.Euler (0,0,0, 'ZYX'));
      GroupE.children[0].position.copy (pos1[4]);
      GroupE.children[0].rotation.copy (new THREE.Euler (0,0,Math.PI/2, 'ZYX'));
      GroupF.children[0].position.copy (pos1[5]);
      GroupF.children[0].rotation.copy (new THREE.Euler (0,Math.PI,Math.PI/2, 'ZYX'));
      turning = 0; //not yet turning		
      manIn='E';
      moving = 'DtoE'; 
    }
    if (eT==3&&which == 'C'&&manIn=='D') {
      //currentPlane = 'D';
      //nextPlane = 'C';
      pos1[0] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[0] = new THREE.Euler (0,Math.PI,Math.PI/2, 'ZYX');
      euler2[0] = new THREE.Euler (Math.PI,0,0, 'ZYX');

      pos1[1] = new THREE.Vector3(0,-L, 0);
      euler1[1] = new THREE.Euler (0,Math.PI/2,Math.PI, 'ZYX');
      euler2[1] = new THREE.Euler (-Math.PI/2,0,Math.PI/2, 'ZYX');
      
      pos1[2] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[2] = new THREE.Euler (0,0,Math.PI/2, 'ZYX');
      euler2[2] = new THREE.Euler (0,0,0, 'ZYX');
      
      pos1[3] = new THREE.Vector3(0,0,0);
      euler1[3] = new THREE.Euler (0,Math.PI/2,0, 'ZYX');
      euler2[3] = new THREE.Euler (-Math.PI/2,0,-Math.PI/2, 'ZYX');
      
      pos1[4] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[4] = new THREE.Euler (0,Math.PI/2,Math.PI/2, 'ZYX');
      euler2[4] = new THREE.Euler (-Math.PI/2,0,0, 'ZYX');
      
      pos1[5] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[5] = new THREE.Euler (0,-Math.PI/2,Math.PI/2, 'ZYX');
      euler2[5] = new THREE.Euler (Math.PI/2,0,0, 'ZYX');

      GroupA.children[0].position.copy (pos1[0]);
      GroupA.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,Math.PI/2, 'ZYX'));
      GroupB.children[0].position.copy (pos1[1]);
      GroupB.children[0].rotation.copy (new THREE.Euler (0,0,Math.PI, 'ZYX'));
      GroupC.children[0].position.copy (pos1[2]);
      GroupC.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,Math.PI/2, 'ZYX'));
      GroupD.children[0].position.copy (pos1[3]);
      GroupD.children[0].rotation.copy (new THREE.Euler (0,0,0, 'ZYX'));
      GroupE.children[0].position.copy (pos1[4]);
      GroupE.children[0].rotation.copy (new THREE.Euler (0,0,Math.PI/2, 'ZYX'));
      GroupF.children[0].position.copy (pos1[5]);
      GroupF.children[0].rotation.copy (new THREE.Euler (0,Math.PI,Math.PI/2, 'ZYX'));
      turning = 0; //not yet turning		
      manIn='C';
      moving = 'DtoC'; 
    }
    if (eT==3&&which == 'F'&&manIn=='D') {
      //currentPlane = 'D';
      //nextPlane = 'F';
      pos1[0] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[0] = new THREE.Euler (0,-Math.PI/2,Math.PI/2, 'ZYX');
      euler2[0] = new THREE.Euler (Math.PI/2,0,0, 'ZYX');

      pos1[1] = new THREE.Vector3(0,-L, 0);
      euler1[1] = new THREE.Euler (0,Math.PI,Math.PI, 'ZYX');
      euler2[1] = new THREE.Euler (Math.PI,0,Math.PI/2, 'ZYX');
      
      pos1[2] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[2] = new THREE.Euler (0,Math.PI/2,Math.PI/2, 'ZYX');
      euler2[2] = new THREE.Euler (-Math.PI/2,0,0, 'ZYX');
      
      pos1[3] = new THREE.Vector3(0,0,0);
      euler1[3] = new THREE.Euler (0,Math.PI,0, 'ZYX');
      euler2[3] = new THREE.Euler (0,Math.PI,Math.PI/2, 'ZYX');
      
      pos1[4] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[4] = new THREE.Euler (0,Math.PI,Math.PI/2, 'ZYX');
      euler2[4] = new THREE.Euler (Math.PI,0,0, 'ZYX');
      
      pos1[5] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[5] = new THREE.Euler (0,0,Math.PI/2, 'ZYX');
      euler2[5] = new THREE.Euler (0,0,0, 'ZYX');

      GroupA.children[0].position.copy (pos1[0]);
      GroupA.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,Math.PI/2, 'ZYX'));
      GroupB.children[0].position.copy (pos1[1]);
      GroupB.children[0].rotation.copy (new THREE.Euler (0,0,Math.PI, 'ZYX'));
      GroupC.children[0].position.copy (pos1[2]);
      GroupC.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,Math.PI/2, 'ZYX'));
      GroupD.children[0].position.copy (pos1[3]);
      GroupD.children[0].rotation.copy (new THREE.Euler (0,0,0, 'ZYX'));
      GroupE.children[0].position.copy (pos1[4]);
      GroupE.children[0].rotation.copy (new THREE.Euler (0,0,Math.PI/2, 'ZYX'));
      GroupF.children[0].position.copy (pos1[5]);
      GroupF.children[0].rotation.copy (new THREE.Euler (0,Math.PI,Math.PI/2, 'ZYX'));
      turning = 0; //not yet turning		
      manIn='F';
      moving = 'DtoF'; 
    }
    //////////////
    if (eT==3&&which == 'A'&&manIn=='E') {
      //currentPlane = 'E';
      //nextPlane = 'A';
      pos1[0] = new THREE.Vector3(0,-L/2, -L/2);
      euler1[0] = new THREE.Euler (-Math.PI/2,0,Math.PI/2, 'ZYX');
      euler2[0] = new THREE.Euler (0,-Math.PI/2,0, 'ZYX');

      pos1[1] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[1] = new THREE.Euler (0,-Math.PI/2,Math.PI/2, 'ZYX');
      euler2[1] = new THREE.Euler (Math.PI/2,0,0, 'ZYX');
      
      pos1[2] = new THREE.Vector3(0,-L/2, L/2);
      euler1[2] = new THREE.Euler (Math.PI/2,0,-Math.PI/2, 'ZYX');
      euler2[2] = new THREE.Euler (0,Math.PI/2,Math.PI, 'ZYX');
      
      pos1[3] = new THREE.Vector3(L/2,-L/2, 0);
      euler1[3] = new THREE.Euler (0,-Math.PI/2,-Math.PI/2, 'ZYX');
      euler2[3] = new THREE.Euler (-Math.PI/2,Math.PI,0, 'ZYX');
      
      pos1[4] = new THREE.Vector3(0,0, 0);
      euler1[4] = new THREE.Euler (0,-Math.PI/2,0, 'ZYX');
      euler2[4] = new THREE.Euler (Math.PI/2,0,-Math.PI/2, 'ZYX');
      
      pos1[5] = new THREE.Vector3(0,-L,0);
      euler1[5] = new THREE.Euler (0,Math.PI/2,Math.PI, 'ZYX');
      euler2[5] = new THREE.Euler (-Math.PI/2,0,Math.PI/2, 'ZYX');

      GroupA.children[0].position.copy (pos1[0]);
      GroupA.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0,-Math.PI/2, 'ZYX'));
      GroupB.children[0].position.copy (pos1[1]);
      GroupB.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,Math.PI/2, 'ZYX'));
      GroupC.children[0].position.copy (pos1[2]);
      GroupC.children[0].rotation.copy (new THREE.Euler (Math.PI/2,0,Math.PI/2, 'ZYX'));
      GroupD.children[0].position.copy (pos1[3]);
      GroupD.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,-Math.PI/2, 'ZYX'));
      GroupE.children[0].position.copy (pos1[4]);
      GroupE.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,0, 'ZYX'));
      GroupF.children[0].position.copy (pos1[5]);
      GroupF.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,Math.PI, 'ZYX'));
      turning = 0; //not yet turning		
      manIn = 'A';
      moving = 'EtoA'; 
    }
    if (eT==3&&which == 'B'&&manIn=='E') {
      //currentPlane = 'E';
      //nextPlane = 'B';
      pos1[0] = new THREE.Vector3(0,-L/2, -L/2);
      euler1[0] = new THREE.Euler (-Math.PI/2,0,0, 'ZYX');
      euler2[0] = new THREE.Euler (0,-Math.PI/2,-Math.PI/2, 'ZYX');

      pos1[1] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[1] = new THREE.Euler (0,0,Math.PI/2, 'ZYX');
      euler2[1] = new THREE.Euler (0,0,0, 'ZYX');
      
      pos1[2] = new THREE.Vector3(0,-L/2, L/2);
      euler1[2] = new THREE.Euler (Math.PI/2,0,0, 'ZYX');
      euler2[2] = new THREE.Euler (0,Math.PI/2,-Math.PI/2, 'ZYX');
      
      pos1[3] = new THREE.Vector3(L/2,-L/2, 0);
      euler1[3] = new THREE.Euler (0,0,-Math.PI/2, 'ZYX');
      euler2[3] = new THREE.Euler (0,0,Math.PI, 'ZYX');
      
      pos1[4] = new THREE.Vector3(0,0, 0);
      euler1[4] = new THREE.Euler (0,0,0, 'ZYX');
      euler2[4] = new THREE.Euler (0,0,-Math.PI/2, 'ZYX');
      
      pos1[5] = new THREE.Vector3(0,-L,0);
      euler1[5] = new THREE.Euler (0,Math.PI,Math.PI, 'ZYX');
      euler2[5] = new THREE.Euler (0,Math.PI,-Math.PI/2, 'ZYX');

      GroupA.children[0].position.copy (pos1[0]);
      GroupA.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0,-Math.PI/2, 'ZYX'));
      GroupB.children[0].position.copy (pos1[1]);
      GroupB.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,Math.PI/2, 'ZYX'));
      GroupC.children[0].position.copy (pos1[2]);
      GroupC.children[0].rotation.copy (new THREE.Euler (Math.PI/2,0,Math.PI/2, 'ZYX'));
      GroupD.children[0].position.copy (pos1[3]);
      GroupD.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,-Math.PI/2, 'ZYX'));
      GroupE.children[0].position.copy (pos1[4]);
      GroupE.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,0, 'ZYX'));
      GroupF.children[0].position.copy (pos1[5]);
      GroupF.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,Math.PI, 'ZYX'));
      turning = 0; //not yet turning		
      manIn = 'B';
      moving = 'EtoB'; 
    }
    if (eT==3&&which == 'C'&&manIn=='E') {
      //currentPlane = 'E';
      //nextPlane = 'C';
      pos1[0] = new THREE.Vector3(0,-L/2, -L/2);
      euler1[0] = new THREE.Euler (-Math.PI/2,0,-Math.PI/2, 'ZYX');
      euler2[0] = new THREE.Euler (Math.PI,-Math.PI/2,0, 'ZYX');

      pos1[1] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[1] = new THREE.Euler (0,Math.PI/2,Math.PI/2, 'ZYX');
      euler2[1] = new THREE.Euler (-Math.PI/2,0,0, 'ZYX');
      
      pos1[2] = new THREE.Vector3(0,-L/2, L/2);
      euler1[2] = new THREE.Euler (Math.PI/2,0,Math.PI/2, 'ZYX');
      euler2[2] = new THREE.Euler (0,Math.PI/2,0, 'ZYX');
      
      pos1[3] = new THREE.Vector3(L/2,-L/2, 0);
      euler1[3] = new THREE.Euler (0,Math.PI/2,-Math.PI/2, 'ZYX');
      euler2[3] = new THREE.Euler (Math.PI/2,Math.PI,0, 'ZYX');
      
      pos1[4] = new THREE.Vector3(0,0, 0);
      euler1[4] = new THREE.Euler (0,Math.PI/2,0, 'ZYX');
      euler2[4] = new THREE.Euler (-Math.PI/2,0,-Math.PI/2, 'ZYX');
      
      pos1[5] = new THREE.Vector3(0,-L,0);
      euler1[5] = new THREE.Euler (0,-Math.PI/2,Math.PI, 'ZYX');
      euler2[5] = new THREE.Euler (Math.PI/2,0,Math.PI/2, 'ZYX');

      GroupA.children[0].position.copy (pos1[0]);
      GroupA.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0,-Math.PI/2, 'ZYX'));
      GroupB.children[0].position.copy (pos1[1]);
      GroupB.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,Math.PI/2, 'ZYX'));
      GroupC.children[0].position.copy (pos1[2]);
      GroupC.children[0].rotation.copy (new THREE.Euler (Math.PI/2,0,Math.PI/2, 'ZYX'));
      GroupD.children[0].position.copy (pos1[3]);
      GroupD.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,-Math.PI/2, 'ZYX'));
      GroupE.children[0].position.copy (pos1[4]);
      GroupE.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,0, 'ZYX'));
      GroupF.children[0].position.copy (pos1[5]);
      GroupF.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,Math.PI, 'ZYX'));
      turning = 0; //not yet turning		
      manIn = 'C';
      moving = 'EtoC'; 
    }
    if (eT==3&&which == 'D'&&manIn=='E') {
      //currentPlane = 'E';
      //nextPlane = 'D';
      pos1[0] = new THREE.Vector3(0,-L/2, -L/2);
      euler1[0] = new THREE.Euler (-Math.PI/2,0,Math.PI, 'ZYX');
      euler2[0] = new THREE.Euler (0,-Math.PI/2,Math.PI/2, 'ZYX');

      pos1[1] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[1] = new THREE.Euler (0,Math.PI,Math.PI/2, 'ZYX');
      euler2[1] = new THREE.Euler (0,Math.PI,Math.PI, 'ZYX');
      
      pos1[2] = new THREE.Vector3(0,-L/2, L/2);
      euler1[2] = new THREE.Euler (Math.PI/2,0,Math.PI, 'ZYX');
      euler2[2] = new THREE.Euler (0,Math.PI/2,Math.PI/2, 'ZYX');
      
      pos1[3] = new THREE.Vector3(L/2,-L/2, 0);
      euler1[3] = new THREE.Euler (0,Math.PI,-Math.PI/2, 'ZYX');
      euler2[3] = new THREE.Euler (0,Math.PI,0, 'ZYX');
      
      pos1[4] = new THREE.Vector3(0,0, 0);
      euler1[4] = new THREE.Euler (0,Math.PI,0, 'ZYX');
      euler2[4] = new THREE.Euler (0,Math.PI,Math.PI/2, 'ZYX');
      
      pos1[5] = new THREE.Vector3(0,-L,0);
      euler1[5] = new THREE.Euler (0,0,Math.PI, 'ZYX');
      euler2[5] = new THREE.Euler (0,0,Math.PI/2, 'ZYX');

      GroupA.children[0].position.copy (pos1[0]);
      GroupA.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0,-Math.PI/2, 'ZYX'));
      GroupB.children[0].position.copy (pos1[1]);
      GroupB.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,Math.PI/2, 'ZYX'));
      GroupC.children[0].position.copy (pos1[2]);
      GroupC.children[0].rotation.copy (new THREE.Euler (Math.PI/2,0,Math.PI/2, 'ZYX'));
      GroupD.children[0].position.copy (pos1[3]);
      GroupD.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,-Math.PI/2, 'ZYX'));
      GroupE.children[0].position.copy (pos1[4]);
      GroupE.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,0, 'ZYX'));
      GroupF.children[0].position.copy (pos1[5]);
      GroupF.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,Math.PI, 'ZYX'));
      turning = 0; //not yet turning		
      manIn = 'D';
      moving = 'EtoD'; 
    }
    //////////////
    if (eT==3&&which == 'A'&&manIn=='F') {
      //currentPlane = 'F';
      //nextPlane = 'A';
      pos1[0] = new THREE.Vector3(0,-L/2, L/2);
      euler1[0] = new THREE.Euler (Math.PI/2,0,Math.PI/2, 'ZYX');
      euler2[0] = new THREE.Euler (0,Math.PI/2,0, 'ZYX');

      pos1[1] = new THREE.Vector3(L/2,-L/2, 0);
      euler1[1] = new THREE.Euler (0,-Math.PI/2,-Math.PI/2, 'ZYX');
      euler2[1] = new THREE.Euler (-Math.PI/2,Math.PI,0, 'ZYX');
      
      pos1[2] = new THREE.Vector3(0,-L/2, -L/2);
      euler1[2] = new THREE.Euler (-Math.PI/2,0,-Math.PI/2, 'ZYX');
      euler2[2] = new THREE.Euler (0,-Math.PI/2,Math.PI, 'ZYX');
      
      pos1[3] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[3] = new THREE.Euler (0,-Math.PI/2,Math.PI/2, 'ZYX');
      euler2[3] = new THREE.Euler (Math.PI/2,0,0, 'ZYX');
      
      pos1[4] = new THREE.Vector3(0,-L, 0);
      euler1[4] = new THREE.Euler (0,-Math.PI/2,Math.PI, 'ZYX');
      euler2[4] = new THREE.Euler (Math.PI/2,0,Math.PI/2, 'ZYX');
      
      pos1[5] = new THREE.Vector3(0,0,0);
      euler1[5] = new THREE.Euler (0,Math.PI/2,0, 'ZYX');
      euler2[5] = new THREE.Euler (-Math.PI/2,0,-Math.PI/2, 'ZYX');

      GroupA.children[0].position.copy (pos1[0]);
      GroupA.children[0].rotation.copy (new THREE.Euler (Math.PI/2,0,Math.PI/2, 'ZYX'));
      GroupB.children[0].position.copy (pos1[1]);
      GroupB.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,-Math.PI/2, 'ZYX'));
      GroupC.children[0].position.copy (pos1[2]);
      GroupC.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0,-Math.PI/2, 'ZYX'));
      GroupD.children[0].position.copy (pos1[3]);
      GroupD.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,Math.PI/2, 'ZYX'));
      GroupE.children[0].position.copy (pos1[4]);
      GroupE.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,Math.PI, 'ZYX'));
      GroupF.children[0].position.copy (pos1[5]);
      GroupF.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,0, 'ZYX'));
      turning = 0; //not yet turning		
      manIn = 'A';
      moving = 'FtoA'; 
    }
    if (eT==3&&which == 'B'&&manIn=='F') {
      //currentPlane = 'F';
      //nextPlane = 'B';
      pos1[0] = new THREE.Vector3(0,-L/2, L/2);
      euler1[0] = new THREE.Euler (Math.PI/2,0,0, 'ZYX');
      euler2[0] = new THREE.Euler (0,Math.PI/2,-Math.PI/2, 'ZYX');

      pos1[1] = new THREE.Vector3(L/2,-L/2, 0);
      euler1[1] = new THREE.Euler (0,Math.PI,-Math.PI/2, 'ZYX');
      euler2[1] = new THREE.Euler (0,Math.PI,0, 'ZYX');
      
      pos1[2] = new THREE.Vector3(0,-L/2, -L/2);
      euler1[2] = new THREE.Euler (-Math.PI/2,0,0, 'ZYX');
      euler2[2] = new THREE.Euler (0,-Math.PI/2,-Math.PI/2, 'ZYX');
      
      pos1[3] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[3] = new THREE.Euler (0,Math.PI,Math.PI/2, 'ZYX');
      euler2[3] = new THREE.Euler (Math.PI,0,0, 'ZYX');
      
      pos1[4] = new THREE.Vector3(0,-L, 0);
      euler1[4] = new THREE.Euler (0,Math.PI,Math.PI, 'ZYX');
      euler2[4] = new THREE.Euler (0,Math.PI,-Math.PI/2, 'ZYX');
      
      pos1[5] = new THREE.Vector3(0,0,0);
      euler1[5] = new THREE.Euler (0,0,0, 'ZYX');
      euler2[5] = new THREE.Euler (0,0,-Math.PI/2, 'ZYX');

      GroupA.children[0].position.copy (pos1[0]);
      GroupA.children[0].rotation.copy (new THREE.Euler (Math.PI/2,0,Math.PI/2, 'ZYX'));
      GroupB.children[0].position.copy (pos1[1]);
      GroupB.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,-Math.PI/2, 'ZYX'));
      GroupC.children[0].position.copy (pos1[2]);
      GroupC.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0,-Math.PI/2, 'ZYX'));
      GroupD.children[0].position.copy (pos1[3]);
      GroupD.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,Math.PI/2, 'ZYX'));
      GroupE.children[0].position.copy (pos1[4]);
      GroupE.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,Math.PI, 'ZYX'));
      GroupF.children[0].position.copy (pos1[5]);
      GroupF.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,0, 'ZYX'));
      turning = 0; //not yet turning		
      manIn = 'B';
      moving = 'FtoB'; 
    }
    if (eT==3&&which == 'C'&&manIn=='F') {
      //currentPlane = 'F';
      //nextPlane = 'C';
      pos1[0] = new THREE.Vector3(0,-L/2, L/2);
      euler1[0] = new THREE.Euler (Math.PI/2,0,-Math.PI/2, 'ZYX');
      euler2[0] = new THREE.Euler (0,Math.PI/2,Math.PI, 'ZYX');

      pos1[1] = new THREE.Vector3(L/2,-L/2, 0);
      euler1[1] = new THREE.Euler (0,Math.PI/2,-Math.PI/2, 'ZYX');
      euler2[1] = new THREE.Euler (-Math.PI/2,0,Math.PI, 'ZYX');
      
      pos1[2] = new THREE.Vector3(0,-L/2, -L/2);
      euler1[2] = new THREE.Euler (-Math.PI/2,0,Math.PI/2, 'ZYX');
      euler2[2] = new THREE.Euler (0,-Math.PI/2,0, 'ZYX');
      
      pos1[3] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[3] = new THREE.Euler (0,Math.PI/2,Math.PI/2, 'ZYX');
      euler2[3] = new THREE.Euler (-Math.PI/2,0,0, 'ZYX');
      
      pos1[4] = new THREE.Vector3(0,-L, 0);
      euler1[4] = new THREE.Euler (0,Math.PI/2,Math.PI, 'ZYX');
      euler2[4] = new THREE.Euler (-Math.PI/2,0,Math.PI/2, 'ZYX');
      
      pos1[5] = new THREE.Vector3(0,0,0);
      euler1[5] = new THREE.Euler (0,-Math.PI/2,0, 'ZYX');
      euler2[5] = new THREE.Euler (Math.PI/2,0,-Math.PI/2, 'ZYX');

      GroupA.children[0].position.copy (pos1[0]);
      GroupA.children[0].rotation.copy (new THREE.Euler (Math.PI/2,0,Math.PI/2, 'ZYX'));
      GroupB.children[0].position.copy (pos1[1]);
      GroupB.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,-Math.PI/2, 'ZYX'));
      GroupC.children[0].position.copy (pos1[2]);
      GroupC.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0,-Math.PI/2, 'ZYX'));
      GroupD.children[0].position.copy (pos1[3]);
      GroupD.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,Math.PI/2, 'ZYX'));
      GroupE.children[0].position.copy (pos1[4]);
      GroupE.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,Math.PI, 'ZYX'));
      GroupF.children[0].position.copy (pos1[5]);
      GroupF.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,0, 'ZYX'));
      turning = 0; //not yet turning		
      manIn = 'C';
      moving = 'FtoC'; 
    }
    if (eT==3&&which == 'D'&&manIn=='F') {
      //currentPlane = 'F';
      //nextPlane = 'D';
      pos1[0] = new THREE.Vector3(0,-L/2, L/2);
      euler1[0] = new THREE.Euler (Math.PI/2,0,Math.PI, 'ZYX');
      euler2[0] = new THREE.Euler (0,Math.PI/2,Math.PI/2, 'ZYX');

      pos1[1] = new THREE.Vector3(L/2,-L/2, 0);
      euler1[1] = new THREE.Euler (0,0,-Math.PI/2, 'ZYX');
      euler2[1] = new THREE.Euler (0,0,Math.PI, 'ZYX');
      
      pos1[2] = new THREE.Vector3(0,-L/2, -L/2);
      euler1[2] = new THREE.Euler (-Math.PI/2,0,Math.PI, 'ZYX');
      euler2[2] = new THREE.Euler (0,-Math.PI/2,Math.PI/2, 'ZYX');
      
      pos1[3] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[3] = new THREE.Euler (0,0,Math.PI/2, 'ZYX');
      euler2[3] = new THREE.Euler (0,0,0, 'ZYX');
      
      pos1[4] = new THREE.Vector3(0,-L, 0);
      euler1[4] = new THREE.Euler (0,0,Math.PI, 'ZYX');
      euler2[4] = new THREE.Euler (0,0,Math.PI/2, 'ZYX');
      
      pos1[5] = new THREE.Vector3(0,0,0);
      euler1[5] = new THREE.Euler (0,Math.PI,0, 'ZYX');
      euler2[5] = new THREE.Euler (0,Math.PI,Math.PI/2, 'ZYX');

      GroupA.children[0].position.copy (pos1[0]);
      GroupA.children[0].rotation.copy (new THREE.Euler (Math.PI/2,0,Math.PI/2, 'ZYX'));
      GroupB.children[0].position.copy (pos1[1]);
      GroupB.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,-Math.PI/2, 'ZYX'));
      GroupC.children[0].position.copy (pos1[2]);
      GroupC.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0,-Math.PI/2, 'ZYX'));
      GroupD.children[0].position.copy (pos1[3]);
      GroupD.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,Math.PI/2, 'ZYX'));
      GroupE.children[0].position.copy (pos1[4]);
      GroupE.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,Math.PI, 'ZYX'));
      GroupF.children[0].position.copy (pos1[5]);
      GroupF.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,0, 'ZYX'));
      turning = 0; //not yet turning		
      manIn = 'D';
      moving = 'FtoD'; 
    }
    
    if(eT>3&&moving == 'AtoE'&&manIn=='E')AtoE(); 
    if(eT>3&&moving == 'AtoB'&&manIn=='B')AtoB();
    if(eT>3&&moving == 'AtoD'&&manIn=='D')AtoD(); 
    if(eT>3&&moving == 'AtoF'&&manIn=='F')AtoF(); 
    
    if(eT>3&&moving == 'BtoC'&&manIn=='C')BtoC();
    if(eT>3&&moving == 'BtoE'&&manIn=='E')BtoE();
    if(eT>3&&moving == 'BtoA'&&manIn=='A')BtoA(); 
    if(eT>3&&moving == 'BtoF'&&manIn=='F')BtoF(); 
    
    if(eT>3&&moving == 'CtoD'&&manIn=='D')CtoD(); 
    if(eT>3&&moving == 'CtoE'&&manIn=='E')CtoE(); 
    if(eT>3&&moving == 'CtoB'&&manIn=='B')CtoB(); 
    if(eT>3&&moving == 'CtoF'&&manIn=='F')CtoF(); 
    
    if(eT>3&&moving == 'DtoA'&&manIn=='A')DtoA(); 
    if(eT>3&&moving == 'DtoE'&&manIn=='E')DtoE(); 
    if(eT>3&&moving == 'DtoC'&&manIn=='C')DtoC(); 
    if(eT>3&&moving == 'DtoF'&&manIn=='F')DtoF(); 
    
    if(eT>3&&moving == 'EtoA'&&manIn=='A')EtoA(); 
    if(eT>3&&moving == 'EtoB'&&manIn=='B')EtoB(); 
    if(eT>3&&moving == 'EtoC'&&manIn=='C')EtoC(); 
    if(eT>3&&moving == 'EtoD'&&manIn=='D')EtoD(); 
    
    if(eT>3&&moving == 'FtoA'&&manIn=='A')FtoA(); 
    if(eT>3&&moving == 'FtoB'&&manIn=='B')FtoB(); 
    if(eT>3&&moving == 'FtoC'&&manIn=='C')FtoC(); 
    if(eT>3&&moving == 'FtoD'&&manIn=='D')FtoD(); 
}

  function AtoB() {
  var triStep = .90;
    if (turning === 0) {
      if(GroupA.children[0].rotation.y>0){
        GroupA.children[0].rotation.y -= 0.05;
        GroupB.children[0].rotation.z -= 0.05;
        GroupC.children[0].rotation.y -= 0.05;
        GroupD.children[0].rotation.z -= 0.05;
        GroupE.children[0].rotation.z -= 0.05;
        GroupF.children[0].rotation.z += 0.05;
      }
      else{
        GroupA.children[0].position.x += triStep;
        GroupB.children[0].position.y += triStep;
        GroupC.children[0].position.x += triStep;
        GroupD.children[0].position.y -= triStep;
        GroupE.children[0].position.x += triStep;
        GroupF.children[0].position.x += triStep;
      }
      if (GroupA.children[0].position.x > L/2-L/kk&&GroupB.children[0].position.y > -L/kk) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(L/2-L/kk, 0, 0);
        pos2[0] = new THREE.Vector3(L/2, 0, 0);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        /////////////////////
        pos1[1] = new THREE.Vector3(0,-L/kk, L/2);
        pos2[1] = new THREE.Vector3(0, 0, L/2);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ////////////////////
        pos1[2] = new THREE.Vector3(L/2-L/kk,-L, 0);
        pos2[2] = new THREE.Vector3(L/2,-L, 0);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ////////////////////
        pos1[3] = new THREE.Vector3(0,-L+L/kk, L/2);
        pos2[3] = new THREE.Vector3(0,-L, L/2);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(L/2-L/kk,-L/2, L/2);
        pos2[4] = new THREE.Vector3(L/2,-L/2, L/2);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(L/2-L/kk,-L/2, -L/2);
        pos2[5] = new THREE.Vector3(L/2,-L/2, -L/2);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
    
      if (GroupA.children[0].position.y < -L/2&&GroupB.children[0].position.z < 0) {
        if(GroupA.children[0].rotation.y<Math.PI/2){
        GroupA.children[0].rotation.y += 0.05;
        GroupB.children[0].rotation.y += 0.05;
        GroupC.children[0].rotation.y += 0.05;
        GroupD.children[0].rotation.y += 0.05;
        GroupE.children[0].rotation.y += 0.05;
        GroupF.children[0].rotation.y += 0.05;
        }
        else moving = false;
      }
      else{
        GroupA.children[0].position.y -= triStep;
        GroupB.children[0].position.z -= triStep;
        GroupC.children[0].position.y += triStep;
        GroupD.children[0].position.z -= triStep;
        GroupE.children[0].position.z -= triStep;
        GroupF.children[0].position.z += triStep;
      }
    }
  }
  function AtoD() {
  var triStep = .90;
    if (turning === 0) {
      if(GroupA.children[0].rotation.y<Math.PI){
        GroupA.children[0].rotation.y += 0.05;
        GroupB.children[0].rotation.z += 0.05;
        GroupC.children[0].rotation.y += 0.05;
        GroupD.children[0].rotation.z += 0.05;
        GroupE.children[0].rotation.z += 0.05;
        GroupF.children[0].rotation.z -= 0.05;
      }
      else{
        GroupA.children[0].position.x -= triStep;
        GroupB.children[0].position.y -= triStep;
        GroupC.children[0].position.x -= triStep;
        GroupD.children[0].position.y += triStep;
        GroupE.children[0].position.x -= triStep;
        GroupF.children[0].position.x -= triStep;
      }
      if (GroupA.children[0].position.x < -L/2+L/kk) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(-L/2+L/kk, 0, 0);
        pos2[0] = new THREE.Vector3(-L/2,0, 0);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        /////////////////////
        pos1[1] = new THREE.Vector3(0,-L+L/kk, L/2);
        pos2[1] = new THREE.Vector3(0,-L, L/2);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ////////////////////
        pos1[2] = new THREE.Vector3(-L/2+L/kk,-L, 0);
        pos2[2] = new THREE.Vector3(-L/2,-L, 0);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ////////////////////
        pos1[3] = new THREE.Vector3(0,-L/kk, L/2);
        pos2[3] = new THREE.Vector3(0,0, L/2);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(-L/2+L/kk,-L/2, L/2);
        pos2[4] = new THREE.Vector3(-L/2,-L/2, L/2);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(-L/2+L/kk,-L/2, -L/2);
        pos2[5] = new THREE.Vector3(-L/2,-L/2, -L/2);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
    
      if (GroupA.children[0].position.y < -L/2) {
        if(GroupA.children[0].rotation.y>Math.PI/2){
        GroupA.children[0].rotation.y -= 0.05;
        GroupB.children[0].rotation.y -= 0.05;
        GroupC.children[0].rotation.y -= 0.05;
        GroupD.children[0].rotation.y -= 0.05;
        GroupE.children[0].rotation.y -= 0.05;
        GroupF.children[0].rotation.y -= 0.05;
        }
        else moving = false;
      }
      else{
        GroupA.children[0].position.y -= triStep;
        GroupB.children[0].position.z -= triStep;
        GroupC.children[0].position.y += triStep;
        GroupD.children[0].position.z -= triStep;
        GroupE.children[0].position.z -= triStep;
        GroupF.children[0].position.z += triStep;
      }
    }
  }
  function AtoE() {
  var triStep = .90;
    if (turning === 0) {
      GroupA.children[0].position.z -= triStep;
      GroupB.children[0].position.x -= triStep;
      GroupC.children[0].position.z += triStep;
      GroupD.children[0].position.x += triStep;
      GroupE.children[0].position.y += triStep;
      GroupF.children[0].position.y -= triStep;
      if (GroupA.children[0].position.z < -L/2+L/kk&&GroupB.children[0].position.x < -L/2+L/kk) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(0, 0, -L/2+L/kk);
        pos2[0] = new THREE.Vector3(0, 0, -L/2);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        /////////////////
        pos1[1] = new THREE.Vector3(-L/2+L/kk,-L/2, L/2);
        pos2[1] = new THREE.Vector3(-L/2,-L/2, L/2);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        /////////////////
        pos1[2] = new THREE.Vector3(0,-L, L/2-L/kk);
        pos2[2] = new THREE.Vector3(0,-L, L/2);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        /////////////////
        pos1[3] = new THREE.Vector3(L/2-L/kk,-L/2, L/2);
        pos2[3] = new THREE.Vector3(L/2,-L/2, L/2);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        /////////////////
        pos1[4] = new THREE.Vector3(0,-L/kk, L/2);
        pos2[4] = new THREE.Vector3(0,0, L/2);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        /////////////////
        pos1[5] = new THREE.Vector3(0,-L+L/kk, -L/2);
        pos2[5] = new THREE.Vector3(0,-L, -L/2);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        /////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
        
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
    GroupA.children[0].position.y -= triStep;
    GroupB.children[0].position.z -= triStep;
    GroupC.children[0].position.y += triStep;
    GroupD.children[0].position.z -= triStep;
    GroupE.children[0].position.z -= triStep;
    GroupF.children[0].position.z += triStep;
      if (GroupA.children[0].position.y < -L/2) {
        moving = false;
      }
    }
  }
  function AtoF() {
  var triStep = .90;
    if (turning === 0) {
      if(GroupA.children[0].rotation.y>-Math.PI/2){
        GroupA.children[0].rotation.y -= 0.05;
        GroupB.children[0].rotation.z -= 0.05;
        GroupC.children[0].rotation.y -= 0.05;
        GroupD.children[0].rotation.z -= 0.05;
        GroupE.children[0].rotation.z -= 0.05;
        GroupF.children[0].rotation.z += 0.05;
      }
      else{
        GroupA.children[0].position.z += triStep;
        GroupB.children[0].position.x += triStep;
        GroupC.children[0].position.z -= triStep;
        GroupD.children[0].position.x -= triStep;
        GroupE.children[0].position.y -= triStep;
        GroupF.children[0].position.y += triStep;
      }
      if (GroupA.children[0].position.z > L/2-L/kk) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(0,0,L/2-L/kk);
        pos2[0] = new THREE.Vector3(0,0,L/2);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        /////////////////////
        pos1[1] = new THREE.Vector3(L/2-L/kk,-L/2, L/2);
        pos2[1] = new THREE.Vector3(L/2,-L/2, L/2);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ////////////////////
        pos1[2] = new THREE.Vector3(0,-L, -L/2+L/kk);
        pos2[2] = new THREE.Vector3(0,-L, -L/2);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ////////////////////
        pos1[3] = new THREE.Vector3(-L/2+L/kk,-L/2, L/2);
        pos2[3] = new THREE.Vector3(-L/2,-L/2, L/2);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(0,-L+L/kk, L/2);
        pos2[4] = new THREE.Vector3(0,-L, L/2);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(0,-L/kk, -L/2);
        pos2[5] = new THREE.Vector3(0,0, -L/2);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
    
      if (GroupA.children[0].position.y < -L/2) {
        if(GroupA.children[0].rotation.z<Math.PI/2){
        GroupA.children[0].rotation.z += 0.05;
        GroupB.children[0].rotation.y += 0.05;
        GroupC.children[0].rotation.z -= 0.05;
        GroupD.children[0].rotation.y += 0.05;
        GroupE.children[0].rotation.y += 0.05;
        GroupF.children[0].rotation.y += 0.05;
        }
        else moving = false;
      }
      else{
        GroupA.children[0].position.y -= triStep;
        GroupB.children[0].position.z -= triStep;
        GroupC.children[0].position.y += triStep;
        GroupD.children[0].position.z -= triStep;
        GroupE.children[0].position.z -= triStep;
        GroupF.children[0].position.z += triStep;
      }
    }
  }

  function BtoC() {
  var triStep = .90;
    if (turning === 0) {
      if(GroupA.children[0].rotation.y>0){
          GroupA.children[0].rotation.y -= 0.05;
          GroupB.children[0].rotation.y -= 0.05;
          GroupC.children[0].rotation.y -= 0.05;
          GroupD.children[0].rotation.y -= 0.05;
          GroupE.children[0].rotation.y -= 0.05;
          GroupF.children[0].rotation.y -= 0.05;
      }
      else{
        GroupA.children[0].position.y -= triStep;
        GroupB.children[0].position.z -= triStep;
        GroupC.children[0].position.y += triStep;
        GroupD.children[0].position.z -= triStep;
        GroupE.children[0].position.z -= triStep;
        GroupF.children[0].position.z += triStep;
      }
      if (GroupA.children[0].position.y < -L) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(L/2, -L, 0);
        pos2[0] = new THREE.Vector3(L/2, -L, 0);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        ///////////////////
        pos1[1] = new THREE.Vector3(0,0, -L/2);
        pos2[1] = new THREE.Vector3(0,0, -L/2);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ///////////////////
        pos1[2] = new THREE.Vector3(L/2,0, 0);
        pos2[2] = new THREE.Vector3(L/2,0, 0);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ///////////////////
        pos1[3] = new THREE.Vector3(0,-L, -L/2);
        pos2[3] = new THREE.Vector3(0,-L, -L/2);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(L/2,-L/2, -L/2);
        pos2[4] = new THREE.Vector3(L/2,-L/2, -L/2);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(L/2,-L/2, L/2);
        pos2[5] = new THREE.Vector3(L/2,-L/2, L/2);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
      if (GroupA.children[0].position.x < 0){
        if(GroupA.children[0].rotation.y<Math.PI/2){
          GroupA.children[0].rotation.y += 0.05;
          GroupB.children[0].rotation.z -= 0.05;
          GroupC.children[0].rotation.y += 0.05;
          GroupD.children[0].rotation.z -= 0.05;
          GroupE.children[0].rotation.z -= 0.05;
          GroupF.children[0].rotation.z += 0.05;
        }
        else moving = false;
      }
      else{
      GroupA.children[0].position.x -= triStep;
      GroupB.children[0].position.y -= triStep;
      GroupC.children[0].position.x -= triStep;
      GroupD.children[0].position.y += triStep;
      GroupE.children[0].position.x -= triStep;
      GroupF.children[0].position.x -= triStep;
      }
    }
  }
  function BtoE() {
  var triStep = .90;
    if (turning === 0) {
      GroupA.children[0].position.z -= triStep;
      GroupB.children[0].position.x -= triStep;
      GroupC.children[0].position.z += triStep;
      GroupD.children[0].position.x += triStep;
      GroupE.children[0].position.y += triStep;
      GroupF.children[0].position.y -= triStep;
      if (GroupA.children[0].position.z < -L/2) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(L/2, -L/2, -L/2);
        pos2[0] = new THREE.Vector3(L/2, -L/2, -L/2);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        ///////////////////
        pos1[1] = new THREE.Vector3(-L/2, 0, 0);
        pos2[1] = new THREE.Vector3(-L/2, 0, 0);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ///////////////////
        pos1[2] = new THREE.Vector3(L/2, -L/2, L/2);
        pos2[2] = new THREE.Vector3(L/2, -L/2, L/2);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ///////////////////
        pos1[3] = new THREE.Vector3(L/2, -L, 0);
        pos2[3] = new THREE.Vector3(L/2,-L, 0);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(L/2,0, 0);
        pos2[4] = new THREE.Vector3(L/2,0, 0);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(L/2,-L, 0);
        pos2[5] = new THREE.Vector3(L/2,-L, 0);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
    
      if (GroupA.children[0].position.x < 0){
        
        if(GroupA.children[0].rotation.z<Math.PI+Math.PI/2){
          GroupA.children[0].rotation.z += 0.05;
          GroupB.children[0].rotation.y -= 0.05;
          GroupC.children[0].rotation.z -= 0.05;
          GroupD.children[0].rotation.y -= 0.05;
          GroupE.children[0].rotation.y -= 0.05;
          GroupF.children[0].rotation.y -= 0.05;
        }
        else moving = false;
      }
      else{
        GroupA.children[0].position.x -= triStep;
        GroupB.children[0].position.y -= triStep;
        GroupC.children[0].position.x -= triStep;
        GroupD.children[0].position.y += triStep;
        GroupE.children[0].position.x -= triStep;
        GroupF.children[0].position.x -= triStep;
      }
    }
  }
  function BtoA() {
  var triStep = .90;
    if (turning === 0) {
      if(GroupA.children[0].rotation.y<Math.PI){
          GroupA.children[0].rotation.y += 0.05;
          GroupB.children[0].rotation.y += 0.05;
          GroupC.children[0].rotation.y += 0.05;
          GroupD.children[0].rotation.y += 0.05;
          GroupE.children[0].rotation.y += 0.05;
          GroupF.children[0].rotation.y += 0.05;
      }
      else{
        GroupA.children[0].position.y += triStep;
        GroupB.children[0].position.z += triStep;
        GroupC.children[0].position.y -= triStep;
        GroupD.children[0].position.z += triStep;
        GroupE.children[0].position.z += triStep;
        GroupF.children[0].position.z -= triStep;
      }
      if (GroupA.children[0].position.y > 0) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(L/2, 0, 0);
        pos2[0] = new THREE.Vector3(L/2, 0, 0);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        ///////////////////
        pos1[1] = new THREE.Vector3(0, 0, L/2);
        pos2[1] = new THREE.Vector3(0, 0, L/2);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ///////////////////
        pos1[2] = new THREE.Vector3(L/2,-L, 0);
        pos2[2] = new THREE.Vector3(L/2,-L, 0);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ///////////////////
        pos1[3] = new THREE.Vector3(0,-L, L/2);
        pos2[3] = new THREE.Vector3(0,-L, L/2);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(L/2,-L/2, L/2);
        pos2[4] = new THREE.Vector3(L/2,-L/2, L/2);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(L/2,-L/2, -L/2);
        pos2[5] = new THREE.Vector3(L/2,-L/2, -L/2);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
      if (GroupA.children[0].position.x < 0){
        if(GroupA.children[0].rotation.y>Math.PI/2){
          GroupA.children[0].rotation.y -= 0.05;
          GroupB.children[0].rotation.z -= 0.05;
          GroupC.children[0].rotation.y -= 0.05;
          GroupD.children[0].rotation.z -= 0.05;
          GroupE.children[0].rotation.z -= 0.05;
          GroupF.children[0].rotation.z += 0.05;
        }
        else moving = false;
      }
      else{
      GroupA.children[0].position.x -= triStep;
      GroupB.children[0].position.y -= triStep;
      GroupC.children[0].position.x -= triStep;
      GroupD.children[0].position.y += triStep;
      GroupE.children[0].position.x -= triStep;
      GroupF.children[0].position.x -= triStep;
      }
    }
  }
  function BtoF() {
  var triStep = .90;
    if (turning === 0) {
      if(GroupA.children[0].rotation.y>-Math.PI/2){
        GroupA.children[0].rotation.y -= 0.05;
        GroupB.children[0].rotation.y -= 0.05;
        GroupC.children[0].rotation.y -= 0.05;
        GroupD.children[0].rotation.y -= 0.05;
        GroupE.children[0].rotation.y -= 0.05;
        GroupF.children[0].rotation.y -= 0.05;
      }
      else{
        GroupA.children[0].position.z += triStep;
        GroupB.children[0].position.x += triStep;
        GroupC.children[0].position.z -= triStep;
        GroupD.children[0].position.x -= triStep;
        GroupE.children[0].position.y -= triStep;
        GroupF.children[0].position.y += triStep;
      }
      if (GroupA.children[0].position.z > L/2-L/kk) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(L/2, -L/2, L/2-L/kk);
        pos2[0] = new THREE.Vector3(L/2, -L/2, L/2);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        ///////////////////
        pos1[1] = new THREE.Vector3(L/2-L/kk, 0, 0);
        pos2[1] = new THREE.Vector3(L/2, 0, 0);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ///////////////////
        pos1[2] = new THREE.Vector3(L/2, -L/2, -L/2+L/kk);
        pos2[2] = new THREE.Vector3(L/2, -L/2, -L/2);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ///////////////////
        pos1[3] = new THREE.Vector3(-L/2+L/kk, -L, 0);
        pos2[3] = new THREE.Vector3(-L/2,-L, 0);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(L/2,-L+L/kk, 0);
        pos2[4] = new THREE.Vector3(L/2,-L, 0);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(L/2,-L/kk, 0);
        pos2[5] = new THREE.Vector3(L/2,0, 0);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
    
      if (GroupA.children[0].position.x < 0){
        
        if(GroupA.children[0].rotation.z>Math.PI/2){
          GroupA.children[0].rotation.z -= 0.05;
          GroupB.children[0].rotation.y -= 0.05;
          GroupC.children[0].rotation.z += 0.05;
          GroupD.children[0].rotation.y -= 0.05;
          GroupE.children[0].rotation.y -= 0.05;
          GroupF.children[0].rotation.y -= 0.05;
        }
        else moving = false;
      }
      else{
        GroupA.children[0].position.x -= triStep;
        GroupB.children[0].position.y -= triStep;
        GroupC.children[0].position.x -= triStep;
        GroupD.children[0].position.y += triStep;
        GroupE.children[0].position.x -= triStep;
        GroupF.children[0].position.x -= triStep;
      }
    }
  }

  function CtoD() {
  var triStep = .90;
    if (turning === 0) {
      if(GroupA.children[0].rotation.y>0){
        GroupA.children[0].rotation.y -= 0.05;
        GroupB.children[0].rotation.z += 0.05;
        GroupC.children[0].rotation.y -= 0.05;
        GroupD.children[0].rotation.z += 0.05;
        GroupE.children[0].rotation.z += 0.05;
        GroupF.children[0].rotation.z -= 0.05;
      }
      else{
        GroupA.children[0].position.x -= triStep;
        GroupB.children[0].position.y -= triStep;
        GroupC.children[0].position.x -= triStep;
        GroupD.children[0].position.y += triStep;
        GroupE.children[0].position.x -= triStep;
        GroupF.children[0].position.x -= triStep;
      }
      if (GroupA.children[0].position.x < -L/2+L/kk) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(-L/2+L/kk,-L, 0);
        pos2[0] = new THREE.Vector3(-L/2,-L, 0);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        ///////////////////
        pos1[1] = new THREE.Vector3(0,-L+L/kk, -L/2);
        pos2[1] = new THREE.Vector3(0,-L, -L/2);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ///////////////////
        pos1[2] = new THREE.Vector3(-L/2+L/kk,0, 0);
        pos2[2] = new THREE.Vector3(-L/2,0, 0);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ///////////////////
        pos1[3] = new THREE.Vector3(0,-L/kk, -L/2);
        pos2[3] = new THREE.Vector3(0,0, -L/2);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(-L/2+L/kk,-L/2, -L/2);
        pos2[4] = new THREE.Vector3(-L/2,-L/2, -L/2);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(-L/2+L/kk,-L/2, L/2);
        pos2[5] = new THREE.Vector3(-L/2,-L/2, L/2);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
    
      if (GroupA.children[0].position.y > -L/2){
        
        if(GroupA.children[0].rotation.y<Math.PI/2){
          GroupA.children[0].rotation.y += 0.05;
          GroupB.children[0].rotation.y += 0.05;
          GroupC.children[0].rotation.y += 0.05;
          GroupD.children[0].rotation.y += 0.05;
          GroupE.children[0].rotation.y += 0.05;
          GroupF.children[0].rotation.y += 0.05;
        }
        else moving = false;
      }
      else{
        GroupA.children[0].position.y += triStep;
        GroupB.children[0].position.z += triStep;
        GroupC.children[0].position.y -= triStep;
        GroupD.children[0].position.z += triStep;
        GroupE.children[0].position.z += triStep;
        GroupF.children[0].position.z -= triStep;
      }
    }
  }
  function CtoB() {
  var triStep = .90;
    if (turning === 0) {
      if(GroupA.children[0].rotation.y<Math.PI){
        GroupA.children[0].rotation.y += 0.05;
        GroupB.children[0].rotation.z -= 0.05;
        GroupC.children[0].rotation.y += 0.05;
        GroupD.children[0].rotation.z -= 0.05;
        GroupE.children[0].rotation.z -= 0.05;
        GroupF.children[0].rotation.z += 0.05;
      }
      else{
        GroupA.children[0].position.x += triStep;
        GroupB.children[0].position.y += triStep;
        GroupC.children[0].position.x += triStep;
        GroupD.children[0].position.y -= triStep;
        GroupE.children[0].position.x += triStep;
        GroupF.children[0].position.x += triStep;
      }
      if (GroupA.children[0].position.x > L/2-L/kk) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(L/2-L/kk,-L, 0);
        pos2[0] = new THREE.Vector3(L/2,-L, 0);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        ///////////////////
        pos1[1] = new THREE.Vector3(0,-L/kk, -L/2);
        pos2[1] = new THREE.Vector3(0,0, -L/2);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ///////////////////
        pos1[2] = new THREE.Vector3(L/2-L/kk,0, 0);
        pos2[2] = new THREE.Vector3(L/2,0, 0);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ///////////////////
        pos1[3] = new THREE.Vector3(0,-L+L/kk, -L/2);
        pos2[3] = new THREE.Vector3(0,-L, -L/2);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(L/2-L/kk,-L/2, -L/2);
        pos2[4] = new THREE.Vector3(L/2,-L/2, -L/2);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(L/2-L/kk,-L/2, L/2);
        pos2[5] = new THREE.Vector3(L/2,-L/2, L/2);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
    
      if (GroupA.children[0].position.y > -L/2){
        
        if(GroupA.children[0].rotation.y > Math.PI/2){
          GroupA.children[0].rotation.y -= 0.05;
          GroupB.children[0].rotation.y -= 0.05;
          GroupC.children[0].rotation.y -= 0.05;
          GroupD.children[0].rotation.y -= 0.05;
          GroupE.children[0].rotation.y -= 0.05;
          GroupF.children[0].rotation.y -= 0.05;
        }
        else moving = false;
      }
      else{
        GroupA.children[0].position.y += triStep;
        GroupB.children[0].position.z += triStep;
        GroupC.children[0].position.y -= triStep;
        GroupD.children[0].position.z += triStep;
        GroupE.children[0].position.z += triStep;
        GroupF.children[0].position.z -= triStep;
      }
    }
  }
  function CtoE() {
  var triStep = .90;
    if (turning === 0) {
      GroupA.children[0].position.z -= triStep;
      GroupB.children[0].position.x -= triStep;
      GroupC.children[0].position.z += triStep;
      GroupD.children[0].position.x += triStep;
      GroupE.children[0].position.y += triStep;
      GroupF.children[0].position.y -= triStep;
      if (GroupA.children[0].position.z < -L/2) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(0,-L, -L/2);
        pos2[0] = new THREE.Vector3(0,-L, -L/2);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        ///////////////////
        pos1[1] = new THREE.Vector3(-L/2,-L/2, -L/2);
        pos2[1] = new THREE.Vector3(-L/2,-L/2, -L/2);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ///////////////////
        pos1[2] = new THREE.Vector3(0,0,L/2);
        pos2[2] = new THREE.Vector3(0,0,L/2);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ///////////////////
        pos1[3] = new THREE.Vector3(L/2,-L/2, -L/2);
        pos2[3] = new THREE.Vector3(L/2,-L/2, -L/2);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(0,0, -L/2);
        pos2[4] = new THREE.Vector3(0,0, -L/2);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(0,-L, L/2);
        pos2[5] = new THREE.Vector3(0,-L, L/2);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
    
      if (GroupA.children[0].position.y > -L/2){
        
        if(GroupA.children[0].rotation.z < Math.PI + Math.PI/2){
          GroupA.children[0].rotation.z += 0.05;
          GroupB.children[0].rotation.y -= 0.05;
          GroupC.children[0].rotation.z -= 0.05;
          GroupD.children[0].rotation.y -= 0.05;
          GroupE.children[0].rotation.y -= 0.05;
          GroupF.children[0].rotation.y -= 0.05;
        }
        else moving = false;
      }
      else{
        GroupA.children[0].position.y += triStep;
        GroupB.children[0].position.z += triStep;
        GroupC.children[0].position.y -= triStep;
        GroupD.children[0].position.z += triStep;
        GroupE.children[0].position.z += triStep;
        GroupF.children[0].position.z -= triStep;
      }
    }
  }
  function CtoF() {
  var triStep = .90;
    if (turning === 0) {
      if(GroupA.children[0].rotation.y>-Math.PI/2){
        GroupA.children[0].rotation.y -= 0.05;
        GroupB.children[0].rotation.z += 0.05;
        GroupC.children[0].rotation.y -= 0.05;
        GroupD.children[0].rotation.z += 0.05;
        GroupE.children[0].rotation.z += 0.05;
        GroupF.children[0].rotation.z -= 0.05;
      }
      else{
        GroupA.children[0].position.z += triStep;
        GroupB.children[0].position.x += triStep;
        GroupC.children[0].position.z -= triStep;
        GroupD.children[0].position.x -= triStep;
        GroupE.children[0].position.y -= triStep;
        GroupF.children[0].position.y += triStep;
      }
      if (GroupA.children[0].position.z > L/2) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(0,-L, L/2);
        pos2[0] = new THREE.Vector3(0,-L, L/2);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        ///////////////////
        pos1[1] = new THREE.Vector3(L/2,-L/2, -L/2);
        pos2[1] = new THREE.Vector3(L/2,-L/2, -L/2);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ///////////////////
        pos1[2] = new THREE.Vector3(0,0,-L/2);
        pos2[2] = new THREE.Vector3(0,0,-L/2);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ///////////////////
        pos1[3] = new THREE.Vector3(-L/2,-L/2, -L/2);
        pos2[3] = new THREE.Vector3(-L/2,-L/2, -L/2);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(0,-L, -L/2);
        pos2[4] = new THREE.Vector3(0,-L, -L/2);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(0,0, L/2);
        pos2[5] = new THREE.Vector3(0,0, L/2);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
    
      if (GroupA.children[0].position.y > -L/2){
          moving = false;
      }
      else{
        GroupA.children[0].position.y += triStep;
        GroupB.children[0].position.z += triStep;
        GroupC.children[0].position.y -= triStep;
        GroupD.children[0].position.z += triStep;
        GroupE.children[0].position.z += triStep;
        GroupF.children[0].position.z -= triStep;
      }
    }
  }

  function DtoA() {
  var triStep = .90;
    if (turning === 0) {
      if(GroupA.children[0].rotation.y > 0){
          GroupA.children[0].rotation.y -= 0.05;
          GroupB.children[0].rotation.y -= 0.05;
          GroupC.children[0].rotation.y -= 0.05;
          GroupD.children[0].rotation.y -= 0.05;
          GroupE.children[0].rotation.y -= 0.05;
          GroupF.children[0].rotation.y -= 0.05;
      }
      else{
        GroupA.children[0].position.y += triStep;
        GroupB.children[0].position.z += triStep;
        GroupC.children[0].position.y -= triStep;
        GroupD.children[0].position.z += triStep;
        GroupE.children[0].position.z += triStep;
        GroupF.children[0].position.z -= triStep;
      }
      if (GroupA.children[0].position.y > -L/kk) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(-L/2,-L/kk, 0);
        pos2[0] = new THREE.Vector3(-L/2,0, 0);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        ///////////////////
        pos1[1] = new THREE.Vector3(0,-L, L/2-L/kk);
        pos2[1] = new THREE.Vector3(0,-L, L/2);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ///////////////////
        pos1[2] = new THREE.Vector3(-L/2,-L+L/kk, 0);
        pos2[2] = new THREE.Vector3(-L/2,-L, 0);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ///////////////////
        pos1[3] = new THREE.Vector3(0,0, L/2-L/kk);
        pos2[3] = new THREE.Vector3(0,0, L/2);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(-L/2,-L/2, L/2-L/kk);
        pos2[4] = new THREE.Vector3(-L/2,-L/2, L/2);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(-L/2,-L/2, -L/2+L/kk);
        pos2[5] = new THREE.Vector3(-L/2,-L/2, -L/2);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
    
      if (GroupA.children[0].position.x > 0){
        
        if(GroupA.children[0].rotation.y < Math.PI/2){
          GroupA.children[0].rotation.y += 0.05;
          GroupB.children[0].rotation.z += 0.05;
          GroupC.children[0].rotation.y -= 0.05;
          GroupD.children[0].rotation.z += 0.05;
          GroupE.children[0].rotation.z += 0.05;
          GroupF.children[0].rotation.z -= 0.05;
        }
        else moving = false;
      }
      else{
        GroupA.children[0].position.x += triStep;
        GroupB.children[0].position.y += triStep;
        GroupC.children[0].position.x += triStep;
        GroupD.children[0].position.y -= triStep;
        GroupE.children[0].position.x += triStep;
        GroupF.children[0].position.x += triStep;
      }
    }
  }
  function DtoC() {
  var triStep = .90;
    if (turning === 0) {
      if(GroupA.children[0].rotation.y < Math.PI){
          GroupA.children[0].rotation.y += 0.05;
          GroupB.children[0].rotation.y += 0.05;
          GroupC.children[0].rotation.y += 0.05;
          GroupD.children[0].rotation.y += 0.05;
          GroupE.children[0].rotation.y += 0.05;
          GroupF.children[0].rotation.y += 0.05;
      }
      else{
        GroupA.children[0].position.y -= triStep;
        GroupB.children[0].position.z -= triStep;
        GroupC.children[0].position.y += triStep;
        GroupD.children[0].position.z -= triStep;
        GroupE.children[0].position.z -= triStep;
        GroupF.children[0].position.z += triStep;
      }
      if (GroupA.children[0].position.y < -L +L/kk) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(-L/2,-L+L/kk, 0);
        pos2[0] = new THREE.Vector3(-L/2,-L, 0);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        ///////////////////
        pos1[1] = new THREE.Vector3(0,-L, -L/2+L/kk);
        pos2[1] = new THREE.Vector3(0,-L, -L/2);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ///////////////////
        pos1[2] = new THREE.Vector3(-L/2,-L/kk, 0);
        pos2[2] = new THREE.Vector3(-L/2,0, 0);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ///////////////////
        pos1[3] = new THREE.Vector3(0,0, -L/2+L/kk);
        pos2[3] = new THREE.Vector3(0,0, -L/2);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(-L/2,-L/2, -L/2+L/kk);
        pos2[4] = new THREE.Vector3(-L/2,-L/2, -L/2);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(-L/2,-L/2, L/2-L/kk);
        pos2[5] = new THREE.Vector3(-L/2,-L/2, L/2);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
    
      if (GroupA.children[0].position.x > 0){
        
        if(GroupA.children[0].rotation.y < Math.PI/2){
          GroupA.children[0].rotation.y += 0.05;
          GroupB.children[0].rotation.z += 0.05;
          GroupC.children[0].rotation.y -= 0.05;
          GroupD.children[0].rotation.z += 0.05;
          GroupE.children[0].rotation.z += 0.05;
          GroupF.children[0].rotation.z -= 0.05;
        }
        else moving = false;
      }
      else{
        GroupA.children[0].position.x += triStep;
        GroupB.children[0].position.y += triStep;
        GroupC.children[0].position.x += triStep;
        GroupD.children[0].position.y -= triStep;
        GroupE.children[0].position.x += triStep;
        GroupF.children[0].position.x += triStep;
      }
    }
  }
  function DtoE() {
  var triStep = .90;
    if (turning === 0) {
      GroupA.children[0].position.z -= triStep;
      GroupB.children[0].position.x -= triStep;
      GroupC.children[0].position.z += triStep;
      GroupD.children[0].position.x += triStep;
      GroupE.children[0].position.y += triStep;
      GroupF.children[0].position.y -= triStep;
      if (GroupA.children[0].position.z < -L/2) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(-L/2,-L/2, -L/2);
        pos2[0] = new THREE.Vector3(-L/2,-L/2, -L/2);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        ///////////////////
        pos1[1] = new THREE.Vector3(-L/2,-L, 0);
        pos2[1] = new THREE.Vector3(-L/2,-L, 0);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ///////////////////
        pos1[2] = new THREE.Vector3(-L/2,-L/2, L/2);
        pos2[2] = new THREE.Vector3(-L/2,-L/2, L/2);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ///////////////////
        pos1[3] = new THREE.Vector3(L/2,0,0);
        pos2[3] = new THREE.Vector3(L/2,0,0);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(-L/2,0, 0);
        pos2[4] = new THREE.Vector3(-L/2,0, 0);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(-L/2,-L, 0);
        pos2[5] = new THREE.Vector3(-L/2,-L, 0);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
    
      if (GroupA.children[0].position.x > 0){
        
        if(GroupA.children[0].rotation.z > -Math.PI/2){
          GroupA.children[0].rotation.z -= 0.05;
          GroupB.children[0].rotation.y += 0.05;
          GroupC.children[0].rotation.z += 0.05;
          GroupD.children[0].rotation.y += 0.05;
          GroupE.children[0].rotation.y += 0.05;
          GroupF.children[0].rotation.y -= 0.05;
        }
        else moving = false;
      }
      else{
        GroupA.children[0].position.x += triStep;
        GroupB.children[0].position.y += triStep;
        GroupC.children[0].position.x += triStep;
        GroupD.children[0].position.y -= triStep;
        GroupE.children[0].position.x += triStep;
        GroupF.children[0].position.x += triStep;
      }
    }
  }
  function DtoF() {
  var triStep = .90;
    if (turning === 0) {
      if(GroupA.children[0].rotation.y > -Math.PI/2){
        GroupA.children[0].rotation.y -= 0.05;
        GroupB.children[0].rotation.y -= 0.05;
        GroupC.children[0].rotation.y -= 0.05;
        GroupD.children[0].rotation.y -= 0.05;
        GroupE.children[0].rotation.y -= 0.05;
        GroupF.children[0].rotation.y -= 0.05;
      }
      else{
        GroupA.children[0].position.z += triStep;
        GroupB.children[0].position.x += triStep;
        GroupC.children[0].position.z -= triStep;
        GroupD.children[0].position.x -= triStep;
        GroupE.children[0].position.y -= triStep;
        GroupF.children[0].position.y += triStep;
      }
      if (GroupA.children[0].position.z > L/2) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(-L/2,-L/2, L/2);
        pos2[0] = new THREE.Vector3(-L/2,-L/2, L/2);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        ///////////////////
        pos1[1] = new THREE.Vector3(L/2,-L, 0);
        pos2[1] = new THREE.Vector3(L/2,-L, 0);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ///////////////////
        pos1[2] = new THREE.Vector3(-L/2,-L/2, -L/2);
        pos2[2] = new THREE.Vector3(-L/2,-L/2, -L/2);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ///////////////////
        pos1[3] = new THREE.Vector3(-L/2,0,0);
        pos2[3] = new THREE.Vector3(-L/2,0,0);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(-L/2,-L, 0);
        pos2[4] = new THREE.Vector3(-L/2,-L, 0);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(-L/2,0, 0);
        pos2[5] = new THREE.Vector3(-L/2,0, 0);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
    
      if (GroupA.children[0].position.x > 0){
        
        if(GroupA.children[0].rotation.z < Math.PI/2){
          GroupA.children[0].rotation.z += 0.05;
          GroupB.children[0].rotation.y -= 0.05;
          GroupC.children[0].rotation.z -= 0.05;
          GroupD.children[0].rotation.y += 0.05;
          GroupE.children[0].rotation.y -= 0.05;
          GroupF.children[0].rotation.y += 0.05;
        }
        else moving = false;
      }
      else{
        GroupA.children[0].position.x += triStep;
        GroupB.children[0].position.y += triStep;
        GroupC.children[0].position.x += triStep;
        GroupD.children[0].position.y -= triStep;
        GroupE.children[0].position.x += triStep;
        GroupF.children[0].position.x += triStep;
      }
    }
  }

  function EtoA() {
  var triStep = .90;
    if (turning === 0) {
      if(GroupA.children[0].rotation.z <Math.PI/2){
        GroupA.children[0].rotation.z += 0.05;
        GroupB.children[0].rotation.y -= 0.05;
        GroupC.children[0].rotation.z -= 0.05;
        GroupD.children[0].rotation.y -= 0.05;
        GroupE.children[0].rotation.y -= 0.05;
        GroupF.children[0].rotation.y -= 0.05;
      }
      else{
        GroupA.children[0].position.y += triStep;
        GroupB.children[0].position.z += triStep;
        GroupC.children[0].position.y -= triStep;
        GroupD.children[0].position.z += triStep;
        GroupE.children[0].position.z += triStep;
        GroupF.children[0].position.z -= triStep;
      }
      if (GroupA.children[0].position.y > 0) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(0,0, -L/2);
        pos2[0] = new THREE.Vector3(0,0, -L/2);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        ///////////////////
        pos1[1] = new THREE.Vector3(-L/2,-L/2, L/2);
        pos2[1] = new THREE.Vector3(-L/2,-L/2, L/2);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ///////////////////
        pos1[2] = new THREE.Vector3(0,-L, L/2);
        pos2[2] = new THREE.Vector3(0,-L, L/2);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ///////////////////
        pos1[3] = new THREE.Vector3(L/2,-L/2, L/2);
        pos2[3] = new THREE.Vector3(L/2,-L/2, L/2);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(0,0,L/2);
        pos2[4] = new THREE.Vector3(0,0,L/2);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(0,-L, -L/2);
        pos2[5] = new THREE.Vector3(0,-L, -L/2);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
    
      if (GroupA.children[0].position.z > 0){
        
        if(GroupA.children[0].rotation.y < Math.PI/2){
          GroupA.children[0].rotation.y += 0.05;
          GroupB.children[0].rotation.z += 0.05;
          GroupC.children[0].rotation.y += 0.05;
          GroupD.children[0].rotation.z += 0.05;
          GroupE.children[0].rotation.z += 0.05;
          GroupF.children[0].rotation.z -= 0.05;
        }
        else moving = false;
      }
      else{
        GroupA.children[0].position.z += triStep;
        GroupB.children[0].position.x += triStep;
        GroupC.children[0].position.z -= triStep;
        GroupD.children[0].position.x -= triStep;
        GroupE.children[0].position.y -= triStep;
        GroupF.children[0].position.y += triStep;
      }
    }
  }
  function EtoC() {
  var triStep = .90;
    if (turning === 0) {
      GroupA.children[0].position.y -= triStep;
      GroupB.children[0].position.z -= triStep;
      GroupC.children[0].position.y += triStep;
      GroupD.children[0].position.z -= triStep;
      GroupE.children[0].position.z -= triStep;
      GroupF.children[0].position.z += triStep;
      if (GroupA.children[0].position.y < -L) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(0,-L, -L/2);
        pos2[0] = new THREE.Vector3(0,-L, -L/2);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        ///////////////////
        pos1[1] = new THREE.Vector3(-L/2,-L/2, -L/2);
        pos2[1] = new THREE.Vector3(-L/2,-L/2, -L/2);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ///////////////////
        pos1[2] = new THREE.Vector3(0,0, L/2);
        pos2[2] = new THREE.Vector3(0,0, L/2);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ///////////////////
        pos1[3] = new THREE.Vector3(L/2,-L/2, -L/2);
        pos2[3] = new THREE.Vector3(L/2,-L/2, -L/2);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(0,0,-L/2);
        pos2[4] = new THREE.Vector3(0,0,-L/2);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(0,-L, L/2);
        pos2[5] = new THREE.Vector3(0,-L, L/2);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
    
      if (GroupA.children[0].position.z > 0){
        
        if(GroupA.children[0].rotation.y > -Math.PI/2-Math.PI){
          GroupA.children[0].rotation.y -= 0.05;
          GroupB.children[0].rotation.z -= 0.05;
          GroupC.children[0].rotation.y += 0.05;
          GroupD.children[0].rotation.z -= 0.05;
          GroupE.children[0].rotation.z -= 0.05;
          GroupF.children[0].rotation.z += 0.05;
        }
        else moving = false;
      }
      else{
        GroupA.children[0].position.z += triStep;
        GroupB.children[0].position.x += triStep;
        GroupC.children[0].position.z -= triStep;
        GroupD.children[0].position.x -= triStep;
        GroupE.children[0].position.y -= triStep;
        GroupF.children[0].position.y += triStep;
      }
    }
  }
  function EtoB() {
  var triStep = .90;
    if (turning === 0) {
      if(GroupA.children[0].rotation.z < 0){
        GroupA.children[0].rotation.z += 0.05;
        GroupB.children[0].rotation.y -= 0.05;
        GroupC.children[0].rotation.z -= 0.05;
        GroupD.children[0].rotation.y -= 0.05;
        GroupE.children[0].rotation.y -= 0.05;
        GroupF.children[0].rotation.y -= 0.05;
      }
      else{
        GroupA.children[0].position.x += triStep;
        GroupB.children[0].position.y += triStep;
        GroupC.children[0].position.x += triStep;
        GroupD.children[0].position.y -= triStep;
        GroupE.children[0].position.x += triStep;
        GroupF.children[0].position.x += triStep;
      }
      if (GroupA.children[0].position.x > L/2) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(L/2,-L/2, -L/2);
        pos2[0] = new THREE.Vector3(L/2,-L/2, -L/2);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        ///////////////////
        pos1[1] = new THREE.Vector3(-L/2,0, 0);
        pos2[1] = new THREE.Vector3(-L/2,0, 0);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ///////////////////
        pos1[2] = new THREE.Vector3(L/2,-L/2, L/2);
        pos2[2] = new THREE.Vector3(L/2,-L/2, L/2);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ///////////////////
        pos1[3] = new THREE.Vector3(L/2,-L, 0);
        pos2[3] = new THREE.Vector3(L/2,-L, 0);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(L/2,0, 0);
        pos2[4] = new THREE.Vector3(L/2,0, 0);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(L/2,-L, 0);
        pos2[5] = new THREE.Vector3(L/2,-L, 0);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
    
      if (GroupA.children[0].position.z > 0){
        
        if(GroupA.children[0].rotation.y < Math.PI/2){
          GroupA.children[0].rotation.y += 0.05;
          GroupB.children[0].rotation.y += 0.05;
          GroupC.children[0].rotation.y += 0.05;
          GroupD.children[0].rotation.y += 0.05;
          GroupE.children[0].rotation.y += 0.05;
          GroupF.children[0].rotation.y += 0.05;
        }
        else moving = false;
      }
      else{
        GroupA.children[0].position.z += triStep;
        GroupB.children[0].position.x += triStep;
        GroupC.children[0].position.z -= triStep;
        GroupD.children[0].position.x -= triStep;
        GroupE.children[0].position.y -= triStep;
        GroupF.children[0].position.y += triStep;
      }
    }
  }
  function EtoD() {
  var triStep = .90;
    if (turning === 0) {
      if(GroupA.children[0].rotation.z > -Math.PI){
        GroupA.children[0].rotation.z -= 0.05;
        GroupB.children[0].rotation.y += 0.05;
        GroupC.children[0].rotation.z += 0.05;
        GroupD.children[0].rotation.y += 0.05;
        GroupE.children[0].rotation.y += 0.05;
        GroupF.children[0].rotation.y += 0.05;
      }
      else{
        GroupA.children[0].position.x -= triStep;
        GroupB.children[0].position.y -= triStep;
        GroupC.children[0].position.x -= triStep;
        GroupD.children[0].position.y += triStep;
        GroupE.children[0].position.x -= triStep;
        GroupF.children[0].position.x -= triStep;
      }
      if (GroupA.children[0].position.x < -L/2) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(-L/2,-L/2, -L/2);
        pos2[0] = new THREE.Vector3(-L/2,-L/2, -L/2);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        ///////////////////
        pos1[1] = new THREE.Vector3(-L/2,-L, 0);
        pos2[1] = new THREE.Vector3(-L/2,-L, 0);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ///////////////////
        pos1[2] = new THREE.Vector3(-L/2,-L/2, L/2);
        pos2[2] = new THREE.Vector3(-L/2,-L/2, L/2);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ///////////////////
        pos1[3] = new THREE.Vector3(L/2,0, 0);
        pos2[3] = new THREE.Vector3(L/2,0, 0);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(-L/2,0, 0);
        pos2[4] = new THREE.Vector3(-L/2,0, 0);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(-L/2,-L, 0);
        pos2[5] = new THREE.Vector3(-L/2,-L, 0);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
    
      if (GroupA.children[0].position.z > 0){
        
        if(GroupA.children[0].rotation.y < Math.PI/2){
          GroupA.children[0].rotation.y += 0.05;
          GroupB.children[0].rotation.y += 0.05;
          GroupC.children[0].rotation.y += 0.05;
          GroupD.children[0].rotation.y += 0.05;
          GroupE.children[0].rotation.y += 0.05;
          GroupF.children[0].rotation.y += 0.05;
        }
        else moving = false;
      }
      else{
        GroupA.children[0].position.z += triStep;
        GroupB.children[0].position.x += triStep;
        GroupC.children[0].position.z -= triStep;
        GroupD.children[0].position.x -= triStep;
        GroupE.children[0].position.y -= triStep;
        GroupF.children[0].position.y += triStep;
      }
    }
  }

  function FtoA() {
  var triStep = .90;
    if (turning === 0) {
      GroupA.children[0].position.y += triStep;
      GroupB.children[0].position.z += triStep;
      GroupC.children[0].position.y -= triStep;
      GroupD.children[0].position.z += triStep;
      GroupE.children[0].position.z += triStep;
      GroupF.children[0].position.z -= triStep;
      if (GroupA.children[0].position.y > 0) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(0,0, L/2);
        pos2[0] = new THREE.Vector3(0,0, L/2);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        ///////////////////
        pos1[1] = new THREE.Vector3(L/2,-L/2, L/2);
        pos2[1] = new THREE.Vector3(L/2,-L/2, L/2);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ///////////////////
        pos1[2] = new THREE.Vector3(0,-L,-L/2);
        pos2[2] = new THREE.Vector3(0,-L,-L/2);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ///////////////////
        pos1[3] = new THREE.Vector3(-L/2,-L/2, L/2);
        pos2[3] = new THREE.Vector3(-L/2,-L/2, L/2);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(0,-L, L/2);
        pos2[4] = new THREE.Vector3(0,-L, L/2);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(0,0, -L/2);
        pos2[5] = new THREE.Vector3(0,0, -L/2);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
      GroupA.children[0].position.z -= triStep;
      GroupB.children[0].position.x -= triStep;
      GroupC.children[0].position.z += triStep;
      GroupD.children[0].position.x += triStep;
      GroupE.children[0].position.y += triStep;
      GroupF.children[0].position.y -= triStep;
      
      if (GroupA.children[0].position.z < 0){
        moving = false;
      }
    }
  }
  function FtoC() {
  var triStep = .90;
    if (turning === 0) {
      if(GroupA.children[0].rotation.z <Math.PI+Math.PI/2){
        GroupA.children[0].rotation.z += 0.05;
        GroupB.children[0].rotation.y += 0.05;
        GroupC.children[0].rotation.z -= 0.05;
        GroupD.children[0].rotation.y += 0.05;
        GroupE.children[0].rotation.y += 0.05;
        GroupF.children[0].rotation.y += 0.05;
      }
      else{
        GroupA.children[0].position.y -= triStep;
        GroupB.children[0].position.z -= triStep;
        GroupC.children[0].position.y += triStep;
        GroupD.children[0].position.z -= triStep;
        GroupE.children[0].position.z -= triStep;
        GroupF.children[0].position.z += triStep;
      }
      if (GroupA.children[0].position.y < -L) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(0,-L, L/2);
        pos2[0] = new THREE.Vector3(0,-L, L/2);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        ///////////////////
        pos1[1] = new THREE.Vector3(L/2,-L/2, -L/2);
        pos2[1] = new THREE.Vector3(L/2,-L/2, -L/2);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ///////////////////
        pos1[2] = new THREE.Vector3(0,0,-L/2);
        pos2[2] = new THREE.Vector3(0,0,-L/2);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ///////////////////
        pos1[3] = new THREE.Vector3(-L/2,-L/2, -L/2);
        pos2[3] = new THREE.Vector3(-L/2,-L/2, -L/2);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(0,-L, -L/2);
        pos2[4] = new THREE.Vector3(0,-L, -L/2);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(0,0, L/2);
        pos2[5] = new THREE.Vector3(0,0, L/2);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
      GroupA.children[0].position.z -= triStep;
      GroupB.children[0].position.x -= triStep;
      GroupC.children[0].position.z += triStep;
      GroupD.children[0].position.x += triStep;
      GroupE.children[0].position.y += triStep;
      GroupF.children[0].position.y -= triStep;
      
      if (GroupA.children[0].position.z < 0){
        moving = false;
      }
    }
  }
  function FtoB() {
  var triStep = .90;
    if (turning === 0) {
      if(GroupA.children[0].rotation.z >0){
        GroupA.children[0].rotation.z -= 0.05;
        GroupB.children[0].rotation.y -= 0.05;
        GroupC.children[0].rotation.z += 0.05;
        GroupD.children[0].rotation.y -= 0.05;
        GroupE.children[0].rotation.y -= 0.05;
        GroupF.children[0].rotation.y -= 0.05;
      }
      else{
        GroupA.children[0].position.x += triStep;
        GroupB.children[0].position.y += triStep;
        GroupC.children[0].position.x += triStep;
        GroupD.children[0].position.y -= triStep;
        GroupE.children[0].position.x += triStep;
        GroupF.children[0].position.x += triStep;
      }
      if (GroupA.children[0].position.x > L/2) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(L/2,-L/2, L/2);
        pos2[0] = new THREE.Vector3(L/2,-L/2, L/2);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        ///////////////////
        pos1[1] = new THREE.Vector3(L/2,0,0);
        pos2[1] = new THREE.Vector3(L/2,0,0);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ///////////////////
        pos1[2] = new THREE.Vector3(L/2,-L/2, -L/2);
        pos2[2] = new THREE.Vector3(L/2,-L/2, -L/2);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ///////////////////
        pos1[3] = new THREE.Vector3(-L/2,-L, 0);
        pos2[3] = new THREE.Vector3(-L/2,-L, 0);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(L/2,-L, 0);
        pos2[4] = new THREE.Vector3(L/2,-L, 0);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(L/2,0, 0);
        pos2[5] = new THREE.Vector3(L/2,0, 0);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
      GroupA.children[0].position.z -= triStep;
      GroupB.children[0].position.x -= triStep;
      GroupC.children[0].position.z += triStep;
      GroupD.children[0].position.x += triStep;
      GroupE.children[0].position.y += triStep;
      GroupF.children[0].position.y -= triStep;
      
      if (GroupA.children[0].position.z < 0){
        moving = false;
      }
    }
  }
  function FtoD() {
  var triStep = .90;
    if (turning === 0) {
      if(GroupA.children[0].rotation.z <Math.PI){
        GroupA.children[0].rotation.z += 0.05;
        GroupB.children[0].rotation.y += 0.05;
        GroupC.children[0].rotation.z -= 0.05;
        GroupD.children[0].rotation.y += 0.05;
        GroupE.children[0].rotation.y += 0.05;
        GroupF.children[0].rotation.y += 0.05;
      }
      else{
        GroupA.children[0].position.x -= triStep;
        GroupB.children[0].position.y -= triStep;
        GroupC.children[0].position.x -= triStep;
        GroupD.children[0].position.y += triStep;
        GroupE.children[0].position.x -= triStep;
        GroupF.children[0].position.x -= triStep;
      }
      if (GroupA.children[0].position.x < -L/2) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(-L/2,-L/2, L/2);
        pos2[0] = new THREE.Vector3(-L/2,-L/2, L/2);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        ///////////////////
        pos1[1] = new THREE.Vector3(L/2,-L,0);
        pos2[1] = new THREE.Vector3(L/2,-L,0);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ///////////////////
        pos1[2] = new THREE.Vector3(-L/2,-L/2, -L/2);
        pos2[2] = new THREE.Vector3(-L/2,-L/2, -L/2);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ///////////////////
        pos1[3] = new THREE.Vector3(-L/2,0, 0);
        pos2[3] = new THREE.Vector3(-L/2,0, 0);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(-L/2,-L, 0);
        pos2[4] = new THREE.Vector3(-L/2,-L, 0);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(-L/2,0, 0);
        pos2[5] = new THREE.Vector3(-L/2,0, 0);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
      GroupA.children[0].position.z -= triStep;
      GroupB.children[0].position.x -= triStep;
      GroupC.children[0].position.z += triStep;
      GroupD.children[0].position.x += triStep;
      GroupE.children[0].position.y += triStep;
      GroupF.children[0].position.y -= triStep;
      
      if (GroupA.children[0].position.z < 0){
        moving = false;
      }
    }
  }  
function Cross(Group,pos1,pos2,quat1,quat2,alpha){
    alpha += 0.01;
      
    var qm = quat1.clone().slerp(quat2, alpha);
    Group.children[2].matrix.makeRotationFromQuaternion (qm);
    
    var pp = pos1.clone().lerp(pos2, alpha);
    Group.children[2].matrix.setPosition(pp);
    Group.children[2].matrixAutoUpdate = false;
    
    if (alpha > 1.0) {
      turning = 2; // done turning
      
      Group.children[2].position.setFromMatrixPosition (Group.children[0].matrixWorld);
      Group.children[2].quaternion.setFromRotationMatrix (Group.children[0].matrixWorld); 
      
      Group.children[2].matrixAutoUpdate = true;
    }
    return alpha;
  }
</script></body>
