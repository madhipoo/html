<!DOCTYPE html>
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<!-- three.js library -->
<!--script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.min.js"></script-->
<script src='../examples/vendor/three.js/build/three.min.js'></script>
<script src="../examples/vendor/three.js/examples/js/libs/stats.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5/dat.gui.min.js"></script>
<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<!-- jsartookit -->
<script src="../vendor/jsartoolkit5/build/artoolkit.min.js"></script>
<script src="../vendor/jsartoolkit5/js/artoolkit.api.js"></script>
<!-- include threex.artoolkit -->
<script src="../src/threex/threex-artoolkitsource.js"></script>
<script src="../src/threex/threex-artoolkitcontext.js"></script>
<script src="../src/threex/threex-arbasecontrols.js"></script>
<script src="../src/threex/threex-armarkercontrols.js"></script>

<script>THREEx.ArToolkitContext.baseURL = '../'</script>

<body style='margin : 0px; overflow: hidden; font-family: Monospace;'>
<div style='font-size:2em;position: absolute; top: 10px; width:100%; text-align: center; z-index: 1;'>
	<a href="https://github.com/jeromeetienne/AR.js/" target="_blank">AR.js</a>
	<br/>
	<p id='printDis'></p>
	<p id='touch'></p>
	<p id='ratio'></p>
</div>
<script type="x-shader/x-fragment" id="fragmentShaderDepth">
	uniform sampler2D texture;
	varying vec2 vUv;

	vec4 pack_depth(const in float depth) {
		const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);
		const vec4 bit_mask = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);
		vec4 res = fract(depth * bit_shift);
		res -= res.xxyz * bit_mask;
		return res;
	}

	void main() {
		vec4 pixel = texture2D(texture, vUv);
		if (pixel.a < 0.5) discard;
		gl_FragData[0] = pack_depth (gl_FragCoord.z);
	}
</script>
<script type="x-shader/x-vertex" id="vertexShaderDepth">
	varying vec2 vUv;

	void main() {
		vUv = uv;
		gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
	}
</script>
<script>
class Button {
	constructor (size, x, y){
		this.size = size;
		this.centerX = x;
		this.centerY = y;
	}
	d1To (v) { // 1-norm
		return Math.abs (v[0]-this.centerX) + Math.abs(v[1]-this.centerY);
	}
	d2To (v) { // 2-norm
		return Math.sqrt ( (v[0]-this.centerX)*(v[0]-this.centerX) 
				+ (v[1]-this.centerY)*(v[1]-this.centerY) );
	}
	dInfTo (v) { // inf-norm
		return Math.max( Math.abs (v[0]-this.centerX), Math.abs(v[1]-this.centerY) )
	}
}
// global variables
var renderer,stats;
var scene, camera,sceneHUD, cameraHUD;
var markerA, markerB,markerC;
var men = [],car = [];
var GroupA,GroupB;
var arToolKitSource, arToolKitContext;
var button,time = 0,flag = 0;
var k = 0.05,angle=0;
var opc = 0.5;
//var head,leftarm, torso, leftleg, rightarm ,rightleg;
var gcontrol;
//var raycaster, pickables;
var manPos = new THREE.Vector3(),pos;
var whRatio, halfW, halfH;
var button1,cubeSpin = false;
var _iOSDevice;
//var onRenderFcts= [];
//var debugEnabled = false
var Drumpose1 = {
        Dtheta1: 1.2057796021989051,
        Dtheta2: 0,
        Dtheta3: 1.5,
        Dtheta4: 1,
        Dtheta5: -0.09110458090435114,
        Dtheta6: 0,
        Dtheta7: 0.24562074316608218,
        Dtheta8: -0.3575635264445681,
        Dtheta9: -0.33541054459782915,
        Dtheta10: -0.025268798743482757
	}
var Drumpose2 = {
        Dtheta1: 1.5,
        Dtheta2: 1,
        Dtheta3: 1.5,
        Dtheta4: 1,
        Dtheta5: 0.15700881577912607,
        Dtheta6: -0.268951599057612,
        Dtheta7: 0.2987878995982558,
        Dtheta8: -0.2911045809043511,
        Dtheta9: -0.24679861721087304,
        Dtheta10: -0.06957476243696081
}
var Drumpose3 = {
        Dtheta1: 1.5,
        Dtheta2: 1,
        Dtheta3: 1.09501469296521,
        Dtheta4: 0,
        Dtheta5: 0.2987878995982558,
        Dtheta6: -0.3686400173679377,
        Dtheta7: -0.10882696638174227,
        Dtheta8: 0,
        Dtheta9: 0.48424978373151495,
        Dtheta10: 0.08549611049021233
}
var Drumpose4 = {
        Dtheta1: 1.5,
        Dtheta2: 1,
        Dtheta3: 1.5,
        Dtheta4: 1,
        Dtheta5: 0.1747312012565173,
        Dtheta6: -0.2911045809043511,
        Dtheta7: -0.09110458090435114,
        Dtheta8: 0,
        Dtheta9: 0.2184140015706466,
        Dtheta10: 0.17410803787716844
}

var Cymbalpose1 = {
        Ctheta1: 0.7,
        Ctheta2: 1,
        Ctheta3: 0.7,
        Ctheta4: 1,
        Ctheta5: 0,
        Ctheta6: 0,
        Ctheta7: 0,
        Ctheta8: 0,
        Ctheta9: 0,
        Ctheta10: 0,
        Ctheta11: 0.7500855658923833,
        Ctheta12:  -0.7500855658923833,
	}
var Cymbalpose2 = {
        Ctheta1: 0.7,
        Ctheta2: 1,
        Ctheta3: 0.7,
        Ctheta4: 1,
        Ctheta5: 0,
        Ctheta6: 0,
        Ctheta7: 0,
        Ctheta8: 0,
        Ctheta9: 0,
        Ctheta10: 0,
				Ctheta11: 0.37348487449781986,
        Ctheta12: -0.33541054459782915
}
var Cymbalpose3 = {
        Ctheta1: 0.7,
        Ctheta2: 1,
        Ctheta3: 0.7,
        Ctheta4: 1,
        Ctheta5: 0,
        Ctheta6: 0,
        Ctheta7: 0,
        Ctheta8: 0,
        Ctheta9: 0,
        Ctheta10: 0,
        Ctheta11: 0,
        Ctheta12: 0
}
var Cymbalpose4 = {
        Ctheta1: 0.7,
        Ctheta2: 1,
        Ctheta3: 0.7,
        Ctheta4: 1,
        Ctheta5: 0,
        Ctheta6: 0,
        Ctheta7: 0,
        Ctheta8: 0,
        Ctheta9: 0,
        Ctheta10: 0,
        Ctheta11:  0.24056698341738558,
        Ctheta12: -0.268951599057612
}


var Drumkeys = [
  [0, Drumpose4],
  [0.250, Drumpose1],
  [0.500, Drumpose2],
  [0.750, Drumpose3],
  [1, Drumpose4]
];
var Cymbalkeys = [
  [0, Cymbalpose4],
  [0.250, Cymbalpose1],
  [0.500, Cymbalpose2],
  [0.750, Cymbalpose3],
  [1, Cymbalpose4]
];

var T = 240/87;
var clock = new THREE.Clock();
var ts = clock.getElapsedTime(),tss = clock.getElapsedTime();  // start time
var intKey1 = [], intKey2 = [];
var soundTrack;
var isDimming = false, soundVal = 1.0, sign = 1.0;
////////////////////////
init();
animate();

function init() {
	let _iOSDevice = !!navigator.platform.match(/iPhone|iPod|iPad/);
	console.log ('iOS: ' + _iOSDevice)

	renderer	= new THREE.WebGLRenderer({
		// antialias	: true,
		alpha: true
	});
	renderer.setClearColor(new THREE.Color('lightgrey'), 0)
	// renderer.setPixelRatio( 1/2 );
	renderer.setSize( window.innerWidth, window.innerHeight );
	renderer.domElement.style.position = 'absolute'
	renderer.domElement.style.top = '0px'
	renderer.domElement.style.left = '0px'
	document.body.appendChild( renderer.domElement );

	whRatio = window.innerWidth/window.innerHeight;
	renderer.autoClear = false;
	// init scene and camera
	scene	= new THREE.Scene();
	// Create a camera
	camera = new THREE.Camera();
	scene.add(camera);
	sceneHUD = new THREE.Scene();
	// eye-coordinate bounds
	halfH = 10;
	halfW = halfH * whRatio;
	cameraHUD = new THREE.OrthographicCamera (-halfW,halfW, halfH,-halfH, -10,10);

	var buttonSize = halfH/3;
	button = new THREE.Mesh (new THREE.PlaneGeometry(buttonSize, buttonSize), 
			new THREE.MeshBasicMaterial({color:"yellow", transparent:true, opacity:0.8}));	
	button1 = new Button (buttonSize, 0, -halfH/2);
	button.position.set (button1.centerX, button1.centerY, 0);
	sceneHUD.add (button);
	arToolkitSource = new THREEx.ArToolkitSource({
		// to read from the webcam 
		sourceType : 'webcam',

	})

	arToolkitSource.init(function onReady(){
		onResize()
	})
	
	// handle resize

	arToolkitContext = new THREEx.ArToolkitContext({
		cameraParametersUrl: THREEx.ArToolkitContext.baseURL + '../data/data/camera_para.dat',
		detectionMode: 'mono',
		maxDetectionRate: 30,
		canvasWidth: 80*3,
		canvasHeight: 60*3,
	})
	// initialize it
	arToolkitContext.init(function onCompleted(){
		// copy projection matrix to camera
		camera.projectionMatrix.copy( arToolkitContext.getProjectionMatrix() );
	})
	renderer.shadowMap.type = THREE.PCFSoftShadowMap
    renderer.shadowMap.enabled = true;

	markerA = new THREE.Group();
	var markerControlsA = new THREEx.ArMarkerControls(arToolkitContext, markerA, {
		type : 'pattern',
		patternUrl : THREEx.ArToolkitContext.baseURL + '../data/data/patt.Aletter',
	})
	scene.add (markerA);
	GroupA = new THREE.Group();
	markerA.add(GroupA);

	let inA = addMarkerA();
	GroupA.add(inA[0],inA[1])
    men[0] = buildWalkMan();
    men[1] = buildDrumMan();
	let drum = buildDrum();
  drum.rotation.y = Math.PI/2;
	GroupA.add(drum);

  car[0] = buildcar();
  men[0][0].position.set(0,0.1,0);
  car[0].add(men[0][0]);
  car[0].rotation.y = Math.PI/2;
  GroupA.add(car[0]);
  car[1] = buildcar();
  men[1][0].position.set(0,0.1,0);
  car[1].add(men[1][0]);
  car[1].rotation.y = Math.PI/2;
  GroupA.add(car[1]);
	markerB = new THREE.Group();
	var markerControlsB = new THREEx.ArMarkerControls(arToolkitContext, markerB, {
		type : 'pattern',
		patternUrl : THREEx.ArToolkitContext.baseURL + '../data/data/patt.Bletter',
	})
	scene.add (markerB);
	GroupB = new THREE.Group();
	markerB.add(GroupB);

	let inB = addMarkerB();
	GroupB.add(inB[0],inB[1])
  men[2] = buildCymbalMan();
  car[2] = buildcar();
  men[2][0].position.set(0,0.1,0);
  car[2].add(men[2][0]);
  car[2].rotation.y = -Math.PI/2;
  GroupB.add(car[2]);
	markerC = new THREE.Group();
	var markerControlsB = new THREEx.ArMarkerControls(arToolkitContext, markerC, {
		type : 'pattern',
		patternUrl : THREEx.ArToolkitContext.baseURL + '../data/data/patt.Cletter',
	})
	scene.add (markerC);
	GroupC = new THREE.Group();
	markerC.add(GroupC);

    let inC = addMarkerC();
	GroupC.add(inC[0],inC[1])
	
	/////////////////////
	/*var gui1 = new dat.GUI({load:DrumJSON(), preset:'key1'});
	gui1.domElement.id = 'gui';
	var gui2 = new dat.GUI({load:CymbalJSON(), preset:'key1'});
	gui2.domElement.id = 'gui';*/
  ///////////////////////////////////////

	var ambient = new THREE.AmbientLight( 0x666666 );
	scene.add(ambient)

	let light = new THREE.PointLight( 0xffffff, 1, 1000 );
	light.position.set(1.5,3,1.5 ); // default; light shining from top
	light.castShadow = true;
	scene.add(light)

	stats = new Stats();
	document.body.appendChild( stats.dom );

	window.addEventListener('resize', function(){
		onResize()
	})
	if (_iOSDevice)
    	window.addEventListener('touchstart', onTouchStart, false);
	else
		window.addEventListener ('mousedown', onMouseDown, false);
}
function onResize(){
		arToolkitSource.onResize()	
		arToolkitSource.copySizeTo(renderer.domElement)	
		if( arToolkitContext.arController !== null ){
			arToolkitSource.copySizeTo(arToolkitContext.arController.canvas)	
		}
		$('#ratio').text ('resize: width: ' + window.innerWidth + ' height: ' + window.innerHeight)
		whRatio = window.innerWidth/window.innerHeight;
		halfW = halfH * whRatio;
		cameraHUD.left = -halfW;
		cameraHUD.right = halfW;
		cameraHUD.top = halfH;
		cameraHUD.bottom = -halfH;
	}	
function buildDrumMan(){
  mine = new THREE.Group();
	//GroupA.add(mine);
	head = makeHead();
	torso = makeTorso();
	mine.add(torso);
	head.position.y = 7.57*k-4.09*k;
	torso.position.y = 4.09*k;
	torso.add(head);

	leftarm = makeArm();
  let geometry = new THREE.CylinderBufferGeometry(0.01, 0.01, 0.1, 32 );
  let material = new THREE.MeshLambertMaterial( {color: 0x803d0a} );
  stick1= new THREE.Mesh( geometry, material );
	leftarm[0].position.set (-1.88*k, 7.57*k-4.09*k, 0);
	leftarm[0].add(leftarm[1]);
	leftarm[1].add(stick1);
	torso.add (leftarm[0]);
  stick1.position.set(2*k,0,-0.05);
  stick1.rotation.x=Math.PI/2;
  stick1.castShadow = true;
  stick1.receiveShadow = true;

	rightarm = makeArm();
  geometry = new THREE.CylinderBufferGeometry(0.01, 0.01, 0.1, 32 );
  material = new THREE.MeshLambertMaterial( {color: 0x803d0a} );
  stick2= new THREE.Mesh( geometry, material );
	rightarm[0].position.set (1.88*k, 7.57*k-4.09*k, 0);
	rightarm[0].add(rightarm[1]);
	rightarm[1].add(stick2);
	torso.add(rightarm[0]);
  stick2.position.set(2*k,0,-0.05);
  stick2.rotation.x=Math.PI/2;
  stick2.castShadow = true;
  stick2.receiveShadow = true;

	leftleg = makeLeg();
	leftleg[0].position.set  (-0.63*k, 4.09*k-4.09*k, 0);
	leftleg[0].add(leftleg[1]);
	torso.add(leftleg[0]);


	rightleg = makeLeg();
	rightleg[0].position.set (0.63*k, 4.09*k-4.09*k, 0);
	rightleg[0].add(rightleg[1]);
	torso.add(rightleg[0]);

	mine.rotation.y=-Math.PI/2;	
	mine.position.y=0.01;
	leftarm[0].rotation.z = -Math.PI/2;
	rightarm[0].rotation.z = -Math.PI/2;
	leftleg[0].rotation.z = -Math.PI/2;
	rightleg[0].rotation.z = -Math.PI/2;
	
	leftarm[0].rotation.order = 'ZYX';
	rightarm[0].rotation.order = 'ZYX';
	leftleg[0].rotation.order = 'ZYX';
	rightleg[0].rotation.order = 'ZYX';
  return [mine,head,torso,leftarm[0],leftarm[1],rightarm[0],rightarm[1],leftleg[0],leftleg[1],rightleg[0],rightleg[1]];
}
function buildCymbalMan(){
    mine = new THREE.Group();
	//GroupA.add(mine);
	head = makeHead();
	torso = makeTorso();
	mine.add(torso);
	head.position.y = 7.57*k-4.09*k;
	torso.position.y = 4.09*k;
	torso.add(head);

	leftarm = makeArm();
    let geometry = new THREE.CylinderBufferGeometry(0.1, 0.1, 0.01, 32 );
    let material = new THREE.MeshLambertMaterial( {color: 0xdbbf4d} );
    cymbal1= new THREE.Mesh( geometry, material );
	leftarm[0].position.set (-1.88*k, 7.57*k-4.09*k, 0);
	leftarm[0].add(leftarm[1]);
	leftarm[1].add(cymbal1);
	torso.add (leftarm[0]);
    cymbal1.position.set(2*k,0.03,0);
    cymbal1.rotation.z=-Math.PI/4;
    cymbal1.castShadow = true;
    cymbal1.receiveShadow = true;

	rightarm = makeArm();
    geometry = new THREE.CylinderBufferGeometry(0.1, 0.1, 0.01, 32 );
    material = new THREE.MeshLambertMaterial( {color: 0xdbbf4d} );
    cymbal2= new THREE.Mesh( geometry, material );
	rightarm[0].position.set (1.88*k, 7.57*k-4.09*k, 0);
	rightarm[0].add(rightarm[1]);
	rightarm[1].add(cymbal2);
	torso.add(rightarm[0]);
    cymbal2.position.set(2*k,-0.03,0);
    cymbal2.rotation.z=Math.PI/5;
    cymbal2.castShadow = true;
    cymbal2.receiveShadow = true;

	leftleg = makeLeg();
	leftleg[0].position.set  (-0.63*k, 4.09*k-4.09*k, 0);
	leftleg[0].add(leftleg[1]);
	torso.add(leftleg[0]);

	rightleg = makeLeg();
	rightleg[0].position.set (0.63*k, 4.09*k-4.09*k, 0);
	rightleg[0].add(rightleg[1]);
	torso.add(rightleg[0]);

	mine.rotation.y=-Math.PI/2;	
	mine.position.y=0.01;
	leftarm[0].rotation.z = -Math.PI/2;
	rightarm[0].rotation.z = -Math.PI/2;
	leftleg[0].rotation.z = -Math.PI/2;
	rightleg[0].rotation.z = -Math.PI/2;
	
	leftarm[0].rotation.order = 'ZYX';
	rightarm[0].rotation.order = 'ZYX';
	leftleg[0].rotation.order = 'ZYX';
	rightleg[0].rotation.order = 'ZYX';
  return [mine,head,torso,leftarm[0],leftarm[1],rightarm[0],rightarm[1],leftleg[0],leftleg[1],rightleg[0],rightleg[1]];
}
function buildWalkMan(){
    mine = new THREE.Group();
	//GroupA.add(mine);
	head = makeHead();
	torso = makeTorso();
	mine.add(torso);
	head.position.y = 7.57*k-4.09*k;
	torso.position.y = 4.09*k;
	torso.add(head);

	leftarm = makeArm();
	leftarm[0].position.set (-1.88*k, 7.57*k-4.09*k, 0);
	leftarm[0].add(leftarm[1]);
	torso.add (leftarm[0]);

	rightarm = makeArm();
	rightarm[0].position.set (1.88*k, 7.57*k-4.09*k, 0);
	rightarm[0].add(rightarm[1]);
	torso.add(rightarm[0]);

	leftleg = makeLeg();
	leftleg[0].position.set  (-0.63*k, 4.09*k-4.09*k, 0);
	leftleg[0].add(leftleg[1]);
	torso.add(leftleg[0]);

	rightleg = makeLeg();
	rightleg[0].position.set (0.63*k, 4.09*k-4.09*k, 0);
	rightleg[0].add(rightleg[1]);
	torso.add(rightleg[0]);

	mine.rotation.y=-Math.PI/2;	
	mine.position.y=0.01;
	leftarm[0].rotation.z = -Math.PI/2;
	rightarm[0].rotation.z = -Math.PI/2;
	leftleg[0].rotation.z = -Math.PI/2;
	rightleg[0].rotation.z = -Math.PI/2;
	
	leftarm[0].rotation.order = 'ZYX';
	rightarm[0].rotation.order = 'ZYX';
	leftleg[0].rotation.order = 'ZYX';
	rightleg[0].rotation.order = 'ZYX';
  return [mine,head,torso,leftarm[0],leftarm[1],rightarm[0],rightarm[1],leftleg[0],leftleg[1],rightleg[0],rightleg[1]];
}
function addMarkerB () {
	let planematerial = new THREE.MeshLambertMaterial({color:0xffffff, side:THREE.DoubleSide});
	planematerial.opacity = 0.6; 
	let planegeometry = new THREE.PlaneGeometry(1, 1)
	let planeMesh = new THREE.Mesh( planegeometry, planematerial);
	planeMesh.receiveShadow = true;
	planeMesh.depthWrite = false;
	planeMesh.rotation.x = -Math.PI/2
	/// add gridhelper
    let geometry = new THREE.CircleBufferGeometry( 0.01, 32 );
	let material = new THREE.MeshBasicMaterial( { color: 'red',side:THREE.DoubleSide});
	circle = new THREE.Mesh( geometry, material );
	circle.rotation.x=-Math.PI/2;
	circle.position.y=0.01;
	var gridXZ = new THREE.GridHelper(1,10);
	//markerRootKanji.add (gridXZ);
	return [planeMesh,circle];
}
function addMarkerA(){
	let planematerial = new THREE.MeshLambertMaterial({color:0xffffff, side:THREE.DoubleSide});
	planematerial.opacity = 0.6; 
	let planegeometry = new THREE.PlaneGeometry(1, 1)
	let planeMesh = new THREE.Mesh( planegeometry, planematerial);
	planeMesh.receiveShadow = true;
	planeMesh.depthWrite = false;
	planeMesh.rotation.x = -Math.PI/2
    let geometry = new THREE.CircleBufferGeometry( 0.01, 32 );
	let material = new THREE.MeshBasicMaterial( { color: 'red',side:THREE.DoubleSide});
	circle = new THREE.Mesh( geometry, material );
	circle.rotation.x=-Math.PI/2;
	circle.position.y=0.01;
	return [planeMesh,circle];
}	
function addMarkerC(){
	let planematerial = new THREE.MeshLambertMaterial({color:0xffffff, side:THREE.DoubleSide});
	planematerial.opacity = 0.6; 
	let planegeometry = new THREE.PlaneGeometry(1, 1)
	let planeMesh = new THREE.Mesh( planegeometry, planematerial);
	planeMesh.receiveShadow = true;
	planeMesh.depthWrite = false;
	planeMesh.rotation.x = -Math.PI/2
    let geometry = new THREE.CircleBufferGeometry( 0.01, 32 );
	let material = new THREE.MeshBasicMaterial( { color: 'red',side:THREE.DoubleSide});
	circle = new THREE.Mesh( geometry, material );
	circle.rotation.x=-Math.PI/2;
	circle.position.y=0.01;
	return [planeMesh,circle];
}	
function update() {
   // o1, x1, z1
   let o1 = markerA.position.clone();
   let x1 = markerA.localToWorld (new THREE.Vector3(1,0,0)).sub(o1);
   let z1 = markerA.localToWorld (new THREE.Vector3(0,0,1)).sub(o1);
   let Az = markerA.localToWorld (new THREE.Vector3(0,0,-1)).sub(o1);
   // o2, x2, z2
   let o2 = markerB.position.clone();
   let x2 = markerB.localToWorld (new THREE.Vector3(1,0,0)).sub(o2);
   let z2 = markerB.localToWorld (new THREE.Vector3(0,0,1)).sub(o2);
   let Bz = markerB.localToWorld (new THREE.Vector3(0,0,-1)).sub(o2);
    /*if(time>=0&&flag){
      time -=0.005
      if(time<0)
        flag = 0;
    }*/ 

    let manPosEye = markerA.localToWorld (manPos.clone());
    let manPos2 = manPosEye.sub (o2);
    let s = manPos2.sub(manPos);
    if(time==0){
      a = Az.clone().angleTo(s);
      while(a>0){
        GroupA.children[3].rotation.y += 0.0002;
        a-=0.0002;
      }
    }
    if(time<=1){
      time +=0.005
    }
    let p = manPos.clone().multiplyScalar(1-time).add(manPos2.clone().multiplyScalar(time));
    //let p = s.clone().multiplyScalar(time);
    //let pos = s.sub(p)
    //console.log(a);
    GroupA.children[3].position.x = -p.x;  
    GroupA.children[3].position.y = 0; 
    GroupA.children[3].position.z = -p.z; 
    if(time==1){
      b = s.clone().angleTo(Bz);
      while(b>0){
        GroupA.children[3].rotation.y -= 0.0002;
        //GroupB.children[].rotation.y += 0.0002;
        //GroupA.children[3].rotation.y += 0.0002;
        b-=0.0002;
      }
    }
    //console.log(GroupA.children[3].position);

}
function pickCompute (ndcX, ndcY) {
	// use 2D algorithm 	
	let dist = button1.dInfTo ([halfW * ndcX, halfH * ndcY]);	
	$('#touch').text ('Mouse-dist-Button: ' + dist.toFixed(2))

	if (dist < button1.size/2) {
		console.log ('picked')
		cubeSpin = !cubeSpin;
	} else {
		console.log ('no hit')
	}
}

function onMouseDown (event) {
	console.log ('in mouse down')
	event.preventDefault();
	let ndcX = (event.clientX / window.innerWidth) * 2 - 1;
	let ndcY = -(event.clientY / window.innerHeight) * 2 + 1;

	pickCompute (ndcX, ndcY);		
}	

function onTouchStart (event) {
	console.log ('in touch start')

	if (event.touches.length == 1) {
		
		event.preventDefault();
		let ndcX = ( event.touches[0].pageX / window.innerWidth ) * 2 - 1;
		let ndcY = - ( event.touches[0].pageY / window.innerHeight ) * 2 + 1;

		pickCompute (ndcX, ndcY);		
		
	}	
}	
function makeArm() {
	var group = new THREE.Group();
 	var group2 = new THREE.Group();
  var material = new THREE.MeshLambertMaterial( { color:0xd0d0c,side:THREE.DoubleSide } );
  uparm = new THREE.Mesh (new THREE.BoxGeometry(1.91*k, 1.20*k, 1.20*k), material); 
  var material = new THREE.MeshLambertMaterial( { color:'white'} );
  dowmarm = new THREE.Mesh (new THREE.BoxGeometry(1.91*k, 1.10*k, 1.10*k), material);
  let armtexture=buildarm();
  armtexture.rotation.z=Math.PI/2;
  armtexture.position.x = 1.91*k/2;
  group2.add(dowmarm,armtexture);
  group.add (uparm,group2);
  uparm.position.x = 1.91*k/2;
  dowmarm.position.x = 1.91*k/2;
  group2.position.x =2*k;
  uparm.castShadow = true;
  uparm.receiveShadow = true;
  dowmarm.castShadow = true;
  dowmarm.receiveShadow = true;
  //group.add (new THREE.AxesHelper (k));
  //group2.add (new THREE.AxesHelper (k));
	return [group,group2];
}

function makeLeg() {
	var group = new THREE.Group();
	var group2 = new THREE.Group();
	var material = new THREE.MeshLambertMaterial( { color:0xd0d0c,side:THREE.DoubleSide } );
	upleg = new THREE.Mesh (new THREE.BoxGeometry(2.045*k,  1.26*k, 1.26*k), material);
	downleg = new THREE.Mesh (new THREE.BoxGeometry(2.045*k, 1.26*k, 1.26*k), material);
	group2.add(downleg);
		group.add (upleg,group2);
	upleg.position.x = 2.045*k/2;
	downleg.position.x =2.045*k/2;
	group2.position.x =2.045*k;
	upleg.castShadow = true;
	upleg.receiveShadow = true;
	downleg.castShadow = true;
	downleg.receiveShadow = true;
	//group.add (new THREE.AxesHelper (k));
	//group2.add (new THREE.AxesHelper (k));
		return [group,group2];
}

function makeHead() {
	var headGroup = new THREE.Group();
  var mat = new THREE.MeshLambertMaterial({color:0x99d8ea});
  headBody = new THREE.Mesh (new THREE.BoxGeometry(2.52*k, 2.52*k, 2.52*k), mat);
  headBody2=buildface();
  headBody2.rotation.y=Math.PI;
  headBody2.position.z = -2.52*k;
	headGroup.add (headBody,headBody2);
  headBody.position.y = 2.52*k/2;
  headBody.castShadow = true;
  headBody.receiveShadow = true;
  //headGroup.add (new THREE.AxesHelper (k));
	return headGroup;
}

function makeTorso () {
	var group = new THREE.Group();
  var material = new THREE.MeshLambertMaterial( { color:0xd0d0c,side:THREE.DoubleSide } );
  Torsobody = new THREE.Mesh (new THREE.BoxGeometry(2.52*k, 3.48*k, 1.26*k), material);
  Torsobody2=buildTorso();
  Torsobody2.rotation.y=Math.PI;
  Torsobody2.position.z = -1.27*k;
	group.add (Torsobody,Torsobody2);
  Torsobody.position.y = 3.48*k/2;
  Torsobody.castShadow = true;
  Torsobody.receiveShadow = true;
	//group.add (new THREE.AxesHelper (2*k));
return group;

}

function Drumkeyframe(t) {
  var s = ((t - ts) % T) / T;

  for (var i = 1; i < Drumkeys.length; i++) {
    if (Drumkeys[i][0] > s) break;
  }
  // take i-1
  var ii = i - 1;
  var a = (s - Drumkeys[ii][0]) / (Drumkeys[ii + 1][0] - Drumkeys[ii][0]);
  intKey1 = [Drumkeys[ii][1].Dtheta1 * (1 - a) + Drumkeys[ii + 1][1].Dtheta1 * a,
            Drumkeys[ii][1].Dtheta2 * (1 - a) + Drumkeys[ii + 1][1].Dtheta2 * a,
            Drumkeys[ii][1].Dtheta3 * (1 - a) + Drumkeys[ii + 1][1].Dtheta3 * a,
            Drumkeys[ii][1].Dtheta4 * (1 - a) + Drumkeys[ii + 1][1].Dtheta4 * a,
            Drumkeys[ii][1].Dtheta5 * (1 - a) + Drumkeys[ii + 1][1].Dtheta5 * a,
            Drumkeys[ii][1].Dtheta6 * (1 - a) + Drumkeys[ii + 1][1].Dtheta6 * a,
            Drumkeys[ii][1].Dtheta7 * (1 - a) + Drumkeys[ii + 1][1].Dtheta7 * a,
            Drumkeys[ii][1].Dtheta8 * (1 - a) + Drumkeys[ii + 1][1].Dtheta8 * a,
            Drumkeys[ii][1].Dtheta9 * (1 - a) + Drumkeys[ii + 1][1].Dtheta9 * a,
            Drumkeys[ii][1].Dtheta10 * (1 - a) + Drumkeys[ii + 1][1].Dtheta10 * a
  ];

}
function Cymbalkeyframe(t) {
  var s = ((t - tss) % T) / T;

  for (var i = 1; i < Cymbalkeys.length; i++) {
    if (Cymbalkeys[i][0] > s) break;
  }
  // take i-1
  var ii = i - 1;
  var a = (s - Cymbalkeys[ii][0]) / (Cymbalkeys[ii + 1][0] - Cymbalkeys[ii][0]);
  intKey2 = [Cymbalkeys[ii][1].Ctheta1 * (1 - a) + Cymbalkeys[ii + 1][1].Ctheta1 * a,
            Cymbalkeys[ii][1].Ctheta2 * (1 - a) + Cymbalkeys[ii + 1][1].Ctheta2 * a,
            Cymbalkeys[ii][1].Ctheta3 * (1 - a) + Cymbalkeys[ii + 1][1].Ctheta3 * a,
            Cymbalkeys[ii][1].Ctheta4 * (1 - a) + Cymbalkeys[ii + 1][1].Ctheta4 * a,
            Cymbalkeys[ii][1].Ctheta5 * (1 - a) + Cymbalkeys[ii + 1][1].Ctheta5 * a,
            Cymbalkeys[ii][1].Ctheta6 * (1 - a) + Cymbalkeys[ii + 1][1].Ctheta6 * a,
            Cymbalkeys[ii][1].Ctheta7 * (1 - a) + Cymbalkeys[ii + 1][1].Ctheta7 * a,
            Cymbalkeys[ii][1].Ctheta8 * (1 - a) + Cymbalkeys[ii + 1][1].Ctheta8 * a,
            Cymbalkeys[ii][1].Ctheta9 * (1 - a) + Cymbalkeys[ii + 1][1].Ctheta9 * a,
            Cymbalkeys[ii][1].Ctheta10 * (1 - a) + Cymbalkeys[ii + 1][1].Ctheta10 * a,
            Cymbalkeys[ii][1].Ctheta11 * (1 - a) + Cymbalkeys[ii + 1][1].Ctheta11 * a,
            Cymbalkeys[ii][1].Ctheta12 * (1 - a) + Cymbalkeys[ii + 1][1].Ctheta12 * a
  ];
}
function buildface() {
  let geometry = new THREE.Geometry();
  geometry.vertices.push(
    new THREE.Vector3(-2.52*k/2, 0, -2.52*k/2),
    new THREE.Vector3(2.52*k/2, 0, -2.52*k/2),
    new THREE.Vector3(-2.52*k/2, 2.52*k, -2.52*k/2),
    new THREE.Vector3(2.52*k/2, 2.52*k, -2.52*k/2)
  );


  let face;
  face = new THREE.Face3(0, 1, 2);
  face.materialIndex = 0;
  geometry.faces.push(face);
  face = new THREE.Face3(2, 1, 3);
  face.materialIndex = 0;
  geometry.faces.push(face);


  geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(0, 1)]);
  geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 1), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);

  geometry.computeFaceNormals();
  geometry.computeVertexNormals();

  let loader = new THREE.TextureLoader();
  loader.crossOrigin = '';
  let texture = loader.load('https://i.imgur.com/J0uy9Kv.png');
  
  materialArray = [];
  materialArray.push(new THREE.MeshLambertMaterial({
      map: texture
    }));
  return new THREE.Mesh(geometry, materialArray);
}
function buildTorso() {
  let geometry = new THREE.Geometry();
  geometry.vertices.push(
    new THREE.Vector3(-2.5*k/2, 0, -1.26*k/2),
    new THREE.Vector3(2.52*k/2, 0, -1.26*k/2),
    new THREE.Vector3(-2.52*k/2, 3.48*k, -1.26*k/2),
    new THREE.Vector3(2.52*k/2, 3.48*k, -1.26*k/2)
  );


  let face;
  face = new THREE.Face3(0, 1, 2);
  face.materialIndex = 0;
  geometry.faces.push(face);
  face = new THREE.Face3(2, 1, 3);
  face.materialIndex = 0;
  geometry.faces.push(face);


  geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(0, 1)]);
  geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 1), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);

  geometry.computeFaceNormals();
  geometry.computeVertexNormals();

  let loader = new THREE.TextureLoader();
  loader.crossOrigin = '';
  let texture = loader.load('https://i.imgur.com/ncljgL4.png');
  
  materialArray = [];
  materialArray.push(new THREE.MeshLambertMaterial({
      map: texture
    }));
  return new THREE.Mesh(geometry, materialArray);
}
function buildarm() {
  let geometry = new THREE.Geometry();
  geometry.vertices.push(
    new THREE.Vector3(-1.25*k/2, 0, -1.25*k/2),
    new THREE.Vector3(1.25*k/2, 0, -1.25*k/2),
    new THREE.Vector3(1.25*k/2, 1.2*k, -1.25*k/2),
    new THREE.Vector3(-1.25*k/2, 1.2*k, -1.25*k/2),
    new THREE.Vector3(1.25*k/2, 0, 1.25*k/2),
    new THREE.Vector3(1.25*k/2, 1.2*k, 1.25*k/2),
    new THREE.Vector3(-1.25*k/2, 0, 1.25*k/2),
    new THREE.Vector3(-1.25*k/2, 1.2*k, 1.25*k/2),
  );


  let face;
  face = new THREE.Face3(0, 1, 2);
  face.materialIndex = 0;
  geometry.faces.push(face);
  face = new THREE.Face3(2, 3, 0);
  face.materialIndex = 0;
  geometry.faces.push(face);
  face = new THREE.Face3(1, 4, 5);
  face.materialIndex = 1;
  geometry.faces.push(face);
  face = new THREE.Face3(5, 2, 1);
  face.materialIndex = 1;
  geometry.faces.push(face);
  face = new THREE.Face3(4, 6, 7);
  face.materialIndex = 2;
  geometry.faces.push(face);
  face = new THREE.Face3(7, 5, 4);
  face.materialIndex = 2;
  geometry.faces.push(face);
  face = new THREE.Face3(6, 0, 3);
  face.materialIndex = 3;
  geometry.faces.push(face);
  face = new THREE.Face3(3, 7, 6);
  face.materialIndex = 3;
  geometry.faces.push(face);

  geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(0, 1)]);
  geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 1), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
  geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(0, 1)]);
  geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 1), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
  geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(0, 1)]);
  geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 1), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
  geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(0, 1)]);
  geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 1), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
  geometry.computeFaceNormals();
  geometry.computeVertexNormals();


  
  materialArray = [];
  materialArray.push(new THREE.MeshLambertMaterial({
      color: 0xd0d0c,side: THREE.DoubleSide
    }));
    materialArray.push(new THREE.MeshLambertMaterial({
      color: 0xd0d0c,side: THREE.DoubleSide
    }));
    materialArray.push(new THREE.MeshLambertMaterial({
      color: 0xd0d0c,side: THREE.DoubleSide
    }));
    materialArray.push(new THREE.MeshLambertMaterial({
      color: 0xd0d0c,side: THREE.DoubleSide
    }));
  return new THREE.Mesh(geometry, materialArray);
}
function buildtire() {

		var loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    var colormap = loader.load ('http://jyunming-chen.github.io/tutsplus/images/tire-side.png');
    var colormap2 = loader.load ('http://jyunming-chen.github.io/tutsplus/images/tire-wheel.jpg');
    
    var tire = new THREE.Object3D();
    var geometry = new THREE.CircleGeometry(0.1, 30);
    var material = new THREE.MeshBasicMaterial({
        map: colormap,
       // transparent: true,  // for cut-out texture
        alphaTest: 0.5,
        side: THREE.DoubleSide
    });
    carmesh1 = new THREE.Mesh(geometry, material);
colormap2.wrapS = colormap2.wrapT = THREE.RepeatWrapping; 
	colormap2.repeat.set( 8, 1 );
    carmesh2 = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.1, 30, 1, true), // only side
    new THREE.MeshBasicMaterial({
        map: colormap2,
        side: THREE.DoubleSide
    }));
    carmesh2.rotation.x = Math.PI / 2;
    carmesh1.position.set(0, 0, 0.05);
    carmesh0 = carmesh1.clone();
    carmesh0.position.set(0, 0, -0.05);
    carmesh0.rotation.y = Math.PI;
    tire.add (carmesh1);
    tire.add(carmesh0);
    tire.add(carmesh2);
    carmesh0.castShadow = true;
    carmesh0.receiveShadow = true;
    carmesh2.castShadow = true;
    carmesh2.receiveShadow = true;
    return tire;
}
function buildcar(){
  var c= new THREE.Group();
    tire1=buildtire();
    tire1.position.set(0,0.1,0.15);
    tire2=buildtire();
    tire2.position.set(0,0.1,-0.15);
    var material = new THREE.MeshBasicMaterial( { color:'black',side:THREE.DoubleSide } );
  	box = new THREE.Mesh (new THREE.BoxGeometry(0.2, 0.15, 0.02), material); 
    box.rotation.set(Math.PI/2,0,Math.PI/2);
    box.position.set(0,0.1,0);
    c.add(tire1,tire2,box);
  return c;
}
function buildDrum(){
	drumgroup = new THREE.Group();
  var geometry = new THREE.CylinderBufferGeometry(0.15, 0.15, 0.1, 32 );
  var material = new THREE.MeshLambertMaterial( {color: 'red'} );
  cylinder1 = new THREE.Mesh( geometry, material );
  cylinder1.position.set(0.3,0.4,0);
  cylinder1.rotation.z=-Math.PI/2;
  var geometry = new THREE.CylinderBufferGeometry(0.15, 0.15, 0.02, 32 );
  var material = new THREE.MeshLambertMaterial( {color: 0xeba434} );
  cylinder2 = new THREE.Mesh( geometry, material );
  cylinder2.position.set(0.24,0.4,0);
  cylinder2.rotation.z=-Math.PI/2;
  cylinder3 = new THREE.Mesh( geometry, material );
  cylinder3.position.set(0.36,0.4,0);
  cylinder3.rotation.z=-Math.PI/2;
  var geometry = new THREE.CylinderBufferGeometry(0.01, 0.01, 0.5, 32 );
  var material = new THREE.MeshLambertMaterial( {color: 0x803d0a} );
  cylinder4 = new THREE.Mesh( geometry, material );
  cylinder4.position.set(0.36,0.18,0);
  cylinder4.rotation.x=-Math.PI/4;
  cylinder5 = new THREE.Mesh( geometry, material );
  cylinder5.position.set(0.36,0.18,0);
  cylinder5.rotation.x=Math.PI/4;
  cylinder6 = new THREE.Mesh( geometry, material );
  cylinder6.position.set(0.24,0.18,0);
  cylinder6.rotation.x=-Math.PI/4;
  cylinder7 = new THREE.Mesh( geometry, material );
  cylinder7.position.set(0.24,0.18,0);
  cylinder7.rotation.x=Math.PI/4;
  
  cylinder1.castShadow = true;
  cylinder1.receiveShadow = true;
  cylinder2.castShadow = true;
  cylinder2.receiveShadow = true;
  cylinder3.castShadow = true;
  cylinder3.receiveShadow = true;
  cylinder4.castShadow = true;
  cylinder4.receiveShadow = true;
  cylinder5.castShadow = true;
  cylinder5.receiveShadow = true;
  cylinder6.castShadow = true;
  cylinder6.receiveShadow = true;
  cylinder7.castShadow = true;
  cylinder7.receiveShadow = true;
  
  drumgroup.add(cylinder1,cylinder2,cylinder3,cylinder4,cylinder5,cylinder6,cylinder7);
  return drumgroup;
}

function animate() {
	requestAnimationFrame (animate);
	if( arToolkitSource.ready === false )	return
	arToolkitContext.update( arToolkitSource.domElement )

	renderer.clear();
	renderer.render( scene, camera );
  stats.update();
	//button.material.visible = markerA.visible;
	scene.visible = camera.visible
	renderer.render (sceneHUD, cameraHUD);
  if ( markerA.visible && markerB.visible ){
    update();
  }
  if(markerA.visible){
    GroupA.children[4].visible = true;
    Drumkeyframe(clock.getElapsedTime()); 
    men[1][3].rotation.y = intKey1[0];//gcontrol.theta1;
    men[1][4].rotation.y = intKey1[1];//gcontrol.theta2;
    men[1][5].rotation.y = intKey1[2];//gcontrol.theta3;
    men[1][6].rotation.y = intKey1[3];//gcontrol.theta4;
    men[1][7].rotation.y = intKey1[4];//gcontrol.theta5;
    men[1][8].rotation.y = intKey1[5];//gcontrol.theta6;
    men[1][9].rotation.y =intKey1[6];//gcontrol.theta7;
    men[1][10].rotation.y =intKey1[7];//gcontrol.theta8;
    men[1][1].rotation.y= intKey1[8];//gcontrol.theta9;
    men[1][2].rotation.y = intKey1[9];//gcontrol.theta10;
  }
  if(markerB.visible){
    GroupB.children[2].visible = true;
    Cymbalkeyframe(clock.getElapsedTime()); 
    men[2][3].rotation.y = intKey2[0];//gcontrol.theta1;
    men[2][4].rotation.y = intKey2[1];//gcontrol.theta2;
    men[2][5].rotation.y = intKey2[2];//gcontrol.theta3;
    men[2][6].rotation.y = intKey2[3];//gcontrol.theta4;
    men[2][7].rotation.y = intKey2[4];//gcontrol.theta5;
    men[2][8].rotation.y = intKey2[5];//gcontrol.theta6;
    men[2][9].rotation.y = intKey2[6];//gcontrol.theta7;
    men[2][10].rotation.y = intKey2[7];//gcontrol.theta8;
    men[2][1].rotation.y = intKey2[8];//gcontrol.theta9;
    men[2][2].rotation.y = intKey2[9];//gcontrol.theta10;
    men[2][4].rotation.z = intKey2[10];//gcontrol.theta11;
    men[2][6].rotation.z = intKey2[11];//gcontrol.theta12;
  }
  GroupA.children[4].visible = false;
  GroupB.children[2].visible = false;
  /*if(GroupA.children[3].position.distanceTo(GroupA.children[1].position)<=0.3){
    GroupA.children[4].visible = true;
    Drumkeyframe(clock.getElapsedTime()); 
    men[1][3].rotation.y = intKey1[0];//gcontrol.theta1;
    men[1][4].rotation.y = intKey1[1];//gcontrol.theta2;
    men[1][5].rotation.y = intKey1[2];//gcontrol.theta3;
    men[1][6].rotation.y = intKey1[3];//gcontrol.theta4;
    men[1][7].rotation.y = intKey1[4];//gcontrol.theta5;
    men[1][8].rotation.y = intKey1[5];//gcontrol.theta6;
    men[1][9].rotation.y =intKey1[6];//gcontrol.theta7;
    men[1][10].rotation.y =intKey1[7];//gcontrol.theta8;
    men[1][1].rotation.y= intKey1[8];//gcontrol.theta9;
    men[1][2].rotation.y = intKey1[9];//gcontrol.theta10;
  }
  else {
    GroupA.children[4].visible = false;
  }
  if(GroupA.children[3].position.distanceTo(GroupB.children[1].position)<=0.3){
    GroupB.children[2].visible = true;
    Cymbalkeyframe(clock.getElapsedTime()); 
    men[2][3].rotation.y = intKey2[0];//gcontrol.theta1;
    men[2][4].rotation.y = intKey2[1];//gcontrol.theta2;
    men[2][5].rotation.y = intKey2[2];//gcontrol.theta3;
    men[2][6].rotation.y = intKey2[3];//gcontrol.theta4;
    men[2][7].rotation.y = intKey2[4];//gcontrol.theta5;
    men[2][8].rotation.y = intKey2[5];//gcontrol.theta6;
    men[2][9].rotation.y = intKey2[6];//gcontrol.theta7;
    men[2][10].rotation.y = intKey2[7];//gcontrol.theta8;
    men[2][1].rotation.y = intKey2[8];//gcontrol.theta9;
    men[2][2].rotation.y = intKey2[9];//gcontrol.theta10;
    men[2][4].rotation.z = intKey2[10];//gcontrol.theta11;
    men[2][6].rotation.z = intKey2[11];//gcontrol.theta12;
  }
  else{
    GroupB.children[2].visible = false;
  }*/
  //GroupA.children[0].material.visible = false;
	if (cubeSpin)
		markerA.children[0].rotation.x += 0.1
}

</script></body>
