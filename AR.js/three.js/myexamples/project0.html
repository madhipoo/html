<!DOCTYPE html>
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<!-- three.js library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.min.js"></script>
<!--script src='../examples/vendor/three.js/build/three.min.js'></script-->
<script src="../examples/vendor/three.js/examples/js/libs/stats.min.js"></script>
<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<!-- jsartookit -->
<script src="../vendor/jsartoolkit5/build/artoolkit.min.js"></script>
<script src="../vendor/jsartoolkit5/js/artoolkit.api.js"></script>
<!-- include threex.artoolkit -->
<script src="../src/threex/threex-artoolkitsource.js"></script>
<script src="../src/threex/threex-artoolkitcontext.js"></script>
<script src="../src/threex/threex-arbasecontrols.js"></script>
<script src="../src/threex/threex-armarkercontrols.js"></script>

<script>THREEx.ArToolkitContext.baseURL = '../'</script>

<body style='margin : 0px; overflow: hidden; font-family: Monospace;'>
<div style='font-size:2em;position: absolute; top: 10px; width:100%; text-align: center; z-index: 1;'>
	<a href="https://github.com/jeromeetienne/AR.js/" target="_blank">AR.js</a>
	<br/>
	<p id='printDis'></p>
	<p id='touch'></p>
	<p id='ratio'></p>
</div>
<script type="x-shader/x-fragment" id="fragmentShaderDepth">
	uniform sampler2D texture;
	varying vec2 vUv;

	vec4 pack_depth(const in float depth) {
		const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);
		const vec4 bit_mask = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);
		vec4 res = fract(depth * bit_shift);
		res -= res.xxyz * bit_mask;
		return res;
	}

	void main() {
		vec4 pixel = texture2D(texture, vUv);
		if (pixel.a < 0.5) discard;
		gl_FragData[0] = pack_depth (gl_FragCoord.z);
	}
</script>
<script type="x-shader/x-vertex" id="vertexShaderDepth">
	varying vec2 vUv;

	void main() {
		vUv = uv;
		gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
	}
</script>
<script>
class Button {
	constructor (size, x, y){
		this.size = size;
		this.centerX = x;
		this.centerY = y;
	}
	d1To (v) { // 1-norm
		return Math.abs (v[0]-this.centerX) + Math.abs(v[1]-this.centerY);
	}
	d2To (v) { // 2-norm
		return Math.sqrt ( (v[0]-this.centerX)*(v[0]-this.centerX) 
				+ (v[1]-this.centerY)*(v[1]-this.centerY) );
	}
	dInfTo (v) { // inf-norm
		return Math.max( Math.abs (v[0]-this.centerX), Math.abs(v[1]-this.centerY) )
	}
}
// global variables
var renderer,stats;
var scene, camera,sceneHUD, cameraHUD;
var markerKanji, markerHiro;
var KanjiGroup,HiroGroup
var arToolKitSource, arToolKitContext;
var button;
//var raycaster, pickables;
var ballPos = new THREE.Vector3();
var whRatio, halfW, halfH;
var flag = 0,time = 0;
var button1,cubeSpin = false;
var _iOSDevice;
//var onRenderFcts= [];
//var debugEnabled = false
init();
animate();

function init() {
	let _iOSDevice = !!navigator.platform.match(/iPhone|iPod|iPad/);
	console.log ('iOS: ' + _iOSDevice)

	renderer	= new THREE.WebGLRenderer({
		// antialias	: true,
		alpha: true
	});
	renderer.setClearColor(new THREE.Color('lightgrey'), 0)
	// renderer.setPixelRatio( 1/2 );
	renderer.setSize( window.innerWidth, window.innerHeight );
	renderer.domElement.style.position = 'absolute'
	renderer.domElement.style.top = '0px'
	renderer.domElement.style.left = '0px'
	document.body.appendChild( renderer.domElement );

	whRatio = window.innerWidth/window.innerHeight;
	renderer.autoClear = false;
	// init scene and camera
	scene	= new THREE.Scene();
	// Create a camera
	camera = new THREE.Camera();
	scene.add(camera);
	sceneHUD = new THREE.Scene();
	// eye-coordinate bounds
	halfH = 10;
	halfW = halfH * whRatio;
	cameraHUD = new THREE.OrthographicCamera (-halfW,halfW, halfH,-halfH, -10,10);

	var buttonSize = halfH/3;
	button = new THREE.Mesh (new THREE.PlaneGeometry(buttonSize, buttonSize), 
			new THREE.MeshBasicMaterial({color:"yellow", transparent:true, opacity:0.8}));	
	button1 = new Button (buttonSize, 0, -halfH/2);
	button.position.set (button1.centerX, button1.centerY, 0);
	sceneHUD.add (button);
	arToolkitSource = new THREEx.ArToolkitSource({
		// to read from the webcam 
		sourceType : 'webcam',

	})

	arToolkitSource.init(function onReady(){
		onResize()
	})
	
	// handle resize

	arToolkitContext = new THREEx.ArToolkitContext({
		cameraParametersUrl: THREEx.ArToolkitContext.baseURL + '../data/data/camera_para.dat',
		detectionMode: 'mono',
		maxDetectionRate: 30,
		canvasWidth: 80*3,
		canvasHeight: 60*3,
	})
	// initialize it
	arToolkitContext.init(function onCompleted(){
		// copy projection matrix to camera
		camera.projectionMatrix.copy( arToolkitContext.getProjectionMatrix() );
	})
	renderer.shadowMap.type = THREE.PCFSoftShadowMap
    renderer.shadowMap.enabled = true;

	markerHiro = new THREE.Group();
	var artoolkitMarker = new THREEx.ArMarkerControls(arToolkitContext, markerHiro, {
		type : 'pattern',
		patternUrl : THREEx.ArToolkitContext.baseURL + '../data/data/patt.hiro',
	})
	scene.add (markerHiro);
	HiroGroup = new THREE.Group();
	markerHiro.add(HiroGroup);
	let inHiro = addMarkerHiro();
	HiroGroup.add(inHiro[0],inHiro[1],inHiro[2])


	markerKanji = new THREE.Group();
	var markerControls = new THREEx.ArMarkerControls(arToolkitContext, markerKanji, {
		type : 'pattern',
		patternUrl : THREEx.ArToolkitContext.baseURL + '../data/data/patt.kanji',
	})
	scene.add (markerKanji);
	KanjiGroup = new THREE.Group();
	markerKanji.add(KanjiGroup);
	let man = buildMan();
	KanjiGroup.add(man);
	let inKanji = addMarkerKanji();
	KanjiGroup.add(inKanji[0],inKanji[1])

	var ambient = new THREE.AmbientLight( 0x666666 );
	scene.add( ambient );

	let light = new THREE.PointLight( 0xffffff, 1, 1000 );
	light.position.set( 0,5,0 ); // default; light shining from top
	light.castShadow = true;
	scene.add( light );

	stats = new Stats();
	document.body.appendChild( stats.dom );

	window.addEventListener('resize', function(){
		onResize()
	})
	if (_iOSDevice)
    	window.addEventListener('touchstart', onTouchStart, false);
	else
		window.addEventListener ('mousedown', onMouseDown, false);
}
function onResize(){
		arToolkitSource.onResize()	
		arToolkitSource.copySizeTo(renderer.domElement)	
		if( arToolkitContext.arController !== null ){
			arToolkitSource.copySizeTo(arToolkitContext.arController.canvas)	
		}
		$('#ratio').text ('resize: width: ' + window.innerWidth + ' height: ' + window.innerHeight)
		whRatio = window.innerWidth/window.innerHeight;
		halfW = halfH * whRatio;
		cameraHUD.left = -halfW;
		cameraHUD.right = halfW;
		cameraHUD.top = halfH;
		cameraHUD.bottom = -halfH;
	}	
	function buildMan() {
		let manGroup = new THREE.Object3D();
		let loader = new THREE.TextureLoader();
		loader.setCrossOrigin('')
		let texture = loader.load( 'https://i.imgur.com/dB5hGwk.png' );
		let material = new THREE.MeshBasicMaterial( { 
			map: texture,
			alphaTest: 0.5,
			side: THREE.DoubleSide
		} );
		let mesh1 = new THREE.Mesh(buildGeometry(), material);
		mesh1.position.set(1,0.3,0);
		manGroup.add(mesh1);
      var uniforms = {
            texture: {
                type: "t",
                value: texture
            }
          };
      var vertexShader = document.getElementById('vertexShaderDepth').textContent;
      var fragmentShader = document.getElementById('fragmentShaderDepth').textContent;
      mesh1.customDepthMaterial = new THREE.ShaderMaterial({
            uniforms: uniforms,
            vertexShader: vertexShader,
            fragmentShader: fragmentShader
        });
        
        mesh1.castShadow = true;
        
        return manGroup;	
    }
	function addMarkerKanji () {
	let loader = new THREE.TextureLoader();
	loader.setCrossOrigin('');
	let ballTexture = loader.load("https://i.imgur.com/BxRSVzx.png");
	let ball1 = new THREE.Mesh(
		new THREE.SphereGeometry(0.3, 32, 32),
		new THREE.MeshLambertMaterial({ 
			map: ballTexture, 
			color: 0xff0000
		})
	);
	ball1.position.set(0,1,0);
	ball1.castShadow = true;
	
	let planematerial = new THREE.MeshLambertMaterial({color:0xffffff, side:THREE.DoubleSide});
	planematerial.opacity = 0.6; 
	let planegeometry = new THREE.PlaneGeometry(3, 3)
	let planeMesh = new THREE.Mesh( planegeometry, planematerial);
	planeMesh.receiveShadow = true;
	planeMesh.depthWrite = false;
	planeMesh.rotation.x = -Math.PI/2
	/// add gridhelper
	var gridXZ = new THREE.GridHelper(1,10);
	//markerRootKanji.add (gridXZ);
	return [ball1,planeMesh];
}
function addMarkerHiro(){
	let markeroot1 = new THREE.Group();
	let loader = new THREE.TextureLoader();
	loader.setCrossOrigin('')
	// add a torus knot	
	let geometry	= new THREE.TorusKnotGeometry(0.3,0.1,64,16);
	let material	= new THREE.MeshLambertMaterial({color:0xffff00});
	mesh2 = new THREE.Mesh( geometry, material );
	mesh2.position.set(-1,0.5,0);
	mesh2.castShadow = true;
    mesh2.receiveShadow = true;
	markeroot1.add(mesh2);
	let ballTexture = loader.load("https://i.imgur.com/BxRSVzx.png");
	ball2 = new THREE.Mesh(
		new THREE.SphereGeometry(0.3, 32, 32),
		new THREE.MeshLambertMaterial({ 
			map: ballTexture, 
			color: 0x0000ff
		})
	);
	ball2.position.set(0,1,0);
	ball2.castShadow = true;
	markeroot1.add( ball2 );

	let planematerial = new THREE.MeshLambertMaterial({color:0xffffff, side:THREE.DoubleSide});
	planematerial.opacity = 0.6; 
	let planegeometry = new THREE.PlaneGeometry(3, 3)
	let planeMesh = new THREE.Mesh( planegeometry, planematerial);
	planeMesh.receiveShadow = true;
	planeMesh.depthWrite = false;
	planeMesh.rotation.x = -Math.PI/2
	markeroot1.add(planeMesh);

	return [mesh2,ball2,planeMesh];
}	
function update() {
	// o1, x1, z1
	let o1 = markerHiro.position.clone();
	let x1 = markerHiro.localToWorld (new THREE.Vector3(1,0,0)).sub(o1);
	let z1 = markerHiro.localToWorld (new THREE.Vector3(0,0,1)).sub(o1);
	// o2, x2, z2
	let o2 = markerKanji.position.clone();
	let x2 = markerKanji.localToWorld (new THREE.Vector3(1,0,0)).sub(o2);
	let z2 = markerKanji.localToWorld (new THREE.Vector3(0,0,1)).sub(o2);
	// ball position (eye coord)
	//ballPosEye = markerHiro.localToWorld (ballPos.clone());
	//let ballPos2 = ballPosEye.sub (o2);
	//ball2.position.x = ballPos2.dot (x2);   
	//ball2.position.z = ballPos2.dot (z2) ;  
	let msg
	if(markerKanji.visible === true&&markerHiro.visible === true){
		msg += ' Hiro Kanji'
		if(flag){
			time+= 0.01;
			if(time>=1)flag = 0;
		}
		else{
			time-=0.01
			if(time<=0)flag = 1;
		}
		let ot = Evaluate(o1, o2, time);
		HiroGroup.children[1].position.copy(ot); //ball2
		KanjiGroup.children[1].position.copy(ot); //ball1
		//HiroGroup.children[1].position.copy (boxPos);
		//markerKanji.children[1].position.copy (boxPos);
	}
}
function Evaluate(o1, o2, t)
{
	let ot1 = o1.clone().multiplyScalar(1-t);
	let ot2 = o2.clone().multiplyScalar(t);
	let ot = ot1.clone().add(ot2);
	return new THREE.Vector3(ot.x, ot.y, ot.z);
}
function buildGeometry() {
  var geometry = new THREE.Geometry();
  geometry.vertices.push(
    new THREE.Vector3(-.3, -.3, 0),
    new THREE.Vector3(.3, -.3, 0),
    new THREE.Vector3(.3, .3, 0),
    new THREE.Vector3(-.3, .3, 0)
  );

  var face;
  face = new THREE.Face3(0, 1, 2);
  geometry.faces.push(face);
  face = new THREE.Face3(0, 2, 3);
  geometry.faces.push(face);

  st0 = new THREE.Vector2(0, 0.33);
  st1 = new THREE.Vector2(0.125, 0.33);
  st2 = new THREE.Vector2(0.125, 0.66);
  st3 = new THREE.Vector2(0, 0.66);
  geometry.faceVertexUvs[0].push([st0, st1, st2]);
  geometry.faceVertexUvs[0].push([st0, st2, st3]);

  geometry.computeBoundingSphere();
  geometry.computeFaceNormals();
  geometry.computeVertexNormals();
  return geometry;
}
function pickCompute (ndcX, ndcY) {
	// use 2D algorithm 	
	let dist = button1.dInfTo ([halfW * ndcX, halfH * ndcY]);	
	$('#touch').text ('Mouse-dist-Button: ' + dist.toFixed(2))

	if (dist < button1.size/2) {
		console.log ('picked')
		cubeSpin = !cubeSpin;
	} else {
		console.log ('no hit')
	}
}
function onMouseDown (event) {
	console.log ('in mouse down')
	event.preventDefault();
	let ndcX = (event.clientX / window.innerWidth) * 2 - 1;
	let ndcY = -(event.clientY / window.innerHeight) * 2 + 1;

	pickCompute (ndcX, ndcY);		
}	
function onTouchStart (event) {
	console.log ('in touch start')

	if (event.touches.length == 1) {
		
		event.preventDefault();
		let ndcX = ( event.touches[0].pageX / window.innerWidth ) * 2 - 1;
		let ndcY = - ( event.touches[0].pageY / window.innerHeight ) * 2 + 1;

		pickCompute (ndcX, ndcY);		
		
	}	
}	

function animate() {
	requestAnimationFrame (animate);
	if( arToolkitSource.ready === false )	return
	arToolkitContext.update( arToolkitSource.domElement )

	renderer.clear();
	renderer.render( scene, camera );
	//button.material.visible = markerHiro.visible;
	scene.visible = camera.visible
	renderer.render (sceneHUD, cameraHUD);
	update();
	//let did =  markerHiro.position.distanceTo (markerKanji.position)
	//console.log (did)
	//$('#printDis').text ('DIS: ' + did.toFixed(2))
	
	// billboard of sitckman
	// camera at eye coord: (0,0,0)
	// corresponding marker coordinate:
	/*let p0 = new THREE.Vector3 (0,0,0)
	let mw = new THREE.Matrix4();		
	p0.applyMatrix4 (mw.getInverse(markerKanji.matrixWorld));

	p0.y = 0;
	let front = new THREE.Vector3(0,0,1);
	let angle = p0.angleTo (front);
	let axis = new THREE.Vector3();
	axis.crossVectors ( front, p0 ).normalize();
	if (axis.y > 0)  // 0, 1, 0
		markerKanji.children[0].rotation.y = angle;
	else 
		markerKanji.children[0].rotation.y = -angle;*/
	HiroGroup.children[0].material.visible = false;
	KanjiGroup.children[0].material.visible = false;
	//KanjiGroup.children[0].rotation.x += 0.1;
	//KanjiGroup.children[1].material.visible = false;
	//$('#printDis').text (msg)
	if (cubeSpin)
		markerHiro.children[0].rotation.x += 0.1
}

</script></body>
