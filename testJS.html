<html>
	<head>
		<audio crossorigin="anonymous" id="collisionsound" style="display:none">
			<source src="https://madhipoo.github.io/html/music/Taiko drum(Bass drum).mp" type="audio/wav">
			</audio>
			<audio crossorigin="anonymous2" id="collisionsound2" style="display:none">
			<source src="https://yang880529.github.io/music/Taiko_Drums_Small_Drum.mp" type="audio/wav">
			</audio>
			<audio id="soundtrack" autoplay="" loop="" style="display:none">
			<source src="https://madhipoo.github.io/html/music/東京盆踊2020.mp" type="audio/mp3">
			</audio>
			<div id="info">
			  <p id='output'> </p>
			</div>
			<script src="https://threejs.org/build/three.min.js"></script>
			<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
			<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
			<script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>
	</head>
	<body> 
	<script>
	var camera, scene, renderer,controls,speedL=0,speedR=0;
  var k = 5,angle = 0;
  var opc = 0.5;
  const L = 300;
  var kk = 8,min = 100;
  var GroupA,GroupB,GroupC,GroupD,GroupE,GroupF;
  var CubeWorld;
  var pos1 = [], pos2 = [], euler1 = [], euler2 = [],quat1 = [],quat2 = [];
  var moving;
  var turning,alpha = [],manIn ='A';
  var people = [],car = [];
  var musicbox;
  var lastChangeTime = 0;
  var keyNow='A';
  var faces;
  var speed=0, angle=0, vel=0,rotspeed=0;
  var a=1;

  var Drumpose1 = {
          Dtheta1: 1.2057796021989051,
          Dtheta2: 0,
          Dtheta3: 1.5,
          Dtheta4: 0.6,
          Dtheta5: 0,
          Dtheta6: 0,
          Dtheta7: 0,
          Dtheta8: 0,
          Dtheta9: -0.33541054459782915,
          Dtheta10: -0.025268798743482757,
          Dtheta11: 0,
          Dtheta12: 0
    }
  var Drumpose2 = {
          Dtheta1: 1.5,
          Dtheta2: 1,
          Dtheta3: 1.5,
          Dtheta4: 0.3,
          Dtheta5: 0,
          Dtheta6: 0,
          Dtheta7: 0,
          Dtheta8: 0,
          Dtheta9: -0.24679861721087304,
          Dtheta10: -0.06957476243696081,
          Dtheta11: 0,
          Dtheta12: 0
  }
  var Drumpose3 = {
          Dtheta1: 1.5,
          Dtheta2: 1,
          Dtheta3: 1.5,
          Dtheta4: 0,
          Dtheta5: 0,
          Dtheta6: 0,
          Dtheta7: 0,
          Dtheta8: 0,
          Dtheta9: 0.48424978373151495,
          Dtheta10: 0.15,
          Dtheta11: 0,
          Dtheta12: 0.6
  }
  var Drumpose4 = {
          Dtheta1: 1.5,
          Dtheta2: 1,
          Dtheta3: 1.5,
          Dtheta4: 1,
          Dtheta5: 0,
          Dtheta6: 0,
          Dtheta7: 0,
          Dtheta8: 0,
          Dtheta9: 0.2184140015706466,
          Dtheta10: 0.17410803787716844,
          Dtheta11: 0,
          Dtheta12: 0
  }
  var Drumpose5 = {
          Dtheta1: 1.2057796021989051,
          Dtheta2: 0,
          Dtheta3: 1.5,
          Dtheta4: 0.6,
          Dtheta5: 0,
          Dtheta6: 0,
          Dtheta7: 0,
          Dtheta8: 0,
          Dtheta9: -0.33541054459782915,
          Dtheta10: -0.025268798743482757,
          Dtheta11: 0,
          Dtheta12: 0
  }
  var Drumpose6 = {
          Dtheta1: 1.5,
          Dtheta2: 1,
          Dtheta3: 1.09501469296521,
          Dtheta4: 0,
          Dtheta5: 0,
          Dtheta6: 0,
          Dtheta7: 0,
          Dtheta8: 0,
          Dtheta9: 0.48424978373151495,
          Dtheta10: 0.08549611049021233,
          Dtheta11: 0,
          Dtheta12: 0
  }
  var Drumpose7 = {
          Dtheta1: 1.5,
          Dtheta2: 0,
          Dtheta3: 1.5,
          Dtheta4: 1,
          Dtheta5: 0,
          Dtheta6: 0,
          Dtheta7: 0,
          Dtheta8: 0,
          Dtheta9: -0.33541054459782915,
          Dtheta10: -0.15,
          Dtheta11: -0.6,
          Dtheta12: 0
  }
  var Drumpose8 = {
          Dtheta1: 1.5,
          Dtheta2: 1,
          Dtheta3: 1.5,
          Dtheta4: 1,
          Dtheta5: 0,
          Dtheta6: 0,
          Dtheta7: 0,
          Dtheta8: 0,
          Dtheta9: -0.24679861721087304,
          Dtheta10: -0.06957476243696081,
          Dtheta11: 0,
          Dtheta12: 0
  }

  var Cymbalpose1 = {
          Ctheta1: 0.7,
          Ctheta2: 1,
          Ctheta3: 0.7,
          Ctheta4: 1,
          Ctheta5: 0,
          Ctheta6: 0,
          Ctheta7: 0,
          Ctheta8: 0,
          Ctheta9: 0,
          Ctheta10: 0,
          Ctheta11: 0.7300855658923833,
          Ctheta12:  -0.7300855658923833,
  }//合
  var Cymbalpose2 = {
          Ctheta1: 0.7,
          Ctheta2: 1,
          Ctheta3: 0.7,
          Ctheta4: 1,
          Ctheta5: 0,
          Ctheta6: 0,
          Ctheta7: 0,
          Ctheta8: 0,
          Ctheta9: 0,
          Ctheta10: 0,
          Ctheta11: 0,
          Ctheta12: 0
  }//開

  var Smallpose1 = {
          Stheta1: 1.2,
          Stheta2: 0.4,
          Stheta3: 1.2,
          Stheta4: 0.4,
          Stheta5: 0,
          Stheta6: 0,
          Stheta7: 0,
          Stheta8: 0,
          Stheta9: -0.33541054459782915,
          Stheta10: -0.025268798743482757,
          Stheta11: -1.903427398586418,
          Stheta12: -1.202492653517395,
          Stheta13: 0,
          Stheta14: -1.7341642178391317
    }
  var Smallpose3 = {
          Stheta1: 1.2,
          Stheta2: 0.4,
          Stheta3: 1.2,
          Stheta4: 0.4,
          Stheta5: 0,
          Stheta6: 0,
          Stheta7: 0,
          Stheta8: 0,
          Stheta9: 0.48424978373151495,
          Stheta10: 0.08549611049021233,
          Stheta11: -1.903427398586418,
          Stheta12: -1.202492653517395,
          Stheta13: 1.7357796021989051,
          Stheta14: 0
  }

  var Smallkeys = [
    [0, Smallpose3],
    [0.09375, Smallpose1],
    [0.21875, Smallpose3],
    [0.34375, Smallpose1],
    [0.46875, Smallpose3],
    [0.5, Smallpose1],
    [0.59375, Smallpose3],
    [0.71875, Smallpose1],
    [0.84375, Smallpose3],
    [0.96875, Smallpose1],
    [1, Smallpose3]
  ];
  var Cymbalkeys = [
    [0, Cymbalpose1],
    [0.125,Cymbalpose2],
    [0.3125, Cymbalpose1],
    [0.5,Cymbalpose2],
    [0.8125,Cymbalpose1],
    [0.9,Cymbalpose2],
    [1, Cymbalpose1]
  ];
  var Drumkeys = [
    [0, Drumpose8],
    [0.0625, Drumpose1],
    [0.1875, Drumpose3],
    [0.3125, Drumpose5],
    [0.3750, Drumpose6],
    [0.4375, Drumpose7],
    [0.5675, Drumpose6],
    [0.7, Drumpose7],
    [0.8125, Drumpose6],
    [0.8750, Drumpose5],
    [0.9375, Drumpose3],
    [1, Drumpose8]
  ];

  var T = 472/67.5;
  var clock = new THREE.Clock();
  var ts = clock.getElapsedTime();  // start time
  var intKey1 = [],intkey2 = [],intkey3 = [];
  var soundTrack;
  var isDimming = false, soundVal = 0, sign = 1.0,soundVal2 = 1,soundVal3 = 1,b=1,c=0;

  (function() {
    Math.clamp = function(val,min,max){
      return Math.min(Math.max(val,min),max);
      
    }})();



  init();
  animate();

  function init() {
    //soundTrack = document.getElementById ('soundtrack');
    //collisionsound = document.getElementById('collisionsound');
    //collisionsound.crossOrigin="anonymous";
    //collisionSound2 = document.getElementById ('collisionsound2');
    //collisionSound2.crossOrigin="anonymous";
    scene = new THREE.Scene();

    renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x888888);
    document.body.appendChild(renderer.domElement);

    camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
    camera.position.z = 500;
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableKeys = false;
    ////////////////////////////////////////////////////////////////
    /*var gridXZ = new THREE.GridHelper(200, 20, 'red', 'white');
    scene.add(gridXZ);*/
  ////////////////
    CubeWorld = new THREE.Group();
    GroupA = new THREE.Group();
    CubeWorld.add(GroupA);
    
    people[0] = buildDrumMan();
    car[0] = buildcar();
    people[0][0].position.set(0,10,0);
    car[0].add(people[0][0]);
    car[0].rotation.y = Math.PI/2;
    GroupA.add(car[0]);
    GroupA.children[0].position.copy (new THREE.Vector3(0,0,0));
    GroupA.children[0].rotation.copy (new THREE.Euler(0, Math.PI/2, 0, 'ZYX'));
    var circlegeometry = new THREE.CircleBufferGeometry( 1, 32 );
    var circlematerial = new THREE.MeshBasicMaterial( { color: 'red',side:THREE.DoubleSide});
    let circle = new THREE.Mesh( circlegeometry, circlematerial );
    circle.rotation.x=-Math.PI/2;
    circle.position.y=1;
    GroupA.add(circle);
    
    let drum = buildDrum();
    drum.rotation.y = Math.PI/2;
    GroupA.add(drum);
    
    let floorA = buildBackground();
    GroupA.add(floorA);
    GroupA.rotation.x = Math.PI/2;
    GroupA.position.z = L/2;
    //scene.add(GroupA);
    ////////////////////////////////////////
    GroupB = new THREE.Group();
    CubeWorld.add(GroupB);
    
    people[1] = buildCymbalMan();
    car[1] = buildcar();
    people[1][0].position.set(0,10,0);
    car[1].add(people[1][0]);
    car[1].rotation.y = Math.PI;
    GroupB.add(car[1]);
    
    circle = new THREE.Mesh( circlegeometry, circlematerial );
    circle.rotation.x=-Math.PI/2;
    circle.position.y=1;
    GroupB.add(circle);

    let floorB = buildBackground();
    GroupB.add(floorB);
    GroupB.position.x = L/2;
    GroupB.rotation.z = -Math.PI/2;
    //scene.add(GroupB);
    GroupB.children[0].position.set(0,- L/2, L/2);
    GroupB.children[0].rotation.copy(new THREE.Euler (-Math.PI/2, Math.PI, 0, 'ZYX'));
    ////////////////////////////////////////
    GroupC = new THREE.Group();
    CubeWorld.add(GroupC);
    
    people[2] = buildSmalldrumMan();
    car[2] = buildcar();
    people[2][0].position.set(0,10,0);
    car[2].add(people[2][0]);
    car[2].rotation.y = -Math.PI/2;
    GroupC.add(car[2]);
    GroupC.children[0].position.set(0,-L, 0);
    GroupC.children[0].rotation.copy(new THREE.Euler (0, -Math.PI/2, Math.PI, 'ZYX'));
    circle = new THREE.Mesh( circlegeometry, circlematerial );
    circle.rotation.x=-Math.PI/2;
    circle.position.y=1;
    GroupC.add(circle);

    let floorC = buildBackground();
    GroupC.add(floorC);
    GroupC.rotation.x = -Math.PI/2;
    GroupC.position.z = -L/2;
    //scene.add(GroupC);
    ////////////////////////////////////////
    GroupD = new THREE.Group();
    CubeWorld.add(GroupD);
    
    people[3] = buildCymbalMan();
    car[3] = buildcar();
    people[3][0].position.set(0,10,0);
    car[3].add(people[3][0]);
    GroupD.add(car[3]);
    GroupD.children[0].position.set(0,-L/2, L/2);
    GroupD.children[0].rotation.copy(new THREE.Euler (Math.PI/2, 0, 0, 'ZYX'));
    
    circle = new THREE.Mesh( circlegeometry, circlematerial );
    circle.rotation.x=-Math.PI/2;
    circle.position.y=1;
    GroupD.add(circle);

    let floorD = buildBackground();
    GroupD.add(floorD);
    GroupD.rotation.z = Math.PI/2;
    GroupD.position.x = -L/2;
    //scene.add(GroupD);
    ////////////////////////////////////////
    GroupE = new THREE.Group();
    CubeWorld.add(GroupE);
    
    people[4] = buildCymbalMan();
    car[4] = buildcar();
    people[4][0].position.set(0,10,0);
    car[4].add(people[4][0]);
    car[4].rotation.y = Math.PI/2;
    GroupE.add(car[4]);
    GroupE.children[0].position.set(0,-L/2, L/2);
    GroupE.children[0].rotation.copy(new THREE.Euler (Math.PI/2, 0, Math.PI/2, 'ZYX'));
    
    
    circle = new THREE.Mesh( circlegeometry, circlematerial );
    circle.rotation.x=-Math.PI/2;
    circle.position.y=1;
    GroupE.add(circle);

    let floorE = buildBackground();
    GroupE.add(floorE);
    GroupE.position.y = L/2;
    //scene.add(GroupE);
    ////////////////////////////////////////
    GroupF = new THREE.Group();
    CubeWorld.add(GroupF);
    
    people[5] = buildCymbalMan();
    car[5] = buildcar();
    people[5][0].position.set(0,10,0);
    car[5].add(people[5][0]);
    car[5].rotation.y = Math.PI/2;
    GroupF.add(car[5]);
    GroupF.children[0].position.set(0,-L/2, -L/2);
    GroupF.children[0].rotation.copy(new THREE.Euler (-Math.PI/2, 0, -Math.PI/2, 'ZYX'));
    
    circle = new THREE.Mesh( circlegeometry, circlematerial );
    circle.rotation.x=-Math.PI/2;
    circle.position.y=1;
    GroupF.add(circle);

    let floorF = buildBackground();
    GroupF.add(floorF);
    GroupF.rotation.x = Math.PI;
    GroupF.position.y = -L/2;
    //scene.add(GroupF);
    //////////////////////////////////////
    CubeWorld.add (new THREE.AxesHelper (L/5));
    scene.add(CubeWorld);
    /*slhelper = new THREE.SpotLightHelper (light);
    lschelper = new THREE.CameraHelper(light.shadow.camera)  
    scene.add (slhelper)
    scene.add(lschelper);*/


    ////// create positionaudio
    var listener = new THREE.AudioListener();
    listener.crossOrigin = "anonymous";
    var listener2 = new THREE.AudioListener();
    listener2.crossOrigin = "anonymous2";
    camera.add(listener,listener2);


    /*sound = new THREE.PositionalAudio( listener );
    sound.setMediaElementSource( collisionsound );
    sound.setRefDistance( 3 );
    sound.panner.setOrientation(1,0,0);
    sound.setDirectionalCone( 360, 200, 0.1 );

    sound2 = new THREE.PositionalAudio( listener2 );
    sound2.setMediaElementSource( collisionsound2 );
    sound2.setRefDistance( 3 );
    sound2.panner.setOrientation(1,0,0);
    sound2.setDirectionalCone( 360, 200, 0.1 );*/

    musicbox = new THREE.BoxGeometry(2,1,5);
    thebox = new THREE.Mesh(musicbox,new THREE.MeshNormalMaterial());
    thebox.rotation.y=Math.PI;

    /*thebox.add(sound,sound2);
    sound.position.set(0,0,2.5);
    sound2.position.set(0,0,2.5);
    thebox.position.set(26,45,0);
    thebox.rotation.y=Math.PI/2;
    scene.add(thebox);*/
    faces = {'B': GroupB.children[0], 'E':GroupE.children[0],'A':GroupA.children[0],'D':GroupD.children[0],'F':GroupF.children[0],'C':GroupC.children[0]};
  }
  function buildDrum(){
    box = new THREE.Group();
    var loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    var colormap = loader.load ('https://i.imgur.com/MTtMccq.jpg');
    var points = [];
    for ( var i = 0; i < 10; i ++ ) {
      points.push( new THREE.Vector2( Math.sin( i * 0.2 ) * 2 + 18, ( i - 5 ) * 2 ) );
    }
    var geometry = new THREE.LatheGeometry( points );
    var material = new THREE.MeshLambertMaterial( { map: colormap} );
    var lathe1 = new THREE.Mesh( geometry, material );
    lathe1.rotation.z=Math.PI/2;
    lathe1.position.set(48,45,0);
    scene.add( lathe1 );
    for ( var i = 0; i < 10; i ++ ) {
      points.push( new THREE.Vector2( Math.sin( i * 0.2 ) * 2 + 18, ( i - 5 ) * 2 ) );
    }

    var lathe2 = new THREE.Mesh( geometry, material );
    lathe2.rotation.z=-Math.PI/2;
    lathe2.position.set(33,45,0);
    scene.add( lathe2 );


    var geometry = new THREE.CylinderBufferGeometry(18, 18, 1, 64 );
    var material = new THREE.MeshLambertMaterial( {color: 0xeba434} );
    cylinder2 = new THREE.Mesh( geometry, material );
    cylinder2.position.set(23,45,0);
    cylinder2.rotation.z=-Math.PI/2;
    cylinder3 = new THREE.Mesh( geometry, material );
    cylinder3.position.set(58,45,0);
    cylinder3.rotation.z=-Math.PI/2;
    var loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    var colormap = loader.load ('https://i.imgur.com/rMKI0rA.jpg');
    var geometry = new THREE.CylinderBufferGeometry(1, 1, 50, 32 );
    var material = new THREE.MeshLambertMaterial( {map: colormap} );
    cylinder4 = new THREE.Mesh( geometry, material );
    cylinder4.position.set(51,18,0);
    cylinder4.rotation.x=-Math.PI/4;
    cylinder5 = new THREE.Mesh( geometry, material );
    cylinder5.position.set(51,18,0);
    cylinder5.rotation.x=Math.PI/4;
    cylinder6 = new THREE.Mesh( geometry, material );
    cylinder6.position.set(30,18,0);
    cylinder6.rotation.x=-Math.PI/4;
    cylinder7 = new THREE.Mesh( geometry, material );
    cylinder7.position.set(30,18,0);
    cylinder7.rotation.x=Math.PI/4;
    box.add(lathe1,lathe2,cylinder2,cylinder3,cylinder4,cylinder5,cylinder6,cylinder7);
    lathe1.castShadow = true;
    lathe1.receiveShadow = true;
    lathe2.castShadow = true;
    lathe2.receiveShadow = true;
    cylinder2.castShadow = true;
    cylinder2.receiveShadow = true;
    cylinder3.castShadow = true;
    cylinder3.receiveShadow = true;
    cylinder4.castShadow = true;
    cylinder4.receiveShadow = true;
    cylinder5.castShadow = true;
    cylinder5.receiveShadow = true;
    cylinder6.castShadow = true;
    cylinder6.receiveShadow = true;
    cylinder7.castShadow = true;
    cylinder7.receiveShadow = true;
    return box;
    }
  function buildDrumMan(){
    let man = new THREE.Group();
    //GroupA.add(mine);
    let head = makeDrumHead();
    let torso = makeDrumTorso();
    man.add(torso);
    head.position.y = 7.57*k-4.09*k;
    torso.position.y = 4.09*k;
    torso.add(head);

    let leftarm = makeDrumArm();
    leftarm[0].position.set (-1.88*k, 7.57*k-4.09*k, 0);
    leftarm[0].add(leftarm[1]);
    torso.add (leftarm[0]);
    let rightarm = makeDrumArm();
    rightarm[0].position.set (1.88*k, 7.57*k-4.09*k, 0);
    rightarm[0].add(rightarm[1]);
    torso.add(rightarm[0]);


    let leftleg = makeDrumLeg();
    leftleg[0].position.set  (-0.63*k, 4.09*k-4.09*k, 0);
    leftleg[0].add(leftleg[1]);
    torso.add(leftleg[0]);


    let rightleg = makeDrumLeg();
    rightleg[0].position.set (0.63*k, 4.09*k-4.09*k, 0);
    rightleg[0].add(rightleg[1]);
    torso.add(rightleg[0]);

    man.rotation.y=-Math.PI/2;	
    man.position.y=0.01;
    leftarm[0].rotation.z = -Math.PI/2;
    rightarm[0].rotation.z = -Math.PI/2;
    leftleg[0].rotation.z = -Math.PI/2;
    rightleg[0].rotation.z = -Math.PI/2;
    
    leftarm[0].rotation.order = 'ZYX';
    rightarm[0].rotation.order = 'ZYX';
    leftleg[0].rotation.order = 'ZYX';
    rightleg[0].rotation.order = 'ZYX';
    man.rotation.order = 'ZYX';
    return [man,head,torso,leftarm[0],leftarm[1],rightarm[0],rightarm[1],leftleg[0],leftleg[1],rightleg[0],rightleg[1],leftarm[2],rightarm[2]];
  }

  function makeDrumArm() {
    var group = new THREE.Group();
    var group2 = new THREE.Group();
    var geometry = new THREE.CylinderBufferGeometry(1, 1, 10, 32 );
    var material = new THREE.MeshLambertMaterial( {color: 0x803d0a} );
    let stick= new THREE.Mesh( geometry, material );
    let body3=buildDrumarm();
    body3.rotation.z=Math.PI/2;
    body3.position.x = 1.92*k;
    let body6=buildDrumarm2();
    body6.rotation.z=Math.PI/2;
    body6.position.x = 1.92*k;
    stick.position.set(2*k,0,-5);
    stick.rotation.x=Math.PI/2;
    group2.add(stick,body6);
    group.add (group2,body3);
    group2.position.x =2*k;
    
    body3.castShadow = true;
    body3.receiveShadow = true;
    body6.castShadow = true;
    body6.receiveShadow = true;
    stick.castShadow = true;
    stick.receiveShadow = true;
    //group.add (new THREE.AxesHelper (k));
    //group2.add (new THREE.AxesHelper (k));
    return [group,group2,stick];
  }
  function makeDrumLeg() {
    var group = new THREE.Group();
    var group2 = new THREE.Group();
    
    let body7=buildDrumleg();
    body7.rotation.z=Math.PI/2;
    body7.position.x = 2.046*k;
    let body8=buildDrumleg2();
    body8.rotation.z=Math.PI/2;
    body8.position.x = 2.046*k;
    group2.add(body8);
    group.add (group2,body7);
    group2.position.x =2.045*k;
    
    body7.castShadow = true;
    body7.receiveShadow = true;
    body8.castShadow = true;
    body8.receiveShadow = true;
    //group.add (new THREE.AxesHelper (k));
    //group2.add (new THREE.AxesHelper (k));
    return [group,group2];
  }
  function makeDrumHead() {
    var headGroup = new THREE.Group();
    var mat = new THREE.MeshLambertMaterial({color:0x99d8ea});
    let headBody = new THREE.Mesh (new THREE.BoxGeometry(2.52*k, 2.52*k, 2.52*k), mat);
    let headBody2=buildDrumface();
    headBody2.rotation.y=Math.PI;
    headGroup.add (headBody,headBody2);
    headBody.position.y = 2.52*k/2;
    
    headBody.castShadow = true;
    headBody.receiveShadow = true;
    //headGroup.add (new THREE.AxesHelper (k));
    return headGroup;
  }
  function makeDrumTorso () {
    var group = new THREE.Group();
    var material = new THREE.MeshLambertMaterial( { color:0xd0d0c,side:THREE.DoubleSide } );
    let Torsobody = new THREE.Mesh (new THREE.BoxGeometry(2.52*k, 3.48*k, 1.26*k), material);
    let Torsobody2=buildDrumTorso();
    Torsobody2.rotation.y=Math.PI;
    group.add (Torsobody,Torsobody2);
    Torsobody.position.y = 3.48*k/2;
    
    Torsobody.castShadow = true;
    Torsobody.receiveShadow = true;
    //group.add (new THREE.AxesHelper (2*k));
  return group;

  }
  function buildDrumface() {
    let geometry = new THREE.Geometry();
    geometry.vertices.push(
      new THREE.Vector3(-2.53*k/2, 0, 2.53*k/2),
      new THREE.Vector3(2.53*k/2, 0, 2.53*k/2),
      new THREE.Vector3(2.53*k/2, 2.53*k, 2.53*k/2),
      new THREE.Vector3(-2.53*k/2, 2.53*k, 2.53*k/2),
      new THREE.Vector3(2.53*k/2, 0, -2.53*k/2),
      new THREE.Vector3(2.53*k/2, 2.53*k, -2.53*k/2),
      new THREE.Vector3(-2.53*k/2, 0, -2.53*k/2),
      new THREE.Vector3(-2.53*k/2, 2.53*k, -2.53*k/2),
    );


    let face;
    face = new THREE.Face3(0, 1, 2);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(2, 3, 0);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 4, 5);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 2, 1);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(4, 6, 7);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(7, 5, 4);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 0, 3);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 7, 6);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 2, 5);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 7, 3);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 4, 1);
    face.materialIndex = 5;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 0, 6);
    face.materialIndex = 5;
    geometry.faces.push(face);
    
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();

    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    let texture = loader.load('https://i.imgur.com/3d2gw9B.png');
    let texture1 = loader.load('https://i.imgur.com/XDyw0Rs.png');
    let texture2 = loader.load('https://i.imgur.com/8oxlNMA.png');
    let texture3 = loader.load('https://i.imgur.com/WjEobnE.png');
    let texture4 = loader.load('https://i.imgur.com/TLdR62i.png');
    let texture5 = loader.load('https://i.imgur.com/E57CwUJ.png');
    materialArray = [];
    materialArray.push(new THREE.MeshLambertMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture1
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }),
      new THREE.MeshPhongMaterial({
        map: texture3
      }),
      new THREE.MeshPhongMaterial({
        map: texture4
      }),
      new THREE.MeshPhongMaterial({
        map: texture5
      }));
    return new THREE.Mesh(geometry, materialArray);
  }
  function buildDrumTorso() {
    let geometry = new THREE.Geometry();
    geometry.vertices.push(
      new THREE.Vector3(-2.53*k/2, 0, 1.27*k/2),
      new THREE.Vector3(2.53*k/2, 0, 1.27*k/2),
      new THREE.Vector3(2.53*k/2, 3.48*k, 1.27*k/2),
      new THREE.Vector3(-2.53*k/2, 3.48*k, 1.27*k/2),
      new THREE.Vector3(2.53*k/2, 0, -1.27*k/2),
      new THREE.Vector3(2.53*k/2, 3.48*k, -1.27*k/2),
      new THREE.Vector3(-2.53*k/2, 0, -1.27*k/2),
      new THREE.Vector3(-2.53*k/2, 3.48*k, -1.27*k/2),
    );


    let face;
    face = new THREE.Face3(0, 1, 2);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(2, 3, 0);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 4, 5);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 2, 1);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(4, 6, 7);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(7, 5, 4);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 0, 3);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 7, 6);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 2, 5);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 7, 3);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 4, 1);
    face.materialIndex = 5;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 0, 6);
    face.materialIndex = 5;
    geometry.faces.push(face);
    
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();

    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    let texture = loader.load('https://i.imgur.com/SFPQbvU.png');
    let texture1 = loader.load('https://i.imgur.com/srIZpsC.png');
    let texture2 = loader.load('https://i.imgur.com/zgO9YE0.png');
    let texture3 = loader.load('https://i.imgur.com/srIZpsC.png');
    let texture4 = loader.load('https://i.imgur.com/iADRREk.png');
    let texture5 = loader.load('https://i.imgur.com/ZPH1PVI.png');
    materialArray = [];
    materialArray.push(new THREE.MeshLambertMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture1
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }),
      new THREE.MeshPhongMaterial({
        map: texture3
      }),
      new THREE.MeshPhongMaterial({
        map: texture4
      }),
      new THREE.MeshPhongMaterial({
        map: texture5
      }));
    return new THREE.Mesh(geometry, materialArray);
  }

  function buildDrumarm() {
    let geometry = new THREE.Geometry();
    geometry.vertices.push(
      new THREE.Vector3(-1.25*k/2, 0, 1.25*k/2),
      new THREE.Vector3(1.25*k/2, 0, 1.25*k/2),
      new THREE.Vector3(1.25*k/2, 1.93*k, 1.25*k/2),
      new THREE.Vector3(-1.25*k/2, 1.93*k, 1.25*k/2),
      new THREE.Vector3(1.25*k/2, 0, -1.25*k/2),
      new THREE.Vector3(1.25*k/2, 1.93*k, -1.25*k/2),
      new THREE.Vector3(-1.25*k/2, 0, -1.25*k/2),
      new THREE.Vector3(-1.25*k/2, 1.93*k, -1.25*k/2),
    );


    let face;
    face = new THREE.Face3(0, 1, 2);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(2, 3, 0);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 4, 5);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 2, 1);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(4, 6, 7);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(7, 5, 4);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 0, 3);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 7, 6);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 2, 5);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 7, 3);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 4, 1);
    face.materialIndex = 5;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 0, 6);
    face.materialIndex = 5;
    geometry.faces.push(face);
    
    
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();


    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    let texture = loader.load('https://i.imgur.com/GBmTa4L.png');
    let texture2 = loader.load('https://i.imgur.com/xWC8zfg.png');
    let texture3 = loader.load('https://i.imgur.com/eA5BB9i.png');
    materialArray = [];
    materialArray.push(new THREE.MeshLambertMaterial({
        map: texture
      }), 
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }),
      new THREE.MeshPhongMaterial({
        map: texture3
      }));
    return new THREE.Mesh(geometry, materialArray);
  }
  function buildDrumarm2() {
    let geometry = new THREE.Geometry();
    geometry.vertices.push(
      new THREE.Vector3(-1.25*k/2, 0, 1.25*k/2),
      new THREE.Vector3(1.25*k/2, 0, 1.25*k/2),
      new THREE.Vector3(1.25*k/2, 1.93*k, 1.25*k/2),
      new THREE.Vector3(-1.25*k/2, 1.93*k, 1.25*k/2),
      new THREE.Vector3(1.25*k/2, 0, -1.25*k/2),
      new THREE.Vector3(1.25*k/2, 1.93*k, -1.25*k/2),
      new THREE.Vector3(-1.25*k/2, 0, -1.25*k/2),
      new THREE.Vector3(-1.25*k/2, 1.93*k, -1.25*k/2),
    );


    let face;
    face = new THREE.Face3(0, 1, 2);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(2, 3, 0);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 4, 5);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 2, 1);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(4, 6, 7);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(7, 5, 4);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 0, 3);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 7, 6);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 2, 5);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 7, 3);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 4, 1);
    face.materialIndex = 5;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 0, 6);
    face.materialIndex = 5;
    geometry.faces.push(face);
    
    
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();


    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    let texture = loader.load('https://i.imgur.com/eA5BB9i.png');
    materialArray = [];
    materialArray.push(new THREE.MeshLambertMaterial({
        map: texture
      }), 
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }));
    return new THREE.Mesh(geometry, materialArray);
  }

  function buildDrumleg() {
    let geometry = new THREE.Geometry();
    geometry.vertices.push(
      new THREE.Vector3(-1.27*k/2, 0, 1.27*k/2),
      new THREE.Vector3(1.27*k/2, 0, 1.27*k/2),
      new THREE.Vector3(1.27*k/2, 2.046*k, 1.27*k/2),
      new THREE.Vector3(-1.27*k/2, 2.046*k, 1.27*k/2),
      new THREE.Vector3(1.27*k/2, 0, -1.27*k/2),
      new THREE.Vector3(1.27*k/2, 2.046*k, -1.27*k/2),
      new THREE.Vector3(-1.27*k/2, 0, -1.27*k/2),
      new THREE.Vector3(-1.27*k/2, 2.046*k, -1.27*k/2),
    );


    let face;
    face = new THREE.Face3(0, 1, 2);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(2, 3, 0);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 4, 5);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 2, 1);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(4, 6, 7);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(7, 5, 4);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 0, 3);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 7, 6);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 2, 5);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 7, 3);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 4, 1);
    face.materialIndex = 5;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 0, 6);
    face.materialIndex = 5;
    geometry.faces.push(face);
    
    
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();


    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    let texture = loader.load('https://i.imgur.com/HdgeyBu.png');
    let texture2 = loader.load('https://i.imgur.com/6mpD0ol.png');
    let texture3 = loader.load('https://i.imgur.com/eA5BB9i.png');
    materialArray = [];
    materialArray.push(new THREE.MeshLambertMaterial({
        map: texture
      }), 
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }),
      new THREE.MeshPhongMaterial({
        map: texture3
      }));
    return new THREE.Mesh(geometry, materialArray);
  }
  function buildDrumleg2() {
    let geometry = new THREE.Geometry();
    geometry.vertices.push(
      new THREE.Vector3(-1.27*k/2, 0, 1.27*k/2),
      new THREE.Vector3(1.27*k/2, 0, 1.27*k/2),
      new THREE.Vector3(1.27*k/2, 2.046*k, 1.27*k/2),
      new THREE.Vector3(-1.27*k/2, 2.046*k, 1.27*k/2),
      new THREE.Vector3(1.27*k/2, 0, -1.27*k/2),
      new THREE.Vector3(1.27*k/2, 2.046*k, -1.27*k/2),
      new THREE.Vector3(-1.27*k/2, 0, -1.27*k/2),
      new THREE.Vector3(-1.27*k/2, 2.046*k, -1.27*k/2),
    );


    let face;
    face = new THREE.Face3(0, 1, 2);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(2, 3, 0);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 4, 5);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 2, 1);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(4, 6, 7);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(7, 5, 4);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 0, 3);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 7, 6);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 2, 5);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 7, 3);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 4, 1);
    face.materialIndex = 5;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 0, 6);
    face.materialIndex = 5;
    geometry.faces.push(face);
    
    
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();


    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    let texture = loader.load('https://i.imgur.com/4ojGjEo.png');
    let texture2 = loader.load('https://i.imgur.com/eA5BB9i.png');
    let texture3 = loader.load('https://i.imgur.com/Xsw5JHL.png');
    materialArray = [];
    materialArray.push(new THREE.MeshLambertMaterial({
        map: texture
      }), 
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }),
      new THREE.MeshPhongMaterial({
        map: texture3
      }));
    return new THREE.Mesh(geometry, materialArray);
  }

  function buildCymbalMan(){
    let man = new THREE.Group();
    //GroupA.add(mine);
    let head = makeCymbalHead();
    let torso = makeCymbalTorso();
    man.add(torso);
    head.position.y = 7.57*k-4.09*k;
    torso.position.y = 4.09*k;
    torso.add(head);
    var loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    var colormap = loader.load ('https://i.imgur.com/54uWXuj.jpg');
    var geometry = new THREE.CylinderBufferGeometry(5, 10, 1, 32 );
    var material = new THREE.MeshLambertMaterial( {map: colormap} );
    let stick= new THREE.Mesh( geometry, material );
    let stick2= new THREE.Mesh( geometry, material );
    var geometry = new THREE.BoxGeometry(2, 1, 1, 32 );
    var material = new THREE.MeshLambertMaterial( {color: 'red'} );
    line= new THREE.Mesh( geometry, material );
    line2= new THREE.Mesh( geometry, material );
    
    let leftarm = makeCymbalArm();
    stick.position.set(2*k,3,0);
    stick.rotation.z+=Math.PI*3/4;
    line.position.set(2*k,1,0);
    line.rotation.z=Math.PI/4;
    let cymbal1 = new THREE.Group();
    cymbal1.add(stick,line);
    leftarm[0].position.set (-1.88*k, 7.57*k-4.09*k, 0);
    leftarm[0].add(leftarm[1]);
    leftarm[1].add(cymbal1);
    torso.add (leftarm[0]);
    stick.castShadow = true;
    stick.receiveShadow = true;
    line.castShadow = true;
    line.receiveShadow = true;
    
    let rightarm = makeCymbalArm();
    stick2.position.set(2*k,-3,0);
    stick2.rotation.z=Math.PI/5;
    line2.position.set(2*k,-1,0);
    line2.rotation.z=-Math.PI/4;
    let cymbal2 = new THREE.Group();
    cymbal2.add(stick2,line2);
    rightarm[0].position.set (1.88*k, 7.57*k-4.09*k, 0);
    rightarm[0].add(rightarm[1]);
    rightarm[1].add(cymbal2);
    torso.add(rightarm[0]);
    stick2.castShadow = true;
    stick2.receiveShadow = true;
    line2.castShadow = true;
    line2.receiveShadow = true;
    
    
    let leftleg = makeCymbalLeg();
    leftleg[0].position.set  (-0.63*k, 4.09*k-4.09*k, 0);
    leftleg[0].add(leftleg[1]);
    torso.add(leftleg[0]);


    let rightleg = makeCymbalLeg();
    rightleg[0].position.set (0.63*k, 4.09*k-4.09*k, 0);
    rightleg[0].add(rightleg[1]);
    torso.add(rightleg[0]);

    man.rotation.y=-Math.PI/2;	
    man.position.y=0.01;
    leftarm[0].rotation.z = -Math.PI/2;
    rightarm[0].rotation.z = -Math.PI/2;
    leftleg[0].rotation.z = -Math.PI/2;
    rightleg[0].rotation.z = -Math.PI/2;
    
    leftarm[0].rotation.order = 'ZYX';
    rightarm[0].rotation.order = 'ZYX';
    leftleg[0].rotation.order = 'ZYX';
    rightleg[0].rotation.order = 'ZYX';
    man.rotation.order = 'ZYX';
    return [man,head,torso,leftarm[0],leftarm[1],rightarm[0],rightarm[1],leftleg[0],leftleg[1],rightleg[0],rightleg[1],cymbal1,cymbal2];
  }

  function makeCymbalArm() {
    var group = new THREE.Group();
    var group2 = new THREE.Group();
    body3=buildCymbalarm();
    body3.rotation.z=Math.PI/2;
    body3.position.x = 1.92*k;
    body8=buildCymbalarm2();
    body8.rotation.z=Math.PI/2;
    body8.position.x = 1.92*k;
    group2.add(body8);
    group.add (group2,body3);
    group2.position.x =2*k;
    
    
    body3.castShadow = true;
    body3.receiveShadow = true;
    body8.castShadow = true;
    body8.receiveShadow = true;

    //group.add (new THREE.AxesHelper (k));
    //group2.add (new THREE.AxesHelper (k));
    return [group,group2];
  }
  function makeCymbalLeg() {
    var group = new THREE.Group();
    var group2 = new THREE.Group();
    body7=buildCymballeg();
    body7.rotation.z=Math.PI/2;
    body7.position.x = 2.046*k;
    body8=buildCymballeg2();
    body8.rotation.z=Math.PI/2;
    body8.position.x = 2.046*k;
    group2.add(body8);
    group.add (group2,body7);
    group2.position.x =2.045*k;
    
    body7.castShadow = true;
    body7.receiveShadow = true;
    body8.castShadow = true;
    body8.receiveShadow = true;
    //group.add (new THREE.AxesHelper (k));
    //group2.add (new THREE.AxesHelper (k));
    return [group,group2];
  }
  function makeCymbalHead() {
    var headGroup = new THREE.Group();
    var mat = new THREE.MeshLambertMaterial({color:0x99d8ea});
    headBody = new THREE.Mesh (new THREE.BoxGeometry(2.52*k, 2.52*k, 2.52*k), mat);
    headBody2=buildCymbalface();
    headBody2.rotation.y=Math.PI;
    headGroup.add (headBody,headBody2);
    headBody.position.y = 2.52*k/2;
    
    headBody.castShadow = true;
    headBody.receiveShadow = true;
    //headGroup.add (new THREE.AxesHelper (k));
    return headGroup;
  }
  function makeCymbalTorso () {
    var group = new THREE.Group();
    var material = new THREE.MeshLambertMaterial( { color:0xd0d0c,side:THREE.DoubleSide } );
    Torsobody = new THREE.Mesh (new THREE.BoxGeometry(2.52*k, 3.48*k, 1.26*k), material);
    Torsobody2=buildCymbalTorso();
    Torsobody2.rotation.y=Math.PI;
    group.add (Torsobody,Torsobody2);
    Torsobody.position.y = 3.48*k/2;
    
      
    Torsobody.castShadow = true;
    Torsobody.receiveShadow = true;
    //group.add (new THREE.AxesHelper (2*k));
  return group;

  }
  function buildCymbalface() {
    let geometry = new THREE.Geometry();
    geometry.vertices.push(
      new THREE.Vector3(-2.53*k/2, 0, 2.53*k/2),
      new THREE.Vector3(2.53*k/2, 0, 2.53*k/2),
      new THREE.Vector3(2.53*k/2, 2.53*k, 2.53*k/2),
      new THREE.Vector3(-2.53*k/2, 2.53*k, 2.53*k/2),
      new THREE.Vector3(2.53*k/2, 0, -2.53*k/2),
      new THREE.Vector3(2.53*k/2, 2.53*k, -2.53*k/2),
      new THREE.Vector3(-2.53*k/2, 0, -2.53*k/2),
      new THREE.Vector3(-2.53*k/2, 2.53*k, -2.53*k/2),
    );


    let face;
    face = new THREE.Face3(0, 1, 2);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(2, 3, 0);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 4, 5);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 2, 1);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(4, 6, 7);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(7, 5, 4);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 0, 3);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 7, 6);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 2, 5);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 7, 3);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 4, 1);
    face.materialIndex = 5;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 0, 6);
    face.materialIndex = 5;
    geometry.faces.push(face);
    
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();

    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    let texture = loader.load('https://i.imgur.com/IYkzEoo.png');
    let texture1 = loader.load('https://i.imgur.com/UyF6RiR.png');
    let texture2 = loader.load('https://i.imgur.com/3vfswFa.png');
    let texture3 = loader.load('https://i.imgur.com/UQYNSe6.png');
    let texture4 = loader.load('https://i.imgur.com/TLdR62i.png');
    let texture5 = loader.load('https://i.imgur.com/E57CwUJ.png');
    materialArray = [];
    materialArray.push(new THREE.MeshLambertMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture1
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }),
      new THREE.MeshPhongMaterial({
        map: texture3
      }),
      new THREE.MeshPhongMaterial({
        map: texture4
      }),
      new THREE.MeshPhongMaterial({
        map: texture5
      }));
    return new THREE.Mesh(geometry, materialArray);
  }
  function buildCymbalTorso() {
    let geometry = new THREE.Geometry();
    geometry.vertices.push(
      new THREE.Vector3(-2.53*k/2, 0, 1.27*k/2),
      new THREE.Vector3(2.53*k/2, 0, 1.27*k/2),
      new THREE.Vector3(2.53*k/2, 3.48*k, 1.27*k/2),
      new THREE.Vector3(-2.53*k/2, 3.48*k, 1.27*k/2),
      new THREE.Vector3(2.53*k/2, 0, -1.27*k/2),
      new THREE.Vector3(2.53*k/2, 3.48*k, -1.27*k/2),
      new THREE.Vector3(-2.53*k/2, 0, -1.27*k/2),
      new THREE.Vector3(-2.53*k/2, 3.48*k, -1.27*k/2),
    );


    let face;
    face = new THREE.Face3(0, 1, 2);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(2, 3, 0);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 4, 5);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 2, 1);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(4, 6, 7);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(7, 5, 4);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 0, 3);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 7, 6);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 2, 5);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 7, 3);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 4, 1);
    face.materialIndex = 5;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 0, 6);
    face.materialIndex = 5;
    geometry.faces.push(face);
    
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();

    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    let texture = loader.load('https://i.imgur.com/Cx06iy5.png');
    let texture1 = loader.load('https://i.imgur.com/X7OW52g.png');
    let texture2 = loader.load('https://i.imgur.com/9DKgJ8s.png');
    let texture3 = loader.load('https://i.imgur.com/X7OW52g.png');
    let texture4 = loader.load('https://i.imgur.com/wXgv152.png');
    let texture5 = loader.load('https://i.imgur.com/9DKgJ8s.png');
    materialArray = [];
    materialArray.push(new THREE.MeshLambertMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture1
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }),
      new THREE.MeshPhongMaterial({
        map: texture3
      }),
      new THREE.MeshPhongMaterial({
        map: texture4
      }),
      new THREE.MeshPhongMaterial({
        map: texture5
      }));
    return new THREE.Mesh(geometry, materialArray);
  }
  function buildCymbalarm() {
    let geometry = new THREE.Geometry();
    geometry.vertices.push(
      new THREE.Vector3(-1.25*k/2, 0, 1.25*k/2),
      new THREE.Vector3(1.25*k/2, 0, 1.25*k/2),
      new THREE.Vector3(1.25*k/2, 1.93*k, 1.25*k/2),
      new THREE.Vector3(-1.25*k/2, 1.93*k, 1.25*k/2),
      new THREE.Vector3(1.25*k/2, 0, -1.25*k/2),
      new THREE.Vector3(1.25*k/2, 1.93*k, -1.25*k/2),
      new THREE.Vector3(-1.25*k/2, 0, -1.25*k/2),
      new THREE.Vector3(-1.25*k/2, 1.93*k, -1.25*k/2),
    );


    let face;
    face = new THREE.Face3(0, 1, 2);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(2, 3, 0);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 4, 5);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 2, 1);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(4, 6, 7);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(7, 5, 4);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 0, 3);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 7, 6);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 2, 5);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 7, 3);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 4, 1);
    face.materialIndex = 5;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 0, 6);
    face.materialIndex = 5;
    geometry.faces.push(face);
    
    
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();


    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    let texture = loader.load('https://i.imgur.com/Reypdny.png');
    let texture2 = loader.load('https://i.imgur.com/UHYXfSO.png');
    let texture3 = loader.load('https://i.imgur.com/zDr6SGt.png');
    materialArray = [];
    materialArray.push(new THREE.MeshLambertMaterial({
        map: texture
      }), 
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }),
      new THREE.MeshPhongMaterial({
        map: texture3
      }));
    return new THREE.Mesh(geometry, materialArray);
  }
  function buildCymbalarm2() {
    let geometry = new THREE.Geometry();
    geometry.vertices.push(
      new THREE.Vector3(-1.25*k/2, 0, 1.25*k/2),
      new THREE.Vector3(1.25*k/2, 0, 1.25*k/2),
      new THREE.Vector3(1.25*k/2, 1.93*k, 1.25*k/2),
      new THREE.Vector3(-1.25*k/2, 1.93*k, 1.25*k/2),
      new THREE.Vector3(1.25*k/2, 0, -1.25*k/2),
      new THREE.Vector3(1.25*k/2, 1.93*k, -1.25*k/2),
      new THREE.Vector3(-1.25*k/2, 0, -1.25*k/2),
      new THREE.Vector3(-1.25*k/2, 1.93*k, -1.25*k/2),
    );


    let face;
    face = new THREE.Face3(0, 1, 2);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(2, 3, 0);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 4, 5);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 2, 1);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(4, 6, 7);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(7, 5, 4);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 0, 3);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 7, 6);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 2, 5);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 7, 3);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 4, 1);
    face.materialIndex = 5;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 0, 6);
    face.materialIndex = 5;
    geometry.faces.push(face);
    
    
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();


    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    let texture = loader.load('https://i.imgur.com/iAEsM2q.png');
    let texture2 = loader.load('https://i.imgur.com/zDr6SGt.png');
    materialArray = [];
    materialArray.push(new THREE.MeshLambertMaterial({
        map: texture
      }), 
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }));
    return new THREE.Mesh(geometry, materialArray);
  }
  function buildCymballeg() {
    let geometry = new THREE.Geometry();
    geometry.vertices.push(
      new THREE.Vector3(-1.27*k/2, 0, 1.27*k/2),
      new THREE.Vector3(1.27*k/2, 0, 1.27*k/2),
      new THREE.Vector3(1.27*k/2, 2.046*k, 1.27*k/2),
      new THREE.Vector3(-1.27*k/2, 2.046*k, 1.27*k/2),
      new THREE.Vector3(1.27*k/2, 0, -1.27*k/2),
      new THREE.Vector3(1.27*k/2, 2.046*k, -1.27*k/2),
      new THREE.Vector3(-1.27*k/2, 0, -1.27*k/2),
      new THREE.Vector3(-1.27*k/2, 2.046*k, -1.27*k/2),
    );


    let face;
    face = new THREE.Face3(0, 1, 2);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(2, 3, 0);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 4, 5);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 2, 1);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(4, 6, 7);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(7, 5, 4);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 0, 3);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 7, 6);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 2, 5);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 7, 3);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 4, 1);
    face.materialIndex = 5;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 0, 6);
    face.materialIndex = 5;
    geometry.faces.push(face);
    
    
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();


    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    let texture = loader.load('https://i.imgur.com/Reypdny.png');
    let texture2 = loader.load('https://i.imgur.com/UHYXfSO.png');
    let texture3 = loader.load('https://i.imgur.com/zDr6SGt.png');
    materialArray = [];
    materialArray.push(new THREE.MeshLambertMaterial({
        map: texture
      }), 
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }),
      new THREE.MeshPhongMaterial({
        map: texture3
      }));
    return new THREE.Mesh(geometry, materialArray);
  }
  function buildCymballeg2() {
    let geometry = new THREE.Geometry();
    geometry.vertices.push(
      new THREE.Vector3(-1.27*k/2, 0, 1.27*k/2),
      new THREE.Vector3(1.27*k/2, 0, 1.27*k/2),
      new THREE.Vector3(1.27*k/2, 2.046*k, 1.27*k/2),
      new THREE.Vector3(-1.27*k/2, 2.046*k, 1.27*k/2),
      new THREE.Vector3(1.27*k/2, 0, -1.27*k/2),
      new THREE.Vector3(1.27*k/2, 2.046*k, -1.27*k/2),
      new THREE.Vector3(-1.27*k/2, 0, -1.27*k/2),
      new THREE.Vector3(-1.27*k/2, 2.046*k, -1.27*k/2),
    );


    let face;
    face = new THREE.Face3(0, 1, 2);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(2, 3, 0);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 4, 5);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 2, 1);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(4, 6, 7);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(7, 5, 4);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 0, 3);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 7, 6);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 2, 5);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 7, 3);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 4, 1);
    face.materialIndex = 5;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 0, 6);
    face.materialIndex = 5;
    geometry.faces.push(face);
    
    
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();


    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    let texture = loader.load('https://i.imgur.com/Reypdny.png');
    let texture2 = loader.load('https://i.imgur.com/zDr6SGt.png');
    materialArray = [];
    materialArray.push(new THREE.MeshLambertMaterial({
        map: texture
      }), 
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }));
    return new THREE.Mesh(geometry, materialArray);
  }

  function buildSmalldrum(){
    box = new THREE.Group();
    var geometry = new THREE.CylinderBufferGeometry(10, 10, 13.1, 32 );
    var material = new THREE.MeshLambertMaterial( {color: 'white'} );
    cylinder1 = new THREE.Mesh( geometry, material );
    cylinder1.position.set(0,-1,-2.8*k);
    var geometry = new THREE.CylinderBufferGeometry(10.1, 10.1, 13, 32 );
    var material = new THREE.MeshLambertMaterial( {color: 'blue'} );
    cylinder2 = new THREE.Mesh( geometry, material );
    cylinder2.position.set(0,-1,-2.8*k);
    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    let texture = loader.load('https://i.imgur.com/DvME6OT.jpg');
    var geometry = new THREE.TorusBufferGeometry( 10.1, 0.5, 32, 100 );
    var material = new THREE.MeshLambertMaterial( { map: texture } );
    cylinder3 = new THREE.Mesh( geometry, material );
    cylinder3.rotation.x=Math.PI/2;
    cylinder3.position.set(0,6,-2.8*k);
    cylinder4 = new THREE.Mesh( geometry, material );
    cylinder4.rotation.x=Math.PI/2;
    cylinder4.position.set(0,-8,-2.8*k);
    var geometry = new THREE.BoxBufferGeometry( 14, 1, 1 );
    var material = new THREE.MeshLambertMaterial( {map: texture } );
    BoxBuffer1= new THREE.Mesh( geometry, material );
    BoxBuffer1.rotation.z=Math.PI/2;
    BoxBuffer1.position.set(10,-1,-2.8*k);
    BoxBuffer2= new THREE.Mesh( geometry, material );
    BoxBuffer2.rotation.z=Math.PI/2;
    BoxBuffer2.position.set(7.5,-1,-4.1*k);
    BoxBuffer3= new THREE.Mesh( geometry, material );
    BoxBuffer3.rotation.z=Math.PI/2;
    BoxBuffer3.position.set(0,-1,-4.8*k);
    BoxBuffer4= new THREE.Mesh( geometry, material );
    BoxBuffer4.rotation.z=Math.PI/2;
    BoxBuffer4.position.set(-7.5,-1,-4.1*k);
    BoxBuffer5= new THREE.Mesh( geometry, material );
    BoxBuffer5.rotation.z=Math.PI/2;
    BoxBuffer5.position.set(-10,-1,-2.8*k);
    BoxBuffer6= new THREE.Mesh( geometry, material );
    BoxBuffer6.rotation.z=Math.PI/2;
    BoxBuffer6.position.set(-7.5,-1,-1.5*k);
    BoxBuffer7= new THREE.Mesh( geometry, material );
    BoxBuffer7.rotation.z=Math.PI/2;
    BoxBuffer7.position.set(0,-1,-0.8*k);
    BoxBuffer8= new THREE.Mesh( geometry, material );
    BoxBuffer8.rotation.z=Math.PI/2;
    BoxBuffer8.position.set(7.5,-1,-1.5*k);
    var material = new THREE.MeshLambertMaterial( { color: 'white',side:THREE.DoubleSide } );
    line1 = new THREE.Mesh (new THREE.BoxGeometry(25, 1,1), material); 
    line1.position.set(-1.6*k,12,-1.2*k);
    line1.rotation.set(0,-Math.PI/2.6,Math.PI/4);
    line2 = new THREE.Mesh (new THREE.BoxGeometry(25, 1, 1), material); 
    line2.position.set(1.6*k,12,-1.2*k);
    line2.rotation.set(0,Math.PI/2.6,-Math.PI/4);
    var material = new THREE.MeshLambertMaterial( { color: 'white',side:THREE.DoubleSide } );
    line3 = new THREE.Mesh (new THREE.BoxGeometry(14, 1, 1), material); 
    line3.position.set(0,17,1);
    line3.rotation.y=Math.PI;
    box.add(cylinder1,cylinder2,cylinder3,cylinder4,BoxBuffer1,BoxBuffer2,BoxBuffer3,BoxBuffer4,BoxBuffer5,BoxBuffer6,BoxBuffer7,BoxBuffer8,line1,line2,line3);
    cylinder1.castShadow = true;
    cylinder1.receiveShadow = true;
    cylinder2.castShadow = true;
    cylinder2.receiveShadow = true;
    cylinder3.castShadow = true;
    cylinder3.receiveShadow = true;
    cylinder4.castShadow = true;
    cylinder4.receiveShadow = true;
    BoxBuffer1.castShadow = true;
    BoxBuffer1.receiveShadow = true;
    BoxBuffer2.castShadow = true;
    BoxBuffer2.receiveShadow = true;
    BoxBuffer3.castShadow = true;
    BoxBuffer3.receiveShadow = true;
    BoxBuffer4.castShadow = true;
    BoxBuffer4.receiveShadow = true;
    BoxBuffer5.castShadow = true;
    BoxBuffer5.receiveShadow = true;
    BoxBuffer6.castShadow = true;
    BoxBuffer6.receiveShadow = true;
    BoxBuffer7.castShadow = true;
    BoxBuffer7.receiveShadow = true;
    BoxBuffer8.castShadow = true;
    BoxBuffer8.receiveShadow = true;
    line1.castShadow = true;
    line1.receiveShadow = true;
    line2.castShadow = true;
    line2.receiveShadow = true;
    line3.castShadow = true;
    line3.receiveShadow = true;
    return box;
    }
  function buildSmalldrumMan(){
    let man = new THREE.Group();
    //GroupA.add(mine);
    let head = makeSmalldrumHead();
    let torso = makeSmalldrumTorso();
    let drum=buildSmalldrum();
    man.add(torso);
    head.position.y = 7.57*k-4.09*k;
    torso.position.y = 4.09*k;
    torso.add(head,drum);

    let leftarm = makeSmalldrumArm();
    leftarm[0].position.set (-1.88*k, 7.57*k-4.09*k, 0);
    leftarm[0].add(leftarm[1]);
    torso.add (leftarm[0]);
    let rightarm = makeSmalldrumArm();
    rightarm[0].position.set (1.88*k, 7.57*k-4.09*k, 0);
    rightarm[0].add(rightarm[1]);
    torso.add(rightarm[0]);


    let leftleg = makeSmalldrumLeg();
    leftleg[0].position.set  (-0.63*k, 4.09*k-4.09*k, 0);
    leftleg[0].add(leftleg[1]);
    torso.add(leftleg[0]);


    let rightleg = makeSmalldrumLeg();
    rightleg[0].position.set (0.63*k, 4.09*k-4.09*k, 0);
    rightleg[0].add(rightleg[1]);
    torso.add(rightleg[0]);

    man.rotation.y=-Math.PI/2;	
    man.position.y=0.01;
    leftarm[0].rotation.z = -Math.PI/2;
    rightarm[0].rotation.z = -Math.PI/2;
    leftleg[0].rotation.z = -Math.PI/2;
    rightleg[0].rotation.z = -Math.PI/2;
    
    leftarm[0].rotation.order = 'ZYX';
    rightarm[0].rotation.order = 'ZYX';
    leftleg[0].rotation.order = 'ZYX';
    rightleg[0].rotation.order = 'ZYX';
    man.rotation.order = 'ZYX';
    return [man,head,torso,leftarm[0],leftarm[1],rightarm[0],rightarm[1],leftleg[0],leftleg[1],rightleg[0],rightleg[1],leftarm[2],rightarm[2],drum];
  }
  function makeSmalldrumArm() {
    var group = new THREE.Group();
    var group2 = new THREE.Group();
    var stick = new THREE.Group();
    var geometry = new THREE.CylinderBufferGeometry(1, 0.5, 10, 32 );
    var material = new THREE.MeshLambertMaterial( {color: 0xcc7818} );
    box= new THREE.Mesh( geometry, material );
    var geometry = new THREE.DodecahedronBufferGeometry(1,5 );
    var material = new THREE.MeshLambertMaterial( {color: 0xcc7818} );
    ball= new THREE.Mesh( geometry, material );
    body3=buildSmalldrumarm();
    body3.rotation.z=Math.PI/2;
    body3.position.x = 1.92*k;
    body6=buildSmalldrumarm2();
    body6.rotation.z=Math.PI/2;
    body6.position.x = 1.92*k;
    box.position.set(2*k,0,-5);
    box.rotation.x=Math.PI/2;
    ball.position.set(2*k,0,-10);
    stick.add(ball,box);
    group2.add(stick,body6);
    group.add (group2,body3);

    group2.position.x =2*k;
    body3.castShadow = true;
    body3.receiveShadow = true;
    body6.castShadow = true;
    body6.receiveShadow = true;
    stick.castShadow = true;
    stick.receiveShadow = true;
    //group.add (new THREE.AxesHelper (k));
    //group2.add (new THREE.AxesHelper (k));
    return [group,group2,stick];
  }
  function makeSmalldrumLeg() {
    var group = new THREE.Group();
    var group2 = new THREE.Group();
    body7=buildSmalldrumleg();
    body7.rotation.z=Math.PI/2;
    body7.position.x = 2.046*k;
    body8=buildSmalldrumleg2();
    body8.rotation.z=Math.PI/2;
    body8.position.x = 2.046*k;
    group2.add(body8);
    group.add (group2,body7);
    group2.position.x =2.045*k;
    
    body7.castShadow = true;
    body7.receiveShadow = true;
    body8.castShadow = true;
    body8.receiveShadow = true;
    //group.add (new THREE.AxesHelper (k));
    //group2.add (new THREE.AxesHelper (k));
    return [group,group2];
  }
  function makeSmalldrumHead() {
    var headGroup = new THREE.Group();
    var mat = new THREE.MeshLambertMaterial({color:0x99d8ea});
    headBody = new THREE.Mesh (new THREE.BoxGeometry(2.52*k, 2.52*k, 2.52*k), mat);
    headBody2=buildSmalldrumface();
    headBody2.rotation.y=Math.PI;
    headGroup.add (headBody,headBody2);
    headBody.position.y = 2.52*k/2;
    
    headBody.castShadow = true;
    headBody.receiveShadow = true;
    //headGroup.add (new THREE.AxesHelper (k));
    return headGroup;
  }
  function makeSmalldrumTorso () {
    var group = new THREE.Group();
    var material = new THREE.MeshLambertMaterial( { color:0xd0d0c,side:THREE.DoubleSide } );
    Torsobody = new THREE.Mesh (new THREE.BoxGeometry(2.52*k, 3.48*k, 1.26*k), material);
    Torsobody2=buildSmalldrumTorso();
    Torsobody2.rotation.y=Math.PI;
    group.add (Torsobody,Torsobody2);
    Torsobody.position.y = 3.48*k/2;
    
    Torsobody.castShadow = true;
    Torsobody.receiveShadow = true;
    //group.add (new THREE.AxesHelper (2*k));
  return group;

  }
  function buildSmalldrumface() {
    let geometry = new THREE.Geometry();
    geometry.vertices.push(
      new THREE.Vector3(-2.53*k/2, 0, 2.53*k/2),
      new THREE.Vector3(2.53*k/2, 0, 2.53*k/2),
      new THREE.Vector3(2.53*k/2, 2.53*k, 2.53*k/2),
      new THREE.Vector3(-2.53*k/2, 2.53*k, 2.53*k/2),
      new THREE.Vector3(2.53*k/2, 0, -2.53*k/2),
      new THREE.Vector3(2.53*k/2, 2.53*k, -2.53*k/2),
      new THREE.Vector3(-2.53*k/2, 0, -2.53*k/2),
      new THREE.Vector3(-2.53*k/2, 2.53*k, -2.53*k/2),
    );


    let face;
    face = new THREE.Face3(0, 1, 2);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(2, 3, 0);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 4, 5);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 2, 1);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(4, 6, 7);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(7, 5, 4);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 0, 3);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 7, 6);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 2, 5);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 7, 3);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 4, 1);
    face.materialIndex = 5;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 0, 6);
    face.materialIndex = 5;
    geometry.faces.push(face);
    
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();

    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    let texture = loader.load('https://i.imgur.com/IYkzEoo.png');
    let texture1 = loader.load('https://i.imgur.com/UyF6RiR.png');
    let texture2 = loader.load('https://i.imgur.com/3vfswFa.png');
    let texture3 = loader.load('https://i.imgur.com/UQYNSe6.png');
    let texture4 = loader.load('https://i.imgur.com/TLdR62i.png');
    let texture5 = loader.load('https://i.imgur.com/E57CwUJ.png');
    materialArray = [];
    materialArray.push(new THREE.MeshLambertMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture1
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }),
      new THREE.MeshPhongMaterial({
        map: texture3
      }),
      new THREE.MeshPhongMaterial({
        map: texture4
      }),
      new THREE.MeshPhongMaterial({
        map: texture5
      }));
    return new THREE.Mesh(geometry, materialArray);
  }
  function buildSmalldrumTorso() {
    let geometry = new THREE.Geometry();
    geometry.vertices.push(
      new THREE.Vector3(-2.53*k/2, 0, 1.27*k/2),
      new THREE.Vector3(2.53*k/2, 0, 1.27*k/2),
      new THREE.Vector3(2.53*k/2, 3.48*k, 1.27*k/2),
      new THREE.Vector3(-2.53*k/2, 3.48*k, 1.27*k/2),
      new THREE.Vector3(2.53*k/2, 0, -1.27*k/2),
      new THREE.Vector3(2.53*k/2, 3.48*k, -1.27*k/2),
      new THREE.Vector3(-2.53*k/2, 0, -1.27*k/2),
      new THREE.Vector3(-2.53*k/2, 3.48*k, -1.27*k/2),
    );


    let face;
    face = new THREE.Face3(0, 1, 2);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(2, 3, 0);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 4, 5);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 2, 1);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(4, 6, 7);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(7, 5, 4);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 0, 3);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 7, 6);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 2, 5);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 7, 3);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 4, 1);
    face.materialIndex = 5;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 0, 6);
    face.materialIndex = 5;
    geometry.faces.push(face);
    
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();

    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    let texture = loader.load('https://i.imgur.com/9dP72Qr.png');
    let texture1 = loader.load('https://i.imgur.com/aOHqblB.png');
    let texture2 = loader.load('https://i.imgur.com/8khnPtP.png');
    let texture3 = loader.load('https://i.imgur.com/aOHqblB.png');
    let texture4 = loader.load('https://i.imgur.com/zhr9X0w.png');
    let texture5 = loader.load('https://i.imgur.com/2wd7fMD.png');
    materialArray = [];
    materialArray.push(new THREE.MeshLambertMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture1
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }),
      new THREE.MeshPhongMaterial({
        map: texture3
      }),
      new THREE.MeshPhongMaterial({
        map: texture4
      }),
      new THREE.MeshPhongMaterial({
        map: texture5
      }));
    return new THREE.Mesh(geometry, materialArray);
  }
  function buildSmalldrumarm() {
    let geometry = new THREE.Geometry();
    geometry.vertices.push(
      new THREE.Vector3(-1.25*k/2, 0, 1.25*k/2),
      new THREE.Vector3(1.25*k/2, 0, 1.25*k/2),
      new THREE.Vector3(1.25*k/2, 1.93*k, 1.25*k/2),
      new THREE.Vector3(-1.25*k/2, 1.93*k, 1.25*k/2),
      new THREE.Vector3(1.25*k/2, 0, -1.25*k/2),
      new THREE.Vector3(1.25*k/2, 1.93*k, -1.25*k/2),
      new THREE.Vector3(-1.25*k/2, 0, -1.25*k/2),
      new THREE.Vector3(-1.25*k/2, 1.93*k, -1.25*k/2),
    );


    let face;
    face = new THREE.Face3(0, 1, 2);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(2, 3, 0);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 4, 5);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 2, 1);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(4, 6, 7);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(7, 5, 4);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 0, 3);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 7, 6);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 2, 5);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 7, 3);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 4, 1);
    face.materialIndex = 5;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 0, 6);
    face.materialIndex = 5;
    geometry.faces.push(face);
    
    
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();


    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    let texture = loader.load('https://i.imgur.com/aANTmBw.png');
    let texture2 = loader.load('https://i.imgur.com/APu9VDq.png');
    let texture3 = loader.load('https://i.imgur.com/zDr6SGt.png');
    materialArray = [];
    materialArray.push(new THREE.MeshLambertMaterial({
        map: texture
      }), 
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }),
      new THREE.MeshPhongMaterial({
        map: texture3
      }));
    return new THREE.Mesh(geometry, materialArray);
  }
  function buildSmalldrumarm2() {
    let geometry = new THREE.Geometry();
    geometry.vertices.push(
      new THREE.Vector3(-1.25*k/2, 0, 1.25*k/2),
      new THREE.Vector3(1.25*k/2, 0, 1.25*k/2),
      new THREE.Vector3(1.25*k/2, 1.93*k, 1.25*k/2),
      new THREE.Vector3(-1.25*k/2, 1.93*k, 1.25*k/2),
      new THREE.Vector3(1.25*k/2, 0, -1.25*k/2),
      new THREE.Vector3(1.25*k/2, 1.93*k, -1.25*k/2),
      new THREE.Vector3(-1.25*k/2, 0, -1.25*k/2),
      new THREE.Vector3(-1.25*k/2, 1.93*k, -1.25*k/2),
    );


    let face;
    face = new THREE.Face3(0, 1, 2);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(2, 3, 0);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 4, 5);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 2, 1);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(4, 6, 7);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(7, 5, 4);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 0, 3);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 7, 6);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 2, 5);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 7, 3);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 4, 1);
    face.materialIndex = 5;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 0, 6);
    face.materialIndex = 5;
    geometry.faces.push(face);
    
    
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();


    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    let texture = loader.load('https://i.imgur.com/eA5BB9i.png');
    let texture2 = loader.load('https://i.imgur.com/zDr6SGt.png');
    materialArray = [];
    materialArray.push(new THREE.MeshLambertMaterial({
        map: texture
      }), 
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }));
    return new THREE.Mesh(geometry, materialArray);
  }
  function buildSmalldrumleg() {
    let geometry = new THREE.Geometry();
    geometry.vertices.push(
      new THREE.Vector3(-1.27*k/2, 0, 1.27*k/2),
      new THREE.Vector3(1.27*k/2, 0, 1.27*k/2),
      new THREE.Vector3(1.27*k/2, 2.046*k, 1.27*k/2),
      new THREE.Vector3(-1.27*k/2, 2.046*k, 1.27*k/2),
      new THREE.Vector3(1.27*k/2, 0, -1.27*k/2),
      new THREE.Vector3(1.27*k/2, 2.046*k, -1.27*k/2),
      new THREE.Vector3(-1.27*k/2, 0, -1.27*k/2),
      new THREE.Vector3(-1.27*k/2, 2.046*k, -1.27*k/2),
    );


    let face;
    face = new THREE.Face3(0, 1, 2);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(2, 3, 0);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 4, 5);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 2, 1);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(4, 6, 7);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(7, 5, 4);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 0, 3);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 7, 6);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 2, 5);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 7, 3);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 4, 1);
    face.materialIndex = 5;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 0, 6);
    face.materialIndex = 5;
    geometry.faces.push(face);
    
    
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();


    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    let texture = loader.load('https://i.imgur.com/CZughnT.png');
    let texture2 = loader.load('https://i.imgur.com/UmnQd9g.png');
    let texture3 = loader.load('https://i.imgur.com/zDr6SGt.png');
    materialArray = [];
    materialArray.push(new THREE.MeshLambertMaterial({
        map: texture
      }), 
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }),
      new THREE.MeshPhongMaterial({
        map: texture3
      }));
    return new THREE.Mesh(geometry, materialArray);
  }
  function buildSmalldrumleg2() {
    let geometry = new THREE.Geometry();
    geometry.vertices.push(
      new THREE.Vector3(-1.27*k/2, 0, 1.27*k/2),
      new THREE.Vector3(1.27*k/2, 0, 1.27*k/2),
      new THREE.Vector3(1.27*k/2, 2.046*k, 1.27*k/2),
      new THREE.Vector3(-1.27*k/2, 2.046*k, 1.27*k/2),
      new THREE.Vector3(1.27*k/2, 0, -1.27*k/2),
      new THREE.Vector3(1.27*k/2, 2.046*k, -1.27*k/2),
      new THREE.Vector3(-1.27*k/2, 0, -1.27*k/2),
      new THREE.Vector3(-1.27*k/2, 2.046*k, -1.27*k/2),
    );


    let face;
    face = new THREE.Face3(0, 1, 2);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(2, 3, 0);
    face.materialIndex = 0;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 4, 5);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 2, 1);
    face.materialIndex = 1;
    geometry.faces.push(face);
    face = new THREE.Face3(4, 6, 7);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(7, 5, 4);
    face.materialIndex = 2;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 0, 3);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 7, 6);
    face.materialIndex = 3;
    geometry.faces.push(face);
    face = new THREE.Face3(3, 2, 5);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(5, 7, 3);
    face.materialIndex = 4;
    geometry.faces.push(face);
    face = new THREE.Face3(6, 4, 1);
    face.materialIndex = 5;
    geometry.faces.push(face);
    face = new THREE.Face3(1, 0, 6);
    face.materialIndex = 5;
    geometry.faces.push(face);
    
    
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
    geometry.faceVertexUvs[0].push([new THREE.Vector2(1, 1), new THREE.Vector2(0, 1), new THREE.Vector2(0, 0)]);
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();


    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    let texture = loader.load('https://i.imgur.com/DuEEa4x.png');
    let texture2 = loader.load('https://i.imgur.com/zDr6SGt.png');
    materialArray = [];
    materialArray.push(new THREE.MeshLambertMaterial({
        map: texture
      }), 
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }),
      new THREE.MeshPhongMaterial({
        map: texture2
      }));
    return new THREE.Mesh(geometry, materialArray);
  }

  function buildtire() {

      var loader = new THREE.TextureLoader();
      loader.crossOrigin = '';
      var colormap = loader.load ('http://jyunming-chen.github.io/tutsplus/images/tire-side.png');
      var colormap2 = loader.load ('http://jyunming-chen.github.io/tutsplus/images/tire-wheel.jpg');
      
      var tire = new THREE.Object3D();
      var geometry = new THREE.CircleGeometry(10, 30);
      var material = new THREE.MeshBasicMaterial({
          map: colormap,
        // transparent: true,  // for cut-out texture
          alphaTest: 0.5,
          side: THREE.DoubleSide
      });
      carmesh1 = new THREE.Mesh(geometry, material);
  colormap2.wrapS = colormap2.wrapT = THREE.RepeatWrapping; 
    colormap2.repeat.set( 8, 1 );
      carmesh2 = new THREE.Mesh(new THREE.CylinderGeometry(10, 10, 10, 30, 1, true), // only side
      new THREE.MeshBasicMaterial({
          map: colormap2,
          side: THREE.DoubleSide
      }));
      carmesh2.rotation.x = Math.PI / 2;
      carmesh1.position.set(0, 0, 5);
      carmesh0 = carmesh1.clone();
      carmesh0.position.set(0, 0, -5);
      carmesh0.rotation.y = Math.PI;
      tire.add (carmesh1);
      tire.add(carmesh0);
      tire.add(carmesh2);
      carmesh0.castShadow = true;
      carmesh0.receiveShadow = true;
      carmesh2.castShadow = true;
      carmesh2.receiveShadow = true;
      return tire;
  }
  function buildcar(){
    var c = new THREE.Group();
    let tire1=buildtire();
    tire1.position.set(0,10,15);
    let tire2=buildtire();
    tire2.position.set(0,10,-15);
    var material = new THREE.MeshBasicMaterial( { color:'black',side:THREE.DoubleSide } );
    let box = new THREE.Mesh (new THREE.BoxGeometry(20, 15, 2), material); 
    box.rotation.set(Math.PI/2,0,Math.PI/2);
    box.position.set(0,10,0);
    c.add(tire1,tire2,box);
    box.castShadow = true;
    box.receiveShadow = true;
    c.add (new THREE.AxesHelper (L/3));
    return c;
  }
  function buildBackground(){
    var back = new THREE.Group();
    let loader = new THREE.TextureLoader();
    loader.crossOrigin = '';
    texture = loader.load('https://i.imgur.com/WGD5Ogl.jpg');
    let floor = new THREE.Mesh(new THREE.PlaneGeometry(L, L),
    new THREE.MeshPhongMaterial({map: texture,side: THREE.DoubleSide}));
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    back.add(floor);
    let light = new THREE.SpotLight(0x888888, 1.5);
    light.position.set(0, L/2 +10, 100);
    light.angle = Math.PI/3;
    light.penumbra = 1
    back.add(light);

    light.castShadow = true;
    light.shadow.mapSize.width = 1024;
    light.shadow.mapSize.height = 1024;
    light.shadow.camera.near = 10;
    light.shadow.camera.far = 200
    light.shadow.camera.fov = light.angle / Math.PI * 180 * 2;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFShadowMap;
    return back;
  }

  function Drumkeyframe(t) {
    var s = ((t - ts) % T) / T;

    for (var i = 1; i < Drumkeys.length; i++) {
      if (Drumkeys[i][0] > s) break;
    }
    // take i-1
    var ii = i - 1;
    var a = (s - Drumkeys[ii][0]) / (Drumkeys[ii + 1][0] - Drumkeys[ii][0]);
    intKey1 = [Drumkeys[ii][1].Dtheta1 * (1 - a) + Drumkeys[ii + 1][1].Dtheta1 * a,
        Drumkeys[ii][1].Dtheta2 * (1 - a) + Drumkeys[ii + 1][1].Dtheta2 * a,
        Drumkeys[ii][1].Dtheta3 * (1 - a) + Drumkeys[ii + 1][1].Dtheta3 * a,
        Drumkeys[ii][1].Dtheta4 * (1 - a) + Drumkeys[ii + 1][1].Dtheta4 * a,
        Drumkeys[ii][1].Dtheta5 * (1 - a) + Drumkeys[ii + 1][1].Dtheta5 * a,
        Drumkeys[ii][1].Dtheta6 * (1 - a) + Drumkeys[ii + 1][1].Dtheta6 * a,
        Drumkeys[ii][1].Dtheta7 * (1 - a) + Drumkeys[ii + 1][1].Dtheta7 * a,
        Drumkeys[ii][1].Dtheta8 * (1 - a) + Drumkeys[ii + 1][1].Dtheta8 * a,
        Drumkeys[ii][1].Dtheta9 * (1 - a) + Drumkeys[ii + 1][1].Dtheta9 * a,
        Drumkeys[ii][1].Dtheta10 * (1 - a) + Drumkeys[ii + 1][1].Dtheta10 * a,
        Drumkeys[ii][1].Dtheta11 * (1 - a) + Drumkeys[ii + 1][1].Dtheta11 * a,
        Drumkeys[ii][1].Dtheta12 * (1 - a) + Drumkeys[ii + 1][1].Dtheta12 * a
    ];

  }
  function Cymbalkeyframe(t) {
    var s = ((t - ts) % T) / T;

    for (var i = 1; i < Cymbalkeys.length; i++) {
      if (Cymbalkeys[i][0] > s) break;
    }
    // take i-1
    var ii = i - 1;
    var a = (s - Cymbalkeys[ii][0]) / (Cymbalkeys[ii + 1][0] - Cymbalkeys[ii][0]);
    intKey2 = [Cymbalkeys[ii][1].Ctheta1 * (1 - a) + Cymbalkeys[ii + 1][1].Ctheta1 * a,
        Cymbalkeys[ii][1].Ctheta2 * (1 - a) + Cymbalkeys[ii + 1][1].Ctheta2 * a,
        Cymbalkeys[ii][1].Ctheta3 * (1 - a) + Cymbalkeys[ii + 1][1].Ctheta3 * a,
        Cymbalkeys[ii][1].Ctheta4 * (1 - a) + Cymbalkeys[ii + 1][1].Ctheta4 * a,
        Cymbalkeys[ii][1].Ctheta5 * (1 - a) + Cymbalkeys[ii + 1][1].Ctheta5 * a,
        Cymbalkeys[ii][1].Ctheta6 * (1 - a) + Cymbalkeys[ii + 1][1].Ctheta6 * a,
        Cymbalkeys[ii][1].Ctheta7 * (1 - a) + Cymbalkeys[ii + 1][1].Ctheta7 * a,
        Cymbalkeys[ii][1].Ctheta8 * (1 - a) + Cymbalkeys[ii + 1][1].Ctheta8 * a,
        Cymbalkeys[ii][1].Ctheta9 * (1 - a) + Cymbalkeys[ii + 1][1].Ctheta9 * a,
        Cymbalkeys[ii][1].Ctheta10 * (1 - a) + Cymbalkeys[ii + 1][1].Ctheta10 * a,
        Cymbalkeys[ii][1].Ctheta11 * (1 - a) + Cymbalkeys[ii + 1][1].Ctheta11 * a,
        Cymbalkeys[ii][1].Ctheta12 * (1 - a) + Cymbalkeys[ii + 1][1].Ctheta12 * a
    ];

  }
  function Smallkeyframe(t) {
    var s = ((t - ts) % T) / T;

    for (var i = 1; i < Smallkeys.length; i++) {
      if (Smallkeys[i][0] > s) break;
    }
    // take i-1
    var ii = i - 1;
    var a = (s - Smallkeys[ii][0]) / (Smallkeys[ii + 1][0] - Smallkeys[ii][0]);
    intKey3 = [Smallkeys[ii][1].Stheta1 * (1 - a) + Smallkeys[ii + 1][1].Stheta1 * a,
              Smallkeys[ii][1].Stheta2 * (1 - a) + Smallkeys[ii + 1][1].Stheta2 * a,
              Smallkeys[ii][1].Stheta3 * (1 - a) + Smallkeys[ii + 1][1].Stheta3 * a,
              Smallkeys[ii][1].Stheta4 * (1 - a) + Smallkeys[ii + 1][1].Stheta4 * a,
              Smallkeys[ii][1].Stheta5 * (1 - a) + Smallkeys[ii + 1][1].Stheta5 * a,
              Smallkeys[ii][1].Stheta6 * (1 - a) + Smallkeys[ii + 1][1].Stheta6 * a,
              Smallkeys[ii][1].Stheta7 * (1 - a) + Smallkeys[ii + 1][1].Stheta7 * a,
              Smallkeys[ii][1].Stheta8 * (1 - a) + Smallkeys[ii + 1][1].Stheta8 * a,
              Smallkeys[ii][1].Stheta9 * (1 - a) + Smallkeys[ii + 1][1].Stheta9 * a,
              Smallkeys[ii][1].Stheta10 * (1 - a) + Smallkeys[ii + 1][1].Stheta10 * a,
              Smallkeys[ii][1].Stheta11 * (1 - a) + Smallkeys[ii + 1][1].Stheta11 * a,
              Smallkeys[ii][1].Stheta12 * (1 - a) + Smallkeys[ii + 1][1].Stheta12 * a,
              Smallkeys[ii][1].Stheta13 * (1 - a) + Smallkeys[ii + 1][1].Stheta13 * a,
              Smallkeys[ii][1].Stheta14 * (1 - a) + Smallkeys[ii + 1][1].Stheta14 * a
    ];

  }

  function searchFace () {
    var maxDot = -1;
    
    var normals = {B: new THREE.Vector3(1,0,0), E: new THREE.Vector3(0,1,0),A: new THREE.Vector3(0,0,1),D: new THREE.Vector3(-1,0,0), F: new THREE.Vector3(0,-1,0), C: new THREE.Vector3(0,0,-1)};
    var centers = {B: new THREE.Vector3(L/2,0,0), E: new THREE.Vector3(0,L/2,0), A: new THREE.Vector3(0,0,L/2),D: new THREE.Vector3(-L/2,0,0), F: new THREE.Vector3(0,-L/2,0), C: new THREE.Vector3(0,0,-L/2)};
    
    let dd, point;
    point = camera.position.clone().sub (centers['B']).normalize();
    if ((dd = normals['B'].dot (point)) > maxDot) {
      maxDot = dd;
      which = 'B';
    }
    point = camera.position.clone().sub (centers['E']).normalize();
    if ((dd = normals['E'].dot (point)) > maxDot) {
      maxDot = dd;
      which = 'E';
    }
    point = camera.position.clone().sub (centers['A']).normalize();
    if ((dd = normals['A'].dot (point)) > maxDot) {
      maxDot = dd;
      which = 'A';
    }
    point = camera.position.clone().sub (centers['D']).normalize();
    if ((dd = normals['D'].dot (point)) > maxDot) {
      maxDot = dd;
      which = 'D';
    }
    point = camera.position.clone().sub (centers['F']).normalize();
    if ((dd = normals['F'].dot (point)) > maxDot) {
      maxDot = dd;
      which = 'F';
    }
    point = camera.position.clone().sub (centers['C']).normalize();
    if ((dd = normals['C'].dot (point)) > maxDot) {
      maxDot = dd;
      which = 'C';
    }
    return which;
  }

  function setAllFacesTransparent () {
    if(GroupA.children[0].position.x<L/2&&GroupA.children[0].position.x>-L/2&&GroupA.children[0].position.z<L/2&&GroupA.children[0].position.z>-L/2&&GroupA.children[0].position.y==0){
      faces['B'].visible = false;
      faces['E'].visible = false;
      faces['A'].visible = true;
      faces['D'].visible = false;
      faces['F'].visible = false;
      faces['C'].visible = false;
    }
    if(GroupA.children[0].position.y<0&&GroupA.children[0].position.y>-L&&GroupA.children[0].position.z<L/2&&GroupA.children[0].position.z>-L/2&&GroupA.children[0].position.x==L/2){
      faces['B'].visible = true;
      faces['E'].visible = false;
      faces['A'].visible = false;
      faces['D'].visible = false;
      faces['F'].visible = false;
      faces['C'].visible = false;
    }
    if(GroupA.children[0].position.x<L/2&&GroupA.children[0].position.x>-L/2&&GroupA.children[0].position.z<L/2&&GroupA.children[0].position.z>-L/2&&GroupA.children[0].position.y==-L){
      faces['B'].visible = false;
      faces['E'].visible = false;
      faces['A'].visible = false;
      faces['D'].visible = false;
      faces['F'].visible = false;
      faces['C'].visible = true;
    }
    if(GroupA.children[0].position.y<0&&GroupA.children[0].position.y>-L&&GroupA.children[0].position.z<L/2&&GroupA.children[0].position.z>-L/2&&GroupA.children[0].position.x==-L/2){
      faces['B'].visible = false;
      faces['E'].visible = false;
      faces['A'].visible = false;
      faces['D'].visible = true;
      faces['F'].visible = false;
      faces['C'].visible = false;
    }
    if(GroupA.children[0].position.y<0&&GroupA.children[0].position.y>-L&&GroupA.children[0].position.x<L/2&&GroupA.children[0].position.x>-L/2&&GroupA.children[0].position.z==-L/2){
      faces['B'].visible = false;
      faces['E'].visible = true;
      faces['A'].visible = false;
      faces['D'].visible = false;
      faces['F'].visible = false;
      faces['C'].visible = false;
    }
    if(GroupA.children[0].position.y<0&&GroupA.children[0].position.y>-L&&GroupA.children[0].position.x<L/2&&GroupA.children[0].position.x>-L/2&&GroupA.children[0].position.z==L/2){
      faces['B'].visible = false;
      faces['E'].visible = false;
      faces['A'].visible = false;
      faces['D'].visible = false;
      faces['F'].visible = true;
      faces['C'].visible = false;
    }
  }
  function animate() {
    controls.update();
    var dt = clock.getDelta();
    // car update
    //setAllFacesTransparent();
    // go through all faces, determine which one facing camera
    let which = searchFace();
      var timeFromStart = clock.getElapsedTime();
    var eT = (timeFromStart - lastChangeTime ).toFixed(0);
    var output = `${keyNow} : ${eT}`;
    
    $('#output').text (output);
      
    if (keyNow != undefined && keyNow !== which) {
      keyNow=which;
      lastChangeTime =  timeFromStart;
    }
    
    //GroupF.children[0].position.copy (new THREE.Vector3(0,0, 0));
    //GroupB.children[0].rotation.copy(new THREE.Euler (-Math.PI/2, Math.PI, 0, 'ZYX'));
    if(GroupA.children[0].position.distanceTo(GroupA.children[1].position)<=5){
    people[0][11].visible = true;
    people[0][12].visible = true;
    GroupA.children[2].visible = true;
    Drumkeyframe(clock.getElapsedTime());   
    people[0][3].rotation.y = intKey1[0];//gcontrol.theta1;
    people[0][4].rotation.y = intKey1[1];//gcontrol.theta2;
    people[0][5].rotation.y = intKey1[2];//gcontrol.theta3;
    people[0][6].rotation.y = intKey1[3];//gcontrol.theta4;
    people[0][7].rotation.y = intKey1[4];//gcontrol.theta5;
    people[0][8].rotation.y = intKey1[5];//gcontrol.theta6;
    people[0][9].rotation.y =intKey1[6];//gcontrol.theta7;
    people[0][10].rotation.y =intKey1[7];//gcontrol.theta8;
    people[0][1].rotation.y= intKey1[8];//gcontrol.theta9;
    people[0][2].rotation.y = intKey1[9];//gcontrol.theta10;
    people[0][4].rotation.z = intKey1[10];//gcontrol.theta11;
    people[0][6].rotation.z = intKey1[11];//gcontrol.theta12;
    }
    else{
      people[0][11].visible = false;
      people[0][12].visible = false;
      GroupA.children[2].visible = false;
      people[0][3].rotation.y = 0;//gcontrol.theta1;
      people[0][4].rotation.y = 0;//gcontrol.theta2;
      people[0][5].rotation.y = 0;//gcontrol.theta3;
      people[0][6].rotation.y = 0;//gcontrol.theta4;
      people[0][7].rotation.y = 0;//gcontrol.theta5;
      people[0][8].rotation.y = 0;//gcontrol.theta6;
      people[0][9].rotation.y = 0;//gcontrol.theta7;
      people[0][10].rotation.y = 0;//gcontrol.theta8;
      people[0][1].rotation.y = 0;//gcontrol.theta9;
      people[0][2].rotation.y = 0;//gcontrol.theta10;
      people[0][4].rotation.z = 0;//gcontrol.theta11;
      people[0][6].rotation.z = 0;//gcontrol.theta12;
    }
    if(GroupB.children[0].position.distanceTo(GroupB.children[1].position)<=5){
    people[1][11].visible = true;
    people[1][12].visible = true;
    Cymbalkeyframe(clock.getElapsedTime()); 
    people[1][3].rotation.y =intKey2[0];// gcontrol.theta1;
    people[1][4].rotation.y =intKey2[1];// gcontrol.theta2;
    people[1][5].rotation.y = intKey2[2];// gcontrol.theta3;
    people[1][6].rotation.y =intKey2[3];// gcontrol.theta4;
    people[1][7].rotation.y = intKey2[4];// gcontrol.theta5;
    people[1][8].rotation.y = intKey2[5];// gcontrol.theta6;
    people[1][9].rotation.y =intKey2[6];// gcontrol.theta7;
    people[1][10].rotation.y =intKey2[7];// gcontrol.theta8;
    people[1][1].rotation.x= intKey2[8];// gcontrol.theta9;
    people[1][2].rotation.y = intKey2[9];// gcontrol.theta10;
    people[1][4].rotation.z = intKey2[10];// gcontrol.theta11;
    people[1][6].rotation.z = intKey2[11];// gcontrol.theta12;
    /////////////////////////////////
    }
    else {
      people[1][11].visible = false;
      people[1][12].visible = false;
      people[1][3].rotation.y =0;// gcontrol.theta1;
      people[1][4].rotation.y =0;// gcontrol.theta2;
      people[1][5].rotation.y = 0;// gcontrol.theta3;
      people[1][6].rotation.y =0;// gcontrol.theta4;
      people[1][7].rotation.y = 0;// gcontrol.theta5;
      people[1][8].rotation.y = 0;// gcontrol.theta6;
      people[1][9].rotation.y =0;// gcontrol.theta7;
      people[1][10].rotation.y =0;// gcontrol.theta8;
      people[1][1].rotation.x= 0;// gcontrol.theta9;
      people[1][2].rotation.y = 0;// gcontrol.theta10;
      people[1][4].rotation.z = 0;// gcontrol.theta11;
      people[1][6].rotation.z = 0;// gcontrol.theta12;
    }
    
    if(GroupC.children[0].position.distanceTo(GroupC.children[1].position)<=5){
    people[2][11].visible = true;
    people[2][12].visible = true;
    people[2][13].visible = true;
    Smallkeyframe(clock.getElapsedTime());   
    people[2][3].rotation.y = intKey3[0];//gcontrol.theta1;
    people[2][4].rotation.y = intKey3[1];//gcontrol.theta2;
    people[2][5].rotation.y = intKey3[2];//gcontrol.theta3;
    people[2][6].rotation.y = intKey3[3];//gcontrol.theta4;
    people[2][7].rotation.y = intKey3[4];//gcontrol.theta5;
    people[2][8].rotation.y = intKey3[5];//gcontrol.theta6;
    people[2][9].rotation.y = intKey3[6];//gcontrol.theta7;
    people[2][10].rotation.y =intKey3[7];//gcontrol.theta8;
    people[2][1].rotation.y = intKey3[8];//gcontrol.theta9;
    people[2][2].rotation.y = intKey3[9];//gcontrol.theta10;
    people[2][3].rotation.z = intKey3[10];//gcontrol.theta11;
    people[2][5].rotation.z = intKey3[11];//gcontrol.theta12;
    people[2][4].rotation.x = intKey3[12];//gcontrol.theta13;
    people[2][6].rotation.x = intKey3[13];//gcontrol.theta14;
    }
    else{
      people[2][11].visible = false;
      people[2][12].visible = false;
      people[2][13].visible = false;
      people[2][3].rotation.y = 0;
      people[2][4].rotation.y = 0;
      people[2][5].rotation.y = 0;
      people[2][6].rotation.y = 0;
      people[2][7].rotation.y = 0;
      people[2][8].rotation.y = 0;
      people[2][9].rotation.y = 0;
      people[2][10].rotation.y = 0;
      people[2][1].rotation.y = 0;
      people[2][2].rotation.y = 0;
      people[2][3].rotation.z = -Math.PI/2;
      people[2][5].rotation.z = -Math.PI/2;
      people[2][4].rotation.x = 0;
      people[2][6].rotation.x = 0;
    }
    
    if (eT==3&&which == 'B'&&manIn=='A') {  // Px2Pz
      //currentPlane = 'A';
      //nextPlane = 'B';
        pos1[0] = new THREE.Vector3(0, 0, 0);  // starting pos
        euler1[0] = new THREE.Euler (0, 0, 0, 'ZYX');// starting orientation
        euler2[0] = new THREE.Euler (0, 0, -Math.PI/2,'ZYX');

        pos1[1] = new THREE.Vector3(0,-L/2, L/2);
        euler1[1] = new THREE.Euler (Math.PI/2, 0, Math.PI/2, 'ZYX');
        euler2[1] = new THREE.Euler (0, Math.PI/2, 0,'ZYX');

        pos1[2] = new THREE.Vector3(0,-L, 0);
        euler1[2] = new THREE.Euler (Math.PI, 0, 0, 'ZYX');
        euler2[2] = new THREE.Euler (0, Math.PI, -Math.PI/2,'ZYX');

        pos1[3] = new THREE.Vector3(0,-L/2, L/2);
        euler1[3] = new THREE.Euler (Math.PI/2, 0, -Math.PI/2, 'ZYX');
        euler2[3] = new THREE.Euler (0, Math.PI/2, Math.PI,'ZYX');

        pos1[4] = new THREE.Vector3(0,-L/2, L/2);
        euler1[4] = new THREE.Euler (Math.PI/2, 0, 0, 'ZYX');
        euler2[4] = new THREE.Euler (0, Math.PI/2, -Math.PI/2,'ZYX');

        pos1[5] = new THREE.Vector3(0,-L/2, -L/2);
        euler1[5] = new THREE.Euler (-Math.PI/2, 0, 0, 'ZYX');
        euler2[5] = new THREE.Euler (0, -Math.PI/2, -Math.PI/2,'ZYX');

        GroupA.children[0].position.copy (pos1[0]);
        GroupA.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,0, 'ZYX'));
        GroupB.children[0].position.copy (pos1[1]);
        GroupB.children[0].rotation.copy (new THREE.Euler (-Math.PI/2, Math.PI, 0, 'ZYX'));
        GroupC.children[0].position.copy (pos1[2]);
        GroupC.children[0].rotation.copy (new THREE.Euler (0, -Math.PI/2, Math.PI, 'ZYX'));
        GroupD.children[0].position.copy (pos1[3]);
        GroupD.children[0].rotation.copy (new THREE.Euler (Math.PI/2, 0, 0, 'ZYX'));
        GroupE.children[0].position.copy (pos1[4]);
        GroupE.children[0].rotation.copy (new THREE.Euler (Math.PI/2,0, Math.PI/2, 'ZYX'));
        GroupF.children[0].position.copy (pos1[5]);
        GroupF.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0, -Math.PI/2, 'ZYX'));
        turning = 0; //not yet turning	
        manIn ='B';
        moving = 'AtoB';
      }
    if (eT==3&&which == 'E'&&manIn=='A') {  // Px2Pz
      //currentPlane = 'A';
      //nextPlane = 'E';
        pos1[0] = new THREE.Vector3(0,0, 0);
        euler1[0] = new THREE.Euler (0, Math.PI/2, 0, 'ZYX');
        euler2[0] = new THREE.Euler (-Math.PI/2,0, -Math.PI/2, 'ZYX');

        pos1[1] = new THREE.Vector3(0,- L/2, L/2);
        euler1[1] = new THREE.Euler (-Math.PI/2, Math.PI, 0, 'ZYX');
        euler2[1] = new THREE.Euler (0, Math.PI/2, Math.PI/2, 'ZYX');

        pos1[2] = new THREE.Vector3(0,-L, 0);
        euler1[2] = new THREE.Euler (0, -Math.PI/2, Math.PI, 'ZYX');
        euler2[2] = new THREE.Euler (Math.PI/2, 0, Math.PI/2, 'ZYX');

        pos1[3] = new THREE.Vector3(0,-L/2, L/2);
        euler1[3] = new THREE.Euler (Math.PI/2, 0, 0, 'ZYX');
        euler2[3] = new THREE.Euler (0, Math.PI/2, -Math.PI/2, 'ZYX');

        pos1[4] = new THREE.Vector3(0,-L/2, L/2);
        euler1[4] = new THREE.Euler (Math.PI/2,0, Math.PI/2, 'ZYX');
        euler2[4] = new THREE.Euler (0,Math.PI/2, 0, 'ZYX');

        pos1[5] = new THREE.Vector3(0,-L/2, -L/2);
        euler1[5] = new THREE.Euler (-Math.PI/2,0, -Math.PI/2, 'ZYX');
        euler2[5] = new THREE.Euler (0,-Math.PI/2, Math.PI, 'ZYX');

        GroupA.children[0].position.copy (pos1[0]);
        GroupA.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,0, 'ZYX'));
        GroupB.children[0].position.copy (pos1[1]);
        GroupB.children[0].rotation.copy (new THREE.Euler (-Math.PI/2, Math.PI, 0, 'ZYX'));
        GroupC.children[0].position.copy (pos1[2]);
        GroupC.children[0].rotation.copy (new THREE.Euler (0, -Math.PI/2, Math.PI, 'ZYX'));
        GroupD.children[0].position.copy (pos1[3]);
        GroupD.children[0].rotation.copy (new THREE.Euler (Math.PI/2, 0, 0, 'ZYX'));
        GroupE.children[0].position.copy (pos1[4]);
        GroupE.children[0].rotation.copy (new THREE.Euler (Math.PI/2,0, Math.PI/2, 'ZYX'));
        GroupF.children[0].position.copy (pos1[5]);
        GroupF.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0, -Math.PI/2, 'ZYX'));
        turning = 0; //not yet turning		
        manIn = 'E';
        moving = 'AtoE';
      }
    if (eT==3&&which == 'D'&&manIn=='A') {  // Px2Pz
      //currentPlane = 'A';
      //nextPlane = 'D';
        pos1[0] = new THREE.Vector3(0, 0, 0);
        euler1[0] = new THREE.Euler (0,Math.PI,0, 'ZYX');
        euler2[0] = new THREE.Euler (0,Math.PI,Math.PI/2,'ZYX');

        pos1[1] = new THREE.Vector3(0,-L/2, L/2);
        euler1[1] = new THREE.Euler (Math.PI/2, 0, -Math.PI/2, 'ZYX');
        euler2[1] = new THREE.Euler (0, Math.PI/2, Math.PI,'ZYX');

        pos1[2] = new THREE.Vector3(0,-L, 0);
        euler1[2] = new THREE.Euler (0, 0, Math.PI, 'ZYX');
        euler2[2] = new THREE.Euler (0, 0, Math.PI/2,'ZYX');

        pos1[3] = new THREE.Vector3(0,-L/2, L/2);
        euler1[3] = new THREE.Euler (Math.PI/2, 0, Math.PI/2, 'ZYX');
        euler2[3] = new THREE.Euler (0, Math.PI/2, 0,'ZYX');

        pos1[4] = new THREE.Vector3(0,-L/2, L/2);
        euler1[4] = new THREE.Euler (-Math.PI/2, Math.PI, 0, 'ZYX');
        euler2[4] = new THREE.Euler (0, Math.PI/2, Math.PI/2,'ZYX');

        pos1[5] = new THREE.Vector3(0,-L/2, -L/2);
        euler1[5] = new THREE.Euler (Math.PI/2, Math.PI, 0, 'ZYX');
        euler2[5] = new THREE.Euler (0, -Math.PI/2, Math.PI/2,'ZYX');

        GroupA.children[0].position.copy (pos1[0]);
        GroupA.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,0, 'ZYX'));
        GroupB.children[0].position.copy (pos1[1]);
        GroupB.children[0].rotation.copy (new THREE.Euler (-Math.PI/2, Math.PI, 0, 'ZYX'));
        GroupC.children[0].position.copy (pos1[2]);
        GroupC.children[0].rotation.copy (new THREE.Euler (0, -Math.PI/2, Math.PI, 'ZYX'));
        GroupD.children[0].position.copy (pos1[3]);
        GroupD.children[0].rotation.copy (new THREE.Euler (Math.PI/2, 0, 0, 'ZYX'));
        GroupE.children[0].position.copy (pos1[4]);
        GroupE.children[0].rotation.copy (new THREE.Euler (Math.PI/2,0, Math.PI/2, 'ZYX'));
        GroupF.children[0].position.copy (pos1[5]);
        GroupF.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0, -Math.PI/2, 'ZYX'));
        turning = 0; //not yet turning		
        manIn = 'D';
        moving = 'AtoD';
      }
    if (eT==3&&which == 'F'&&manIn=='A') {  // Px2Pz
      //currentPlane = 'A';
      //nextPlane = 'F';
        pos1[0] = new THREE.Vector3(0, 0, 0);
        euler1[0] = new THREE.Euler (0, -Math.PI/2, 0, 'ZYX');
        euler2[0] = new THREE.Euler (Math.PI/2, 0, -Math.PI/2,'ZYX');

        pos1[1] = new THREE.Vector3(0,-L/2, L/2);
        euler1[1] = new THREE.Euler (Math.PI/2, 0, 0, 'ZYX');
        euler2[1] = new THREE.Euler (0, Math.PI/2, -Math.PI/2,'ZYX');

        pos1[2] = new THREE.Vector3(0,-L, 0);
        euler1[2] = new THREE.Euler (0, Math.PI/2, -Math.PI, 'ZYX');
        euler2[2] = new THREE.Euler (-Math.PI/2, 0, Math.PI/2,'ZYX');

        pos1[3] = new THREE.Vector3(0,-L/2, L/2);
        euler1[3] = new THREE.Euler (-Math.PI/2, Math.PI, 0, 'ZYX');
        euler2[3] = new THREE.Euler (0, Math.PI/2, Math.PI/2,'ZYX');

        pos1[4] = new THREE.Vector3(0,-L/2, L/2);
        euler1[4] = new THREE.Euler (Math.PI/2, 0, -Math.PI/2, 'ZYX');
        euler2[4] = new THREE.Euler (0, Math.PI/2, Math.PI,'ZYX');

        pos1[5] = new THREE.Vector3(0,-L/2, -L/2);
        euler1[5] = new THREE.Euler (-Math.PI/2, 0, Math.PI/2, 'ZYX');
        euler2[5] = new THREE.Euler (0, -Math.PI/2, 0,'ZYX');

        GroupA.children[0].position.copy (pos1[0]);
        GroupA.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,0, 'ZYX'));
        GroupB.children[0].position.copy (pos1[1]);
        GroupB.children[0].rotation.copy (new THREE.Euler (-Math.PI/2, Math.PI, 0, 'ZYX'));
        GroupC.children[0].position.copy (pos1[2]);
        GroupC.children[0].rotation.copy (new THREE.Euler (0, -Math.PI/2, Math.PI, 'ZYX'));
        GroupD.children[0].position.copy (pos1[3]);
        GroupD.children[0].rotation.copy (new THREE.Euler (Math.PI/2, 0, 0, 'ZYX'));
        GroupE.children[0].position.copy (pos1[4]);
        GroupE.children[0].rotation.copy (new THREE.Euler (Math.PI/2,0, Math.PI/2, 'ZYX'));
        GroupF.children[0].position.copy (pos1[5]);
        GroupF.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0, -Math.PI/2, 'ZYX'));
        turning = 0; //not yet turning	
        manIn = 'F';
        moving = 'AtoF';
      }
    /////////////
    if (eT==3&&which == 'C'&&manIn=='B') {  // Px2Pz
      //currentPlane = 'B';
      //nextPlane = 'C';
        pos1[0] = new THREE.Vector3(L/2, -L/2, 0);
        euler1[0] = new THREE.Euler (0, 0, -Math.PI/2, 'ZYX'); 
        euler2[0] = new THREE.Euler (0, 0, -Math.PI, 'ZYX');

        pos1[1] = new THREE.Vector3(0,0, 0);
        euler1[1] = new THREE.Euler (0, Math.PI/2, 0, 'ZYX');
        euler2[1] = new THREE.Euler (-Math.PI/2, 0, -Math.PI/2,'ZYX');

        pos1[2] = new THREE.Vector3(L/2,-L/2, 0);
        euler1[2] = new THREE.Euler (0, Math.PI, -Math.PI/2, 'ZYX');
        euler2[2] = new THREE.Euler (0, Math.PI, 0,'ZYX');

        pos1[3] = new THREE.Vector3(0,-L, 0);
        euler1[3] = new THREE.Euler (0, Math.PI/2, Math.PI, 'ZYX');
        euler2[3] = new THREE.Euler (-Math.PI/2, 0, Math.PI/2,'ZYX');

        pos1[4] = new THREE.Vector3(L/2,-L/2, 0);
        euler1[4] = new THREE.Euler (0, Math.PI/2, -Math.PI/2, 'ZYX');
        euler2[4] = new THREE.Euler (Math.PI/2, Math.PI, 0,'ZYX');

        pos1[5] = new THREE.Vector3(L/2,-L/2, 0);
        euler1[5] = new THREE.Euler (0, -Math.PI/2, -Math.PI/2, 'ZYX');
        euler2[5] = new THREE.Euler (-Math.PI/2, Math.PI, 0,'ZYX');

        GroupA.children[0].position.copy (pos1[0]);
        GroupA.children[0].rotation.copy (new THREE.Euler (0, Math.PI/2, -Math.PI/2, 'ZYX'));
        GroupB.children[0].position.copy (pos1[1]);
        GroupB.children[0].rotation.copy (new THREE.Euler (0, Math.PI,0, 'ZYX'));
        GroupC.children[0].position.copy (pos1[2]);
        GroupC.children[0].rotation.copy (new THREE.Euler (0, -Math.PI/2, -Math.PI/2, 'ZYX'));
        GroupD.children[0].position.copy (pos1[3]);
        GroupD.children[0].rotation.copy (new THREE.Euler (0, Math.PI, Math.PI, 'ZYX'));
        GroupE.children[0].position.copy (pos1[4]);
        GroupE.children[0].rotation.copy (new THREE.Euler (0, Math.PI, -Math.PI/2, 'ZYX'));
        GroupF.children[0].position.copy (pos1[5]);
        GroupF.children[0].rotation.copy (new THREE.Euler (0,0, -Math.PI/2, 'ZYX'));

        turning = 0; //not yet turning	
        manIn = 'C';
        moving = 'BtoC';
      }
    if (eT==3&&which == 'E'&&manIn=='B') {  // Px2Pz
      //currentPlane = 'B';
      //nextPlane = 'E';
        pos1[0] = new THREE.Vector3(L/2, -L/2, 0);
        euler1[0] = new THREE.Euler (0, Math.PI/2, -Math.PI/2, 'ZYX');
        euler2[0] = new THREE.Euler (-Math.PI/2, 0, Math.PI, 'ZYX');

        pos1[1] = new THREE.Vector3(0, 0, 0);
        euler1[1] = new THREE.Euler (0, Math.PI,0, 'ZYX');
        euler2[1] = new THREE.Euler (0,Math.PI, Math.PI/2, 'ZYX');

        pos1[2] = new THREE.Vector3(L/2, -L/2, 0);
        euler1[2] = new THREE.Euler (0, -Math.PI/2, -Math.PI/2, 'ZYX');
        euler2[2] = new THREE.Euler (Math.PI/2, 0, Math.PI, 'ZYX');

        pos1[3] = new THREE.Vector3(0,-L, 0);
        euler1[3] = new THREE.Euler (0, Math.PI, Math.PI, 'ZYX');
        euler2[3] = new THREE.Euler (0, Math.PI, -Math.PI/2, 'ZYX');

        pos1[4] = new THREE.Vector3(L/2,-L/2, 0);
        euler1[4] = new THREE.Euler (0, Math.PI, -Math.PI/2, 'ZYX');
        euler2[4] = new THREE.Euler (0, Math.PI, 0, 'ZYX');

        pos1[5] = new THREE.Vector3(L/2,-L/2, 0);
        euler1[5] = new THREE.Euler (0,0, -Math.PI/2, 'ZYX');
        euler2[5] = new THREE.Euler (0,0, -Math.PI, 'ZYX');

        GroupA.children[0].position.copy (pos1[0]);
        GroupA.children[0].rotation.copy (new THREE.Euler (0, Math.PI/2, -Math.PI/2, 'ZYX'));
        GroupB.children[0].position.copy (pos1[1]);
        GroupB.children[0].rotation.copy (new THREE.Euler (0, Math.PI,0, 'ZYX'));
        GroupC.children[0].position.copy (pos1[2]);
        GroupC.children[0].rotation.copy (new THREE.Euler (0, -Math.PI/2, -Math.PI/2, 'ZYX'));
        GroupD.children[0].position.copy (pos1[3]);
        GroupD.children[0].rotation.copy (new THREE.Euler (0, Math.PI, Math.PI, 'ZYX'));
        GroupE.children[0].position.copy (pos1[4]);
        GroupE.children[0].rotation.copy (new THREE.Euler (0, Math.PI, -Math.PI/2, 'ZYX'));
        GroupF.children[0].position.copy (pos1[5]);
        GroupF.children[0].rotation.copy (new THREE.Euler (0,0, -Math.PI/2, 'ZYX'));
        turning = 0; //not yet turning		
        moving = 'BtoE';
        manIn = 'E';
      }
    if (eT==3&&which == 'A'&&manIn=='B') {  // Px2Pz
      //currentPlane = 'B';
      //nextPlane = 'A';
        pos1[0] = new THREE.Vector3(L/2, -L/2, 0);
        euler1[0] = new THREE.Euler (0,Math.PI, -Math.PI/2, 'ZYX');
        euler2[0] = new THREE.Euler (0,Math.PI, 0, 'ZYX');

        pos1[1] = new THREE.Vector3(0, 0, 0);
        euler1[1] = new THREE.Euler (0,-Math.PI/2, 0, 'ZYX');
        euler2[1] = new THREE.Euler (Math.PI/2,0, -Math.PI/2, 'ZYX');

        pos1[2] = new THREE.Vector3(L/2, -L/2, 0);
        euler1[2] = new THREE.Euler (0, 0, -Math.PI/2, 'ZYX');
        euler2[2] = new THREE.Euler (0, 0, -Math.PI, 'ZYX');

        pos1[3] = new THREE.Vector3(0,-L, 0);
        euler1[3] = new THREE.Euler (0, -Math.PI/2, Math.PI, 'ZYX');
        euler2[3] = new THREE.Euler (Math.PI/2, 0, Math.PI/2, 'ZYX');

        pos1[4] = new THREE.Vector3(L/2,-L/2, 0);
        euler1[4] = new THREE.Euler (0, -Math.PI/2, -Math.PI/2, 'ZYX');
        euler2[4] = new THREE.Euler (Math.PI/2, 0, -Math.PI, 'ZYX');

        pos1[5] = new THREE.Vector3(L/2,-L/2, 0);
        euler1[5] = new THREE.Euler (0, Math.PI/2, -Math.PI/2, 'ZYX');
        euler2[5] = new THREE.Euler (-Math.PI/2, 0, Math.PI, 'ZYX');

        GroupA.children[0].position.copy (pos1[0]);
        GroupA.children[0].rotation.copy (new THREE.Euler (0, Math.PI/2, -Math.PI/2, 'ZYX'));
        GroupB.children[0].position.copy (pos1[1]);
        GroupB.children[0].rotation.copy (new THREE.Euler (0, Math.PI,0, 'ZYX'));
        GroupC.children[0].position.copy (pos1[2]);
        GroupC.children[0].rotation.copy (new THREE.Euler (0, -Math.PI/2, -Math.PI/2, 'ZYX'));
        GroupD.children[0].position.copy (pos1[3]);
        GroupD.children[0].rotation.copy (new THREE.Euler (0, Math.PI, Math.PI, 'ZYX'));
        GroupE.children[0].position.copy (pos1[4]);
        GroupE.children[0].rotation.copy (new THREE.Euler (0, Math.PI, -Math.PI/2, 'ZYX'));
        GroupF.children[0].position.copy (pos1[5]);
        GroupF.children[0].rotation.copy (new THREE.Euler (0,0, -Math.PI/2, 'ZYX'));
        turning = 0; //not yet turning	
        manIn ='A';
        moving = 'BtoA';
      }
    if (eT==3&&which == 'F'&&manIn=='B') {  // Px2Pz
      //currentPlane = 'B';
      //nextPlane = 'F';
        pos1[0] = new THREE.Vector3(L/2, -L/2, 0);
        euler1[0] = new THREE.Euler (0, -Math.PI/2, -Math.PI/2, 'ZYX');
        euler2[0] = new THREE.Euler (Math.PI/2, 0, Math.PI, 'ZYX');

        pos1[1] = new THREE.Vector3(0, 0, 0);
        euler1[1] = new THREE.Euler (0, 0,0, 'ZYX');
        euler2[1] = new THREE.Euler (0, 0,-Math.PI/2, 'ZYX');

        pos1[2] = new THREE.Vector3(L/2, -L/2, 0);
        euler1[2] = new THREE.Euler (0, Math.PI/2,-Math.PI/2, 'ZYX');
        euler2[2] = new THREE.Euler (-Math.PI/2, 0,Math.PI, 'ZYX');

        pos1[3] = new THREE.Vector3(0,-L, 0);
        euler1[3] = new THREE.Euler (0, 0, Math.PI, 'ZYX');
        euler2[3] = new THREE.Euler (0, 0,Math.PI/2, 'ZYX');

        pos1[4] = new THREE.Vector3(L/2,-L/2, 0);
        euler1[4] = new THREE.Euler (0,0 ,-Math.PI/2, 'ZYX');
        euler2[4] = new THREE.Euler (0,0 ,-Math.PI, 'ZYX');

        pos1[5] = new THREE.Vector3(L/2,-L/2, 0);
        euler1[5] = new THREE.Euler (0,Math.PI,-Math.PI/2, 'ZYX');
        euler2[5] = new THREE.Euler (0,Math.PI,0, 'ZYX');

        GroupA.children[0].position.copy (pos1[0]);
        GroupA.children[0].rotation.copy (new THREE.Euler (0, Math.PI/2, -Math.PI/2, 'ZYX'));
        GroupB.children[0].position.copy (pos1[1]);
        GroupB.children[0].rotation.copy (new THREE.Euler (0, Math.PI,0, 'ZYX'));
        GroupC.children[0].position.copy (pos1[2]);
        GroupC.children[0].rotation.copy (new THREE.Euler (0, -Math.PI/2, -Math.PI/2, 'ZYX'));
        GroupD.children[0].position.copy (pos1[3]);
        GroupD.children[0].rotation.copy (new THREE.Euler (0, Math.PI, Math.PI, 'ZYX'));
        GroupE.children[0].position.copy (pos1[4]);
        GroupE.children[0].rotation.copy (new THREE.Euler (0, Math.PI, -Math.PI/2, 'ZYX'));
        GroupF.children[0].position.copy (pos1[5]);
        GroupF.children[0].rotation.copy (new THREE.Euler (0,0, -Math.PI/2, 'ZYX'));
        turning = 0; //not yet turning		
        manIn = 'F';
        moving = 'BtoF';
      }
    //////////////
    if (eT==3&&which == 'D'&&manIn=='C') {  // Px2Pz
      //currentPlane = 'C';
      //nextPlane = 'D';
        pos1[0] = new THREE.Vector3(0,-L, 0);
        euler1[0] = new THREE.Euler (0,0,Math.PI, 'ZYX');
        euler2[0] = new THREE.Euler (0,0,Math.PI/2, 'ZYX');

        pos1[1] = new THREE.Vector3(0,-L/2, -L/2);
        euler1[1] = new THREE.Euler (-Math.PI/2,0,-Math.PI/2, 'ZYX');
        euler2[1] = new THREE.Euler (0,-Math.PI/2,Math.PI, 'ZYX');

        pos1[2] = new THREE.Vector3(0, 0, 0);
        euler1[2] = new THREE.Euler (0,Math.PI,0, 'ZYX');
        euler2[2] = new THREE.Euler (0,Math.PI,Math.PI/2, 'ZYX');

        pos1[3] = new THREE.Vector3(0,-L/2, -L/2);
        euler1[3] = new THREE.Euler (-Math.PI/2,0,Math.PI/2, 'ZYX');
        euler2[3] = new THREE.Euler (0,-Math.PI/2,0, 'ZYX');

        pos1[4] = new THREE.Vector3(0,-L/2, -L/2);
        euler1[4] = new THREE.Euler (-Math.PI/2,0,Math.PI, 'ZYX');
        euler2[4] = new THREE.Euler (0,-Math.PI/2,Math.PI/2, 'ZYX');

        pos1[5] = new THREE.Vector3(0,-L/2, L/2);
        euler1[5] = new THREE.Euler (Math.PI/2,0,Math.PI, 'ZYX');
        euler2[5] = new THREE.Euler (0,Math.PI/2,Math.PI/2, 'ZYX');

        GroupA.children[0].position.copy (pos1[0]);
        GroupA.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,Math.PI, 'ZYX'));
        GroupB.children[0].position.copy (pos1[1]);
        GroupB.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0,Math.PI, 'ZYX'));
        GroupC.children[0].position.copy (pos1[2]);
        GroupC.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,0, 'ZYX'));
        GroupD.children[0].position.copy (pos1[3]);
        GroupD.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0,0, 'ZYX'));
        GroupE.children[0].position.copy (pos1[4]);
        GroupE.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0,Math.PI/2, 'ZYX'));
        GroupF.children[0].position.copy (pos1[5]);
        GroupF.children[0].rotation.copy (new THREE.Euler (Math.PI/2,0,-Math.PI/2, 'ZYX'));
        turning = 0; //not yet turning		
        manIn ='D'
        moving = 'CtoD';
      }
    if (eT==3&&which == 'E'&&manIn=='C') {  // Px2Pz
      //currentPlane = 'C';
      //nextPlane = 'E';
        pos1[0] = new THREE.Vector3(0,-L, 0);
        euler1[0] = new THREE.Euler (0,Math.PI/2,Math.PI, 'ZYX');
        euler2[0] = new THREE.Euler (-Math.PI/2,0,Math.PI/2, 'ZYX');

        pos1[1] = new THREE.Vector3(0,-L/2, -L/2);
        euler1[1] = new THREE.Euler (-Math.PI/2,0,Math.PI, 'ZYX');
        euler2[1] = new THREE.Euler (0,-Math.PI/2,Math.PI/2, 'ZYX');

        pos1[2] = new THREE.Vector3(0, 0, 0);
        euler1[2] = new THREE.Euler (0,-Math.PI/2,0, 'ZYX');
        euler2[2] = new THREE.Euler (Math.PI/2,0,-Math.PI/2, 'ZYX');

        pos1[3] = new THREE.Vector3(0,-L/2, -L/2);
        euler1[3] = new THREE.Euler (-Math.PI/2,0,0, 'ZYX');
        euler2[3] = new THREE.Euler (0,-Math.PI/2,-Math.PI/2, 'ZYX');

        pos1[4] = new THREE.Vector3(0,-L/2, -L/2);
        euler1[4] = new THREE.Euler (-Math.PI/2,0,Math.PI/2, 'ZYX');
        euler2[4] = new THREE.Euler (0,-Math.PI/2,0, 'ZYX');

        pos1[5] = new THREE.Vector3(0,-L/2, L/2);
        euler1[5] = new THREE.Euler (Math.PI/2,0,-Math.PI/2, 'ZYX');
        euler2[5] = new THREE.Euler (0,Math.PI/2,Math.PI, 'ZYX');

        GroupA.children[0].position.copy (pos1[0]);
        GroupA.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,Math.PI, 'ZYX'));
        GroupB.children[0].position.copy (pos1[1]);
        GroupB.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0,Math.PI, 'ZYX'));
        GroupC.children[0].position.copy (pos1[2]);
        GroupC.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,0, 'ZYX'));
        GroupD.children[0].position.copy (pos1[3]);
        GroupD.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0,0, 'ZYX'));
        GroupE.children[0].position.copy (pos1[4]);
        GroupE.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0,Math.PI/2, 'ZYX'));
        GroupF.children[0].position.copy (pos1[5]);
        GroupF.children[0].rotation.copy (new THREE.Euler (Math.PI/2,0,-Math.PI/2, 'ZYX'));
        turning = 0; //not yet turning		
        manIn = 'E';
        moving = 'CtoE';
      }
    if (eT==3&&which == 'B'&&manIn=='C') {  // Px2Pz
      //currentPlane = 'C';
      //nextPlane = 'B';
      pos1[0] = new THREE.Vector3(0,-L, 0);
      euler1[0] = new THREE.Euler (0,Math.PI,Math.PI, 'ZYX');
      euler2[0] = new THREE.Euler (0,Math.PI,-Math.PI/2, 'ZYX');

      pos1[1] = new THREE.Vector3(0,-L/2, -L/2);
      euler1[1] = new THREE.Euler (-Math.PI/2,0,Math.PI/2, 'ZYX');
      euler2[1] = new THREE.Euler (0,-Math.PI/2,0, 'ZYX');
      
      pos1[2] = new THREE.Vector3(0, 0, 0);
      euler1[2] = new THREE.Euler (0,0,0, 'ZYX');
      euler2[2] = new THREE.Euler (0,0,-Math.PI/2, 'ZYX');
      
      pos1[3] = new THREE.Vector3(0,-L/2, -L/2);
      euler1[3] = new THREE.Euler (-Math.PI/2,0,-Math.PI/2, 'ZYX');
      euler2[3] = new THREE.Euler (0,-Math.PI/2,Math.PI, 'ZYX');
      
      pos1[4] = new THREE.Vector3(0,-L/2, -L/2);
      euler1[4] = new THREE.Euler (-Math.PI/2,0,0, 'ZYX');
      euler2[4] = new THREE.Euler (0,-Math.PI/2,-Math.PI/2, 'ZYX');
      
      pos1[5] = new THREE.Vector3(0,-L/2, L/2);
      euler1[5] = new THREE.Euler (Math.PI/2,0,0, 'ZYX');
      euler2[5] = new THREE.Euler (0,Math.PI/2,-Math.PI/2, 'ZYX');

      GroupA.children[0].position.copy (pos1[0]);
        GroupA.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,Math.PI, 'ZYX'));
        GroupB.children[0].position.copy (pos1[1]);
        GroupB.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0,Math.PI, 'ZYX'));
        GroupC.children[0].position.copy (pos1[2]);
        GroupC.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,0, 'ZYX'));
        GroupD.children[0].position.copy (pos1[3]);
        GroupD.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0,0, 'ZYX'));
        GroupE.children[0].position.copy (pos1[4]);
        GroupE.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0,Math.PI/2, 'ZYX'));
        GroupF.children[0].position.copy (pos1[5]);
        GroupF.children[0].rotation.copy (new THREE.Euler (Math.PI/2,0,-Math.PI/2, 'ZYX'));
      turning = 0; //not yet turning		
      manIn = 'B';
      moving = 'CtoB'; 
    }
    if (eT==3&&which == 'F'&&manIn=='C'){  // Px2Pz
      //currentPlane = 'C';
      //nextPlane = 'F';
      pos1[0] = new THREE.Vector3(0,-L, 0);
      euler1[0] = new THREE.Euler (0,-Math.PI/2,Math.PI, 'ZYX');
      euler2[0] = new THREE.Euler (Math.PI/2,0,Math.PI/2, 'ZYX');

      pos1[1] = new THREE.Vector3(0,-L/2, -L/2);
      euler1[1] = new THREE.Euler (-Math.PI/2,0,0, 'ZYX');
      euler2[1] = new THREE.Euler (0,-Math.PI/2,-Math.PI/2, 'ZYX');
      
      pos1[2] = new THREE.Vector3(0, 0, 0);
      euler1[2] = new THREE.Euler (0,Math.PI/2,0, 'ZYX');
      euler2[2] = new THREE.Euler (-Math.PI/2,0,-Math.PI/2, 'ZYX');
      
      pos1[3] = new THREE.Vector3(0,-L/2, -L/2);
      euler1[3] = new THREE.Euler (-Math.PI/2,0,Math.PI, 'ZYX');
      euler2[3] = new THREE.Euler (0,-Math.PI/2,Math.PI/2, 'ZYX');
      
      pos1[4] = new THREE.Vector3(0,-L/2, -L/2);
      euler1[4] = new THREE.Euler (-Math.PI/2,0,-Math.PI/2, 'ZYX');
      euler2[4] = new THREE.Euler (0,-Math.PI/2,Math.PI, 'ZYX');
      
      pos1[5] = new THREE.Vector3(0,-L/2, L/2);
      euler1[5] = new THREE.Euler (Math.PI/2,0,Math.PI/2, 'ZYX');
      euler2[5] = new THREE.Euler (0,Math.PI/2,0, 'ZYX');

      GroupA.children[0].position.copy (pos1[0]);
        GroupA.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,Math.PI, 'ZYX'));
        GroupB.children[0].position.copy (pos1[1]);
        GroupB.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0,Math.PI, 'ZYX'));
        GroupC.children[0].position.copy (pos1[2]);
        GroupC.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,0, 'ZYX'));
        GroupD.children[0].position.copy (pos1[3]);
        GroupD.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0,0, 'ZYX'));
        GroupE.children[0].position.copy (pos1[4]);
        GroupE.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0,Math.PI/2, 'ZYX'));
        GroupF.children[0].position.copy (pos1[5]);
        GroupF.children[0].rotation.copy (new THREE.Euler (Math.PI/2,0,-Math.PI/2, 'ZYX'));
      turning = 0; //not yet turning		
      manIn = 'F';
      moving = 'CtoF'; 
    }
    //////////////
    if (eT==3&&which == 'A'&&manIn=='D') {
      //currentPlane = 'D';
      //nextPlane = 'A';
      pos1[0] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[0] = new THREE.Euler (0,0,Math.PI/2, 'ZYX');
      euler2[0] = new THREE.Euler (0,0,0, 'ZYX');

      pos1[1] = new THREE.Vector3(0,-L, 0);
      euler1[1] = new THREE.Euler (0,-Math.PI/2,Math.PI, 'ZYX');
      euler2[1] = new THREE.Euler (Math.PI/2,0,Math.PI/2, 'ZYX');
      
      pos1[2] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[2] = new THREE.Euler (0,Math.PI,Math.PI/2, 'ZYX');
      euler2[2] = new THREE.Euler (Math.PI,0,0, 'ZYX');
      
      pos1[3] = new THREE.Vector3(0,0,0);
      euler1[3] = new THREE.Euler (0,-Math.PI/2,0, 'ZYX');
      euler2[3] = new THREE.Euler (Math.PI/2,0,-Math.PI/2, 'ZYX');
      
      pos1[4] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[4] = new THREE.Euler (0,-Math.PI/2,Math.PI/2, 'ZYX');
      euler2[4] = new THREE.Euler (Math.PI/2,0,0, 'ZYX');
      
      pos1[5] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[5] = new THREE.Euler (0,Math.PI/2,Math.PI/2, 'ZYX');
      euler2[5] = new THREE.Euler (-Math.PI/2,0,0, 'ZYX');

      GroupA.children[0].position.copy (pos1[0]);
      GroupA.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,Math.PI/2, 'ZYX'));
      GroupB.children[0].position.copy (pos1[1]);
      GroupB.children[0].rotation.copy (new THREE.Euler (0,0,Math.PI, 'ZYX'));
      GroupC.children[0].position.copy (pos1[2]);
      GroupC.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,Math.PI/2, 'ZYX'));
      GroupD.children[0].position.copy (pos1[3]);
      GroupD.children[0].rotation.copy (new THREE.Euler (0,0,0, 'ZYX'));
      GroupE.children[0].position.copy (pos1[4]);
      GroupE.children[0].rotation.copy (new THREE.Euler (0,0,Math.PI/2, 'ZYX'));
      GroupF.children[0].position.copy (pos1[5]);
      GroupF.children[0].rotation.copy (new THREE.Euler (0,Math.PI,Math.PI/2, 'ZYX'));
      turning = 0; //not yet turning		
      manIn='A';
      moving = 'DtoA'; 
    }
    if (eT==3&&which == 'E'&&manIn=='D') {
      //currentPlane = 'D';
      //nextPlane = 'E';
      pos1[0] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[0] = new THREE.Euler (0,Math.PI/2,Math.PI/2, 'ZYX');
      euler2[0] = new THREE.Euler (-Math.PI/2,0,0, 'ZYX');

      pos1[1] = new THREE.Vector3(0,-L, 0);
      euler1[1] = new THREE.Euler (0,0,Math.PI, 'ZYX');
      euler2[1] = new THREE.Euler (0,0,Math.PI/2, 'ZYX');
      
      pos1[2] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[2] = new THREE.Euler (0,-Math.PI/2,Math.PI/2, 'ZYX');
      euler2[2] = new THREE.Euler (Math.PI/2,0,0, 'ZYX');
      
      pos1[3] = new THREE.Vector3(0,0,0);
      euler1[3] = new THREE.Euler (0,0,0, 'ZYX');
      euler2[3] = new THREE.Euler (0,0,-Math.PI/2, 'ZYX');
      
      pos1[4] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[4] = new THREE.Euler (0,0,Math.PI/2, 'ZYX');
      euler2[4] = new THREE.Euler (0,0,0, 'ZYX');
      
      pos1[5] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[5] = new THREE.Euler (0,Math.PI,Math.PI/2, 'ZYX');
      euler2[5] = new THREE.Euler (Math.PI,0,0, 'ZYX');

      GroupA.children[0].position.copy (pos1[0]);
      GroupA.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,Math.PI/2, 'ZYX'));
      GroupB.children[0].position.copy (pos1[1]);
      GroupB.children[0].rotation.copy (new THREE.Euler (0,0,Math.PI, 'ZYX'));
      GroupC.children[0].position.copy (pos1[2]);
      GroupC.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,Math.PI/2, 'ZYX'));
      GroupD.children[0].position.copy (pos1[3]);
      GroupD.children[0].rotation.copy (new THREE.Euler (0,0,0, 'ZYX'));
      GroupE.children[0].position.copy (pos1[4]);
      GroupE.children[0].rotation.copy (new THREE.Euler (0,0,Math.PI/2, 'ZYX'));
      GroupF.children[0].position.copy (pos1[5]);
      GroupF.children[0].rotation.copy (new THREE.Euler (0,Math.PI,Math.PI/2, 'ZYX'));
      turning = 0; //not yet turning		
      manIn='E';
      moving = 'DtoE'; 
    }
    if (eT==3&&which == 'C'&&manIn=='D') {
      //currentPlane = 'D';
      //nextPlane = 'C';
      pos1[0] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[0] = new THREE.Euler (0,Math.PI,Math.PI/2, 'ZYX');
      euler2[0] = new THREE.Euler (Math.PI,0,0, 'ZYX');

      pos1[1] = new THREE.Vector3(0,-L, 0);
      euler1[1] = new THREE.Euler (0,Math.PI/2,Math.PI, 'ZYX');
      euler2[1] = new THREE.Euler (-Math.PI/2,0,Math.PI/2, 'ZYX');
      
      pos1[2] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[2] = new THREE.Euler (0,0,Math.PI/2, 'ZYX');
      euler2[2] = new THREE.Euler (0,0,0, 'ZYX');
      
      pos1[3] = new THREE.Vector3(0,0,0);
      euler1[3] = new THREE.Euler (0,Math.PI/2,0, 'ZYX');
      euler2[3] = new THREE.Euler (-Math.PI/2,0,-Math.PI/2, 'ZYX');
      
      pos1[4] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[4] = new THREE.Euler (0,Math.PI/2,Math.PI/2, 'ZYX');
      euler2[4] = new THREE.Euler (-Math.PI/2,0,0, 'ZYX');
      
      pos1[5] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[5] = new THREE.Euler (0,-Math.PI/2,Math.PI/2, 'ZYX');
      euler2[5] = new THREE.Euler (Math.PI/2,0,0, 'ZYX');

      GroupA.children[0].position.copy (pos1[0]);
      GroupA.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,Math.PI/2, 'ZYX'));
      GroupB.children[0].position.copy (pos1[1]);
      GroupB.children[0].rotation.copy (new THREE.Euler (0,0,Math.PI, 'ZYX'));
      GroupC.children[0].position.copy (pos1[2]);
      GroupC.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,Math.PI/2, 'ZYX'));
      GroupD.children[0].position.copy (pos1[3]);
      GroupD.children[0].rotation.copy (new THREE.Euler (0,0,0, 'ZYX'));
      GroupE.children[0].position.copy (pos1[4]);
      GroupE.children[0].rotation.copy (new THREE.Euler (0,0,Math.PI/2, 'ZYX'));
      GroupF.children[0].position.copy (pos1[5]);
      GroupF.children[0].rotation.copy (new THREE.Euler (0,Math.PI,Math.PI/2, 'ZYX'));
      turning = 0; //not yet turning		
      manIn='C';
      moving = 'DtoC'; 
    }
    if (eT==3&&which == 'F'&&manIn=='D') {
      //currentPlane = 'D';
      //nextPlane = 'F';
      pos1[0] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[0] = new THREE.Euler (0,-Math.PI/2,Math.PI/2, 'ZYX');
      euler2[0] = new THREE.Euler (Math.PI/2,0,0, 'ZYX');

      pos1[1] = new THREE.Vector3(0,-L, 0);
      euler1[1] = new THREE.Euler (0,Math.PI,Math.PI, 'ZYX');
      euler2[1] = new THREE.Euler (Math.PI,0,Math.PI/2, 'ZYX');
      
      pos1[2] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[2] = new THREE.Euler (0,Math.PI/2,Math.PI/2, 'ZYX');
      euler2[2] = new THREE.Euler (-Math.PI/2,0,0, 'ZYX');
      
      pos1[3] = new THREE.Vector3(0,0,0);
      euler1[3] = new THREE.Euler (0,Math.PI,0, 'ZYX');
      euler2[3] = new THREE.Euler (0,Math.PI,Math.PI/2, 'ZYX');
      
      pos1[4] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[4] = new THREE.Euler (0,Math.PI,Math.PI/2, 'ZYX');
      euler2[4] = new THREE.Euler (Math.PI,0,0, 'ZYX');
      
      pos1[5] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[5] = new THREE.Euler (0,0,Math.PI/2, 'ZYX');
      euler2[5] = new THREE.Euler (0,0,0, 'ZYX');

      GroupA.children[0].position.copy (pos1[0]);
      GroupA.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,Math.PI/2, 'ZYX'));
      GroupB.children[0].position.copy (pos1[1]);
      GroupB.children[0].rotation.copy (new THREE.Euler (0,0,Math.PI, 'ZYX'));
      GroupC.children[0].position.copy (pos1[2]);
      GroupC.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,Math.PI/2, 'ZYX'));
      GroupD.children[0].position.copy (pos1[3]);
      GroupD.children[0].rotation.copy (new THREE.Euler (0,0,0, 'ZYX'));
      GroupE.children[0].position.copy (pos1[4]);
      GroupE.children[0].rotation.copy (new THREE.Euler (0,0,Math.PI/2, 'ZYX'));
      GroupF.children[0].position.copy (pos1[5]);
      GroupF.children[0].rotation.copy (new THREE.Euler (0,Math.PI,Math.PI/2, 'ZYX'));
      turning = 0; //not yet turning		
      manIn='F';
      moving = 'DtoF'; 
    }
    //////////////
    if (eT==3&&which == 'A'&&manIn=='E') {
      //currentPlane = 'E';
      //nextPlane = 'A';
      pos1[0] = new THREE.Vector3(0,-L/2, -L/2);
      euler1[0] = new THREE.Euler (-Math.PI/2,0,Math.PI/2, 'ZYX');
      euler2[0] = new THREE.Euler (0,-Math.PI/2,0, 'ZYX');

      pos1[1] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[1] = new THREE.Euler (0,-Math.PI/2,Math.PI/2, 'ZYX');
      euler2[1] = new THREE.Euler (Math.PI/2,0,0, 'ZYX');
      
      pos1[2] = new THREE.Vector3(0,-L/2, L/2);
      euler1[2] = new THREE.Euler (Math.PI/2,0,-Math.PI/2, 'ZYX');
      euler2[2] = new THREE.Euler (0,Math.PI/2,Math.PI, 'ZYX');
      
      pos1[3] = new THREE.Vector3(L/2,-L/2, 0);
      euler1[3] = new THREE.Euler (0,-Math.PI/2,-Math.PI/2, 'ZYX');
      euler2[3] = new THREE.Euler (-Math.PI/2,Math.PI,0, 'ZYX');
      
      pos1[4] = new THREE.Vector3(0,0, 0);
      euler1[4] = new THREE.Euler (0,-Math.PI/2,0, 'ZYX');
      euler2[4] = new THREE.Euler (Math.PI/2,0,-Math.PI/2, 'ZYX');
      
      pos1[5] = new THREE.Vector3(0,-L,0);
      euler1[5] = new THREE.Euler (0,Math.PI/2,Math.PI, 'ZYX');
      euler2[5] = new THREE.Euler (-Math.PI/2,0,Math.PI/2, 'ZYX');

      GroupA.children[0].position.copy (pos1[0]);
      GroupA.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0,-Math.PI/2, 'ZYX'));
      GroupB.children[0].position.copy (pos1[1]);
      GroupB.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,Math.PI/2, 'ZYX'));
      GroupC.children[0].position.copy (pos1[2]);
      GroupC.children[0].rotation.copy (new THREE.Euler (Math.PI/2,0,Math.PI/2, 'ZYX'));
      GroupD.children[0].position.copy (pos1[3]);
      GroupD.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,-Math.PI/2, 'ZYX'));
      GroupE.children[0].position.copy (pos1[4]);
      GroupE.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,0, 'ZYX'));
      GroupF.children[0].position.copy (pos1[5]);
      GroupF.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,Math.PI, 'ZYX'));
      turning = 0; //not yet turning		
      manIn = 'A';
      moving = 'EtoA'; 
    }
    if (eT==3&&which == 'B'&&manIn=='E') {
      //currentPlane = 'E';
      //nextPlane = 'B';
      pos1[0] = new THREE.Vector3(0,-L/2, -L/2);
      euler1[0] = new THREE.Euler (-Math.PI/2,0,0, 'ZYX');
      euler2[0] = new THREE.Euler (0,-Math.PI/2,-Math.PI/2, 'ZYX');

      pos1[1] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[1] = new THREE.Euler (0,0,Math.PI/2, 'ZYX');
      euler2[1] = new THREE.Euler (0,0,0, 'ZYX');
      
      pos1[2] = new THREE.Vector3(0,-L/2, L/2);
      euler1[2] = new THREE.Euler (Math.PI/2,0,0, 'ZYX');
      euler2[2] = new THREE.Euler (0,Math.PI/2,-Math.PI/2, 'ZYX');
      
      pos1[3] = new THREE.Vector3(L/2,-L/2, 0);
      euler1[3] = new THREE.Euler (0,0,-Math.PI/2, 'ZYX');
      euler2[3] = new THREE.Euler (0,0,Math.PI, 'ZYX');
      
      pos1[4] = new THREE.Vector3(0,0, 0);
      euler1[4] = new THREE.Euler (0,0,0, 'ZYX');
      euler2[4] = new THREE.Euler (0,0,-Math.PI/2, 'ZYX');
      
      pos1[5] = new THREE.Vector3(0,-L,0);
      euler1[5] = new THREE.Euler (0,Math.PI,Math.PI, 'ZYX');
      euler2[5] = new THREE.Euler (0,Math.PI,-Math.PI/2, 'ZYX');

      GroupA.children[0].position.copy (pos1[0]);
      GroupA.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0,-Math.PI/2, 'ZYX'));
      GroupB.children[0].position.copy (pos1[1]);
      GroupB.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,Math.PI/2, 'ZYX'));
      GroupC.children[0].position.copy (pos1[2]);
      GroupC.children[0].rotation.copy (new THREE.Euler (Math.PI/2,0,Math.PI/2, 'ZYX'));
      GroupD.children[0].position.copy (pos1[3]);
      GroupD.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,-Math.PI/2, 'ZYX'));
      GroupE.children[0].position.copy (pos1[4]);
      GroupE.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,0, 'ZYX'));
      GroupF.children[0].position.copy (pos1[5]);
      GroupF.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,Math.PI, 'ZYX'));
      turning = 0; //not yet turning		
      manIn = 'B';
      moving = 'EtoB'; 
    }
    if (eT==3&&which == 'C'&&manIn=='E') {
      //currentPlane = 'E';
      //nextPlane = 'C';
      pos1[0] = new THREE.Vector3(0,-L/2, -L/2);
      euler1[0] = new THREE.Euler (-Math.PI/2,0,-Math.PI/2, 'ZYX');
      euler2[0] = new THREE.Euler (Math.PI,-Math.PI/2,0, 'ZYX');

      pos1[1] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[1] = new THREE.Euler (0,Math.PI/2,Math.PI/2, 'ZYX');
      euler2[1] = new THREE.Euler (-Math.PI/2,0,0, 'ZYX');
      
      pos1[2] = new THREE.Vector3(0,-L/2, L/2);
      euler1[2] = new THREE.Euler (Math.PI/2,0,Math.PI/2, 'ZYX');
      euler2[2] = new THREE.Euler (0,Math.PI/2,0, 'ZYX');
      
      pos1[3] = new THREE.Vector3(L/2,-L/2, 0);
      euler1[3] = new THREE.Euler (0,Math.PI/2,-Math.PI/2, 'ZYX');
      euler2[3] = new THREE.Euler (Math.PI/2,Math.PI,0, 'ZYX');
      
      pos1[4] = new THREE.Vector3(0,0, 0);
      euler1[4] = new THREE.Euler (0,Math.PI/2,0, 'ZYX');
      euler2[4] = new THREE.Euler (-Math.PI/2,0,-Math.PI/2, 'ZYX');
      
      pos1[5] = new THREE.Vector3(0,-L,0);
      euler1[5] = new THREE.Euler (0,-Math.PI/2,Math.PI, 'ZYX');
      euler2[5] = new THREE.Euler (Math.PI/2,0,Math.PI/2, 'ZYX');

      GroupA.children[0].position.copy (pos1[0]);
      GroupA.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0,-Math.PI/2, 'ZYX'));
      GroupB.children[0].position.copy (pos1[1]);
      GroupB.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,Math.PI/2, 'ZYX'));
      GroupC.children[0].position.copy (pos1[2]);
      GroupC.children[0].rotation.copy (new THREE.Euler (Math.PI/2,0,Math.PI/2, 'ZYX'));
      GroupD.children[0].position.copy (pos1[3]);
      GroupD.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,-Math.PI/2, 'ZYX'));
      GroupE.children[0].position.copy (pos1[4]);
      GroupE.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,0, 'ZYX'));
      GroupF.children[0].position.copy (pos1[5]);
      GroupF.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,Math.PI, 'ZYX'));
      turning = 0; //not yet turning		
      manIn = 'C';
      moving = 'EtoC'; 
    }
    if (eT==3&&which == 'D'&&manIn=='E') {
      //currentPlane = 'E';
      //nextPlane = 'D';
      pos1[0] = new THREE.Vector3(0,-L/2, -L/2);
      euler1[0] = new THREE.Euler (-Math.PI/2,0,Math.PI, 'ZYX');
      euler2[0] = new THREE.Euler (0,-Math.PI/2,Math.PI/2, 'ZYX');

      pos1[1] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[1] = new THREE.Euler (0,Math.PI,Math.PI/2, 'ZYX');
      euler2[1] = new THREE.Euler (0,Math.PI,Math.PI, 'ZYX');
      
      pos1[2] = new THREE.Vector3(0,-L/2, L/2);
      euler1[2] = new THREE.Euler (Math.PI/2,0,Math.PI, 'ZYX');
      euler2[2] = new THREE.Euler (0,Math.PI/2,Math.PI/2, 'ZYX');
      
      pos1[3] = new THREE.Vector3(L/2,-L/2, 0);
      euler1[3] = new THREE.Euler (0,Math.PI,-Math.PI/2, 'ZYX');
      euler2[3] = new THREE.Euler (0,Math.PI,0, 'ZYX');
      
      pos1[4] = new THREE.Vector3(0,0, 0);
      euler1[4] = new THREE.Euler (0,Math.PI,0, 'ZYX');
      euler2[4] = new THREE.Euler (0,Math.PI,Math.PI/2, 'ZYX');
      
      pos1[5] = new THREE.Vector3(0,-L,0);
      euler1[5] = new THREE.Euler (0,0,Math.PI, 'ZYX');
      euler2[5] = new THREE.Euler (0,0,Math.PI/2, 'ZYX');

      GroupA.children[0].position.copy (pos1[0]);
      GroupA.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0,-Math.PI/2, 'ZYX'));
      GroupB.children[0].position.copy (pos1[1]);
      GroupB.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,Math.PI/2, 'ZYX'));
      GroupC.children[0].position.copy (pos1[2]);
      GroupC.children[0].rotation.copy (new THREE.Euler (Math.PI/2,0,Math.PI/2, 'ZYX'));
      GroupD.children[0].position.copy (pos1[3]);
      GroupD.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,-Math.PI/2, 'ZYX'));
      GroupE.children[0].position.copy (pos1[4]);
      GroupE.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,0, 'ZYX'));
      GroupF.children[0].position.copy (pos1[5]);
      GroupF.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,Math.PI, 'ZYX'));
      turning = 0; //not yet turning		
      manIn = 'D';
      moving = 'EtoD'; 
    }
    //////////////
    if (eT==3&&which == 'A'&&manIn=='F') {
      //currentPlane = 'F';
      //nextPlane = 'A';
      pos1[0] = new THREE.Vector3(0,-L/2, L/2);
      euler1[0] = new THREE.Euler (Math.PI/2,0,Math.PI/2, 'ZYX');
      euler2[0] = new THREE.Euler (0,Math.PI/2,0, 'ZYX');

      pos1[1] = new THREE.Vector3(L/2,-L/2, 0);
      euler1[1] = new THREE.Euler (0,-Math.PI/2,-Math.PI/2, 'ZYX');
      euler2[1] = new THREE.Euler (-Math.PI/2,Math.PI,0, 'ZYX');
      
      pos1[2] = new THREE.Vector3(0,-L/2, -L/2);
      euler1[2] = new THREE.Euler (-Math.PI/2,0,-Math.PI/2, 'ZYX');
      euler2[2] = new THREE.Euler (0,-Math.PI/2,Math.PI, 'ZYX');
      
      pos1[3] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[3] = new THREE.Euler (0,-Math.PI/2,Math.PI/2, 'ZYX');
      euler2[3] = new THREE.Euler (Math.PI/2,0,0, 'ZYX');
      
      pos1[4] = new THREE.Vector3(0,-L, 0);
      euler1[4] = new THREE.Euler (0,-Math.PI/2,Math.PI, 'ZYX');
      euler2[4] = new THREE.Euler (Math.PI/2,0,Math.PI/2, 'ZYX');
      
      pos1[5] = new THREE.Vector3(0,0,0);
      euler1[5] = new THREE.Euler (0,Math.PI/2,0, 'ZYX');
      euler2[5] = new THREE.Euler (-Math.PI/2,0,-Math.PI/2, 'ZYX');

      GroupA.children[0].position.copy (pos1[0]);
      GroupA.children[0].rotation.copy (new THREE.Euler (Math.PI/2,0,Math.PI/2, 'ZYX'));
      GroupB.children[0].position.copy (pos1[1]);
      GroupB.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,-Math.PI/2, 'ZYX'));
      GroupC.children[0].position.copy (pos1[2]);
      GroupC.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0,-Math.PI/2, 'ZYX'));
      GroupD.children[0].position.copy (pos1[3]);
      GroupD.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,Math.PI/2, 'ZYX'));
      GroupE.children[0].position.copy (pos1[4]);
      GroupE.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,Math.PI, 'ZYX'));
      GroupF.children[0].position.copy (pos1[5]);
      GroupF.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,0, 'ZYX'));
      turning = 0; //not yet turning		
      manIn = 'A';
      moving = 'FtoA'; 
    }
    if (eT==3&&which == 'B'&&manIn=='F') {
      //currentPlane = 'F';
      //nextPlane = 'B';
      pos1[0] = new THREE.Vector3(0,-L/2, L/2);
      euler1[0] = new THREE.Euler (Math.PI/2,0,0, 'ZYX');
      euler2[0] = new THREE.Euler (0,Math.PI/2,-Math.PI/2, 'ZYX');

      pos1[1] = new THREE.Vector3(L/2,-L/2, 0);
      euler1[1] = new THREE.Euler (0,Math.PI,-Math.PI/2, 'ZYX');
      euler2[1] = new THREE.Euler (0,Math.PI,0, 'ZYX');
      
      pos1[2] = new THREE.Vector3(0,-L/2, -L/2);
      euler1[2] = new THREE.Euler (-Math.PI/2,0,0, 'ZYX');
      euler2[2] = new THREE.Euler (0,-Math.PI/2,-Math.PI/2, 'ZYX');
      
      pos1[3] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[3] = new THREE.Euler (0,Math.PI,Math.PI/2, 'ZYX');
      euler2[3] = new THREE.Euler (Math.PI,0,0, 'ZYX');
      
      pos1[4] = new THREE.Vector3(0,-L, 0);
      euler1[4] = new THREE.Euler (0,Math.PI,Math.PI, 'ZYX');
      euler2[4] = new THREE.Euler (0,Math.PI,-Math.PI/2, 'ZYX');
      
      pos1[5] = new THREE.Vector3(0,0,0);
      euler1[5] = new THREE.Euler (0,0,0, 'ZYX');
      euler2[5] = new THREE.Euler (0,0,-Math.PI/2, 'ZYX');

      GroupA.children[0].position.copy (pos1[0]);
      GroupA.children[0].rotation.copy (new THREE.Euler (Math.PI/2,0,Math.PI/2, 'ZYX'));
      GroupB.children[0].position.copy (pos1[1]);
      GroupB.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,-Math.PI/2, 'ZYX'));
      GroupC.children[0].position.copy (pos1[2]);
      GroupC.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0,-Math.PI/2, 'ZYX'));
      GroupD.children[0].position.copy (pos1[3]);
      GroupD.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,Math.PI/2, 'ZYX'));
      GroupE.children[0].position.copy (pos1[4]);
      GroupE.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,Math.PI, 'ZYX'));
      GroupF.children[0].position.copy (pos1[5]);
      GroupF.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,0, 'ZYX'));
      turning = 0; //not yet turning		
      manIn = 'B';
      moving = 'FtoB'; 
    }
    if (eT==3&&which == 'C'&&manIn=='F') {
      //currentPlane = 'F';
      //nextPlane = 'C';
      pos1[0] = new THREE.Vector3(0,-L/2, L/2);
      euler1[0] = new THREE.Euler (Math.PI/2,0,-Math.PI/2, 'ZYX');
      euler2[0] = new THREE.Euler (0,Math.PI/2,Math.PI, 'ZYX');

      pos1[1] = new THREE.Vector3(L/2,-L/2, 0);
      euler1[1] = new THREE.Euler (0,Math.PI/2,-Math.PI/2, 'ZYX');
      euler2[1] = new THREE.Euler (-Math.PI/2,0,Math.PI, 'ZYX');
      
      pos1[2] = new THREE.Vector3(0,-L/2, -L/2);
      euler1[2] = new THREE.Euler (-Math.PI/2,0,Math.PI/2, 'ZYX');
      euler2[2] = new THREE.Euler (0,-Math.PI/2,0, 'ZYX');
      
      pos1[3] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[3] = new THREE.Euler (0,Math.PI/2,Math.PI/2, 'ZYX');
      euler2[3] = new THREE.Euler (-Math.PI/2,0,0, 'ZYX');
      
      pos1[4] = new THREE.Vector3(0,-L, 0);
      euler1[4] = new THREE.Euler (0,Math.PI/2,Math.PI, 'ZYX');
      euler2[4] = new THREE.Euler (-Math.PI/2,0,Math.PI/2, 'ZYX');
      
      pos1[5] = new THREE.Vector3(0,0,0);
      euler1[5] = new THREE.Euler (0,-Math.PI/2,0, 'ZYX');
      euler2[5] = new THREE.Euler (Math.PI/2,0,-Math.PI/2, 'ZYX');

      GroupA.children[0].position.copy (pos1[0]);
      GroupA.children[0].rotation.copy (new THREE.Euler (Math.PI/2,0,Math.PI/2, 'ZYX'));
      GroupB.children[0].position.copy (pos1[1]);
      GroupB.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,-Math.PI/2, 'ZYX'));
      GroupC.children[0].position.copy (pos1[2]);
      GroupC.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0,-Math.PI/2, 'ZYX'));
      GroupD.children[0].position.copy (pos1[3]);
      GroupD.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,Math.PI/2, 'ZYX'));
      GroupE.children[0].position.copy (pos1[4]);
      GroupE.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,Math.PI, 'ZYX'));
      GroupF.children[0].position.copy (pos1[5]);
      GroupF.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,0, 'ZYX'));
      turning = 0; //not yet turning		
      manIn = 'C';
      moving = 'FtoC'; 
    }
    if (eT==3&&which == 'D'&&manIn=='F') {
      //currentPlane = 'F';
      //nextPlane = 'D';
      pos1[0] = new THREE.Vector3(0,-L/2, L/2);
      euler1[0] = new THREE.Euler (Math.PI/2,0,Math.PI, 'ZYX');
      euler2[0] = new THREE.Euler (0,Math.PI/2,Math.PI/2, 'ZYX');

      pos1[1] = new THREE.Vector3(L/2,-L/2, 0);
      euler1[1] = new THREE.Euler (0,0,-Math.PI/2, 'ZYX');
      euler2[1] = new THREE.Euler (0,0,Math.PI, 'ZYX');
      
      pos1[2] = new THREE.Vector3(0,-L/2, -L/2);
      euler1[2] = new THREE.Euler (-Math.PI/2,0,Math.PI, 'ZYX');
      euler2[2] = new THREE.Euler (0,-Math.PI/2,Math.PI/2, 'ZYX');
      
      pos1[3] = new THREE.Vector3(-L/2,-L/2, 0);
      euler1[3] = new THREE.Euler (0,0,Math.PI/2, 'ZYX');
      euler2[3] = new THREE.Euler (0,0,0, 'ZYX');
      
      pos1[4] = new THREE.Vector3(0,-L, 0);
      euler1[4] = new THREE.Euler (0,0,Math.PI, 'ZYX');
      euler2[4] = new THREE.Euler (0,0,Math.PI/2, 'ZYX');
      
      pos1[5] = new THREE.Vector3(0,0,0);
      euler1[5] = new THREE.Euler (0,Math.PI,0, 'ZYX');
      euler2[5] = new THREE.Euler (0,Math.PI,Math.PI/2, 'ZYX');

      GroupA.children[0].position.copy (pos1[0]);
      GroupA.children[0].rotation.copy (new THREE.Euler (Math.PI/2,0,Math.PI/2, 'ZYX'));
      GroupB.children[0].position.copy (pos1[1]);
      GroupB.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,-Math.PI/2, 'ZYX'));
      GroupC.children[0].position.copy (pos1[2]);
      GroupC.children[0].rotation.copy (new THREE.Euler (-Math.PI/2,0,-Math.PI/2, 'ZYX'));
      GroupD.children[0].position.copy (pos1[3]);
      GroupD.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,Math.PI/2, 'ZYX'));
      GroupE.children[0].position.copy (pos1[4]);
      GroupE.children[0].rotation.copy (new THREE.Euler (0,-Math.PI/2,Math.PI, 'ZYX'));
      GroupF.children[0].position.copy (pos1[5]);
      GroupF.children[0].rotation.copy (new THREE.Euler (0,Math.PI/2,0, 'ZYX'));
      turning = 0; //not yet turning		
      manIn = 'D';
      moving = 'FtoD'; 
    }
    
    if(eT>3&&moving == 'AtoE'&&manIn=='E')AtoE(); 
    if(eT>3&&moving == 'AtoB'&&manIn=='B')AtoB();
    if(eT>3&&moving == 'AtoD'&&manIn=='D')AtoD(); 
    if(eT>3&&moving == 'AtoF'&&manIn=='F')AtoF(); 
    
    if(eT>3&&moving == 'BtoC'&&manIn=='C')BtoC();
    if(eT>3&&moving == 'BtoE'&&manIn=='E')BtoE();
    if(eT>3&&moving == 'BtoA'&&manIn=='A')BtoA(); 
    if(eT>3&&moving == 'BtoF'&&manIn=='F')BtoF(); 
    
    if(eT>3&&moving == 'CtoD'&&manIn=='D')CtoD(); 
    if(eT>3&&moving == 'CtoE'&&manIn=='E')CtoE(); 
    if(eT>3&&moving == 'CtoB'&&manIn=='B')CtoB(); 
    if(eT>3&&moving == 'CtoF'&&manIn=='F')CtoF(); 
    
    if(eT>3&&moving == 'DtoA'&&manIn=='A')DtoA(); 
    if(eT>3&&moving == 'DtoE'&&manIn=='E')DtoE(); 
    if(eT>3&&moving == 'DtoC'&&manIn=='C')DtoC(); 
    if(eT>3&&moving == 'DtoF'&&manIn=='F')DtoF(); 
    
    if(eT>3&&moving == 'EtoA'&&manIn=='A')EtoA(); 
    if(eT>3&&moving == 'EtoB'&&manIn=='B')EtoB(); 
    if(eT>3&&moving == 'EtoC'&&manIn=='C')EtoC(); 
    if(eT>3&&moving == 'EtoD'&&manIn=='D')EtoD(); 
    
    if(eT>3&&moving == 'FtoA'&&manIn=='A')FtoA(); 
    if(eT>3&&moving == 'FtoB'&&manIn=='B')FtoB(); 
    if(eT>3&&moving == 'FtoC'&&manIn=='C')FtoC(); 
    if(eT>3&&moving == 'FtoD'&&manIn=='D')FtoD(); 
    //////////////////////////////////////////////
    requestAnimationFrame(animate);
    render();

  }
  function AtoB() {
  var triStep = .90;
    if (turning === 0) {
      if(GroupA.children[0].rotation.y>0){
        GroupA.children[0].rotation.y -= 0.05;
        GroupB.children[0].rotation.z -= 0.05;
        GroupC.children[0].rotation.y -= 0.05;
        GroupD.children[0].rotation.z -= 0.05;
        GroupE.children[0].rotation.z -= 0.05;
        GroupF.children[0].rotation.z += 0.05;
      }
      else{
        GroupA.children[0].position.x += triStep;
        GroupB.children[0].position.y += triStep;
        GroupC.children[0].position.x += triStep;
        GroupD.children[0].position.y -= triStep;
        GroupE.children[0].position.x += triStep;
        GroupF.children[0].position.x += triStep;
      }
      if (GroupA.children[0].position.x > L/2-L/kk&&GroupB.children[0].position.y > -L/kk) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(L/2-L/kk, 0, 0);
        pos2[0] = new THREE.Vector3(L/2, 0, 0);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        /////////////////////
        pos1[1] = new THREE.Vector3(0,-L/kk, L/2);
        pos2[1] = new THREE.Vector3(0, 0, L/2);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ////////////////////
        pos1[2] = new THREE.Vector3(L/2-L/kk,-L, 0);
        pos2[2] = new THREE.Vector3(L/2,-L, 0);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ////////////////////
        pos1[3] = new THREE.Vector3(0,-L+L/kk, L/2);
        pos2[3] = new THREE.Vector3(0,-L, L/2);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(L/2-L/kk,-L/2, L/2);
        pos2[4] = new THREE.Vector3(L/2,-L/2, L/2);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(L/2-L/kk,-L/2, -L/2);
        pos2[5] = new THREE.Vector3(L/2,-L/2, -L/2);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
    
      if (GroupA.children[0].position.y < -L/2&&GroupB.children[0].position.z < 0) {
        if(GroupA.children[0].rotation.y<Math.PI/2){
        GroupA.children[0].rotation.y += 0.05;
        GroupB.children[0].rotation.y += 0.05;
        GroupC.children[0].rotation.y += 0.05;
        GroupD.children[0].rotation.y += 0.05;
        GroupE.children[0].rotation.y += 0.05;
        GroupF.children[0].rotation.y += 0.05;
        }
        else moving = false;
      }
      else{
        GroupA.children[0].position.y -= triStep;
        GroupB.children[0].position.z -= triStep;
        GroupC.children[0].position.y += triStep;
        GroupD.children[0].position.z -= triStep;
        GroupE.children[0].position.z -= triStep;
        GroupF.children[0].position.z += triStep;
      }
    }
  }
  function AtoD() {
  var triStep = .90;
    if (turning === 0) {
      if(GroupA.children[0].rotation.y<Math.PI){
        GroupA.children[0].rotation.y += 0.05;
        GroupB.children[0].rotation.z += 0.05;
        GroupC.children[0].rotation.y += 0.05;
        GroupD.children[0].rotation.z += 0.05;
        GroupE.children[0].rotation.z += 0.05;
        GroupF.children[0].rotation.z -= 0.05;
      }
      else{
        GroupA.children[0].position.x -= triStep;
        GroupB.children[0].position.y -= triStep;
        GroupC.children[0].position.x -= triStep;
        GroupD.children[0].position.y += triStep;
        GroupE.children[0].position.x -= triStep;
        GroupF.children[0].position.x -= triStep;
      }
      if (GroupA.children[0].position.x < -L/2+L/kk) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(-L/2+L/kk, 0, 0);
        pos2[0] = new THREE.Vector3(-L/2,0, 0);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        /////////////////////
        pos1[1] = new THREE.Vector3(0,-L+L/kk, L/2);
        pos2[1] = new THREE.Vector3(0,-L, L/2);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ////////////////////
        pos1[2] = new THREE.Vector3(-L/2+L/kk,-L, 0);
        pos2[2] = new THREE.Vector3(-L/2,-L, 0);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ////////////////////
        pos1[3] = new THREE.Vector3(0,-L/kk, L/2);
        pos2[3] = new THREE.Vector3(0,0, L/2);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(-L/2+L/kk,-L/2, L/2);
        pos2[4] = new THREE.Vector3(-L/2,-L/2, L/2);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(-L/2+L/kk,-L/2, -L/2);
        pos2[5] = new THREE.Vector3(-L/2,-L/2, -L/2);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
    
      if (GroupA.children[0].position.y < -L/2) {
        if(GroupA.children[0].rotation.y>Math.PI/2){
        GroupA.children[0].rotation.y -= 0.05;
        GroupB.children[0].rotation.y -= 0.05;
        GroupC.children[0].rotation.y -= 0.05;
        GroupD.children[0].rotation.y -= 0.05;
        GroupE.children[0].rotation.y -= 0.05;
        GroupF.children[0].rotation.y -= 0.05;
        }
        else moving = false;
      }
      else{
        GroupA.children[0].position.y -= triStep;
        GroupB.children[0].position.z -= triStep;
        GroupC.children[0].position.y += triStep;
        GroupD.children[0].position.z -= triStep;
        GroupE.children[0].position.z -= triStep;
        GroupF.children[0].position.z += triStep;
      }
    }
  }
  function AtoE() {
  var triStep = .90;
    if (turning === 0) {
      GroupA.children[0].position.z -= triStep;
      GroupB.children[0].position.x -= triStep;
      GroupC.children[0].position.z += triStep;
      GroupD.children[0].position.x += triStep;
      GroupE.children[0].position.y += triStep;
      GroupF.children[0].position.y -= triStep;
      if (GroupA.children[0].position.z < -L/2+L/kk&&GroupB.children[0].position.x < -L/2+L/kk) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(0, 0, -L/2+L/kk);
        pos2[0] = new THREE.Vector3(0, 0, -L/2);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        /////////////////
        pos1[1] = new THREE.Vector3(-L/2+L/kk,-L/2, L/2);
        pos2[1] = new THREE.Vector3(-L/2,-L/2, L/2);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        /////////////////
        pos1[2] = new THREE.Vector3(0,-L, L/2-L/kk);
        pos2[2] = new THREE.Vector3(0,-L, L/2);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        /////////////////
        pos1[3] = new THREE.Vector3(L/2-L/kk,-L/2, L/2);
        pos2[3] = new THREE.Vector3(L/2,-L/2, L/2);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        /////////////////
        pos1[4] = new THREE.Vector3(0,-L/kk, L/2);
        pos2[4] = new THREE.Vector3(0,0, L/2);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        /////////////////
        pos1[5] = new THREE.Vector3(0,-L+L/kk, -L/2);
        pos2[5] = new THREE.Vector3(0,-L, -L/2);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        /////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
        
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
    GroupA.children[0].position.y -= triStep;
    GroupB.children[0].position.z -= triStep;
    GroupC.children[0].position.y += triStep;
    GroupD.children[0].position.z -= triStep;
    GroupE.children[0].position.z -= triStep;
    GroupF.children[0].position.z += triStep;
      if (GroupA.children[0].position.y < -L/2) {
        moving = false;
      }
    }
  }
  function AtoF() {
  var triStep = .90;
    if (turning === 0) {
      if(GroupA.children[0].rotation.y>-Math.PI/2){
        GroupA.children[0].rotation.y -= 0.05;
        GroupB.children[0].rotation.z -= 0.05;
        GroupC.children[0].rotation.y -= 0.05;
        GroupD.children[0].rotation.z -= 0.05;
        GroupE.children[0].rotation.z -= 0.05;
        GroupF.children[0].rotation.z += 0.05;
      }
      else{
        GroupA.children[0].position.z += triStep;
        GroupB.children[0].position.x += triStep;
        GroupC.children[0].position.z -= triStep;
        GroupD.children[0].position.x -= triStep;
        GroupE.children[0].position.y -= triStep;
        GroupF.children[0].position.y += triStep;
      }
      if (GroupA.children[0].position.z > L/2-L/kk) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(0,0,L/2-L/kk);
        pos2[0] = new THREE.Vector3(0,0,L/2);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        /////////////////////
        pos1[1] = new THREE.Vector3(L/2-L/kk,-L/2, L/2);
        pos2[1] = new THREE.Vector3(L/2,-L/2, L/2);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ////////////////////
        pos1[2] = new THREE.Vector3(0,-L, -L/2+L/kk);
        pos2[2] = new THREE.Vector3(0,-L, -L/2);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ////////////////////
        pos1[3] = new THREE.Vector3(-L/2+L/kk,-L/2, L/2);
        pos2[3] = new THREE.Vector3(-L/2,-L/2, L/2);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(0,-L+L/kk, L/2);
        pos2[4] = new THREE.Vector3(0,-L, L/2);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(0,-L/kk, -L/2);
        pos2[5] = new THREE.Vector3(0,0, -L/2);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
    
      if (GroupA.children[0].position.y < -L/2) {
        if(GroupA.children[0].rotation.z<Math.PI/2){
        GroupA.children[0].rotation.z += 0.05;
        GroupB.children[0].rotation.y += 0.05;
        GroupC.children[0].rotation.z -= 0.05;
        GroupD.children[0].rotation.y += 0.05;
        GroupE.children[0].rotation.y += 0.05;
        GroupF.children[0].rotation.y += 0.05;
        }
        else moving = false;
      }
      else{
        GroupA.children[0].position.y -= triStep;
        GroupB.children[0].position.z -= triStep;
        GroupC.children[0].position.y += triStep;
        GroupD.children[0].position.z -= triStep;
        GroupE.children[0].position.z -= triStep;
        GroupF.children[0].position.z += triStep;
      }
    }
  }

  function BtoC() {
  var triStep = .90;
    if (turning === 0) {
      if(GroupA.children[0].rotation.y>0){
          GroupA.children[0].rotation.y -= 0.05;
          GroupB.children[0].rotation.y -= 0.05;
          GroupC.children[0].rotation.y -= 0.05;
          GroupD.children[0].rotation.y -= 0.05;
          GroupE.children[0].rotation.y -= 0.05;
          GroupF.children[0].rotation.y -= 0.05;
      }
      else{
        GroupA.children[0].position.y -= triStep;
        GroupB.children[0].position.z -= triStep;
        GroupC.children[0].position.y += triStep;
        GroupD.children[0].position.z -= triStep;
        GroupE.children[0].position.z -= triStep;
        GroupF.children[0].position.z += triStep;
      }
      if (GroupA.children[0].position.y < -L) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(L/2, -L, 0);
        pos2[0] = new THREE.Vector3(L/2, -L, 0);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        ///////////////////
        pos1[1] = new THREE.Vector3(0,0, -L/2);
        pos2[1] = new THREE.Vector3(0,0, -L/2);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ///////////////////
        pos1[2] = new THREE.Vector3(L/2,0, 0);
        pos2[2] = new THREE.Vector3(L/2,0, 0);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ///////////////////
        pos1[3] = new THREE.Vector3(0,-L, -L/2);
        pos2[3] = new THREE.Vector3(0,-L, -L/2);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(L/2,-L/2, -L/2);
        pos2[4] = new THREE.Vector3(L/2,-L/2, -L/2);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(L/2,-L/2, L/2);
        pos2[5] = new THREE.Vector3(L/2,-L/2, L/2);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
      if (GroupA.children[0].position.x < 0){
        if(GroupA.children[0].rotation.y<Math.PI/2){
          GroupA.children[0].rotation.y += 0.05;
          GroupB.children[0].rotation.z -= 0.05;
          GroupC.children[0].rotation.y += 0.05;
          GroupD.children[0].rotation.z -= 0.05;
          GroupE.children[0].rotation.z -= 0.05;
          GroupF.children[0].rotation.z += 0.05;
        }
        else moving = false;
      }
      else{
      GroupA.children[0].position.x -= triStep;
      GroupB.children[0].position.y -= triStep;
      GroupC.children[0].position.x -= triStep;
      GroupD.children[0].position.y += triStep;
      GroupE.children[0].position.x -= triStep;
      GroupF.children[0].position.x -= triStep;
      }
    }
  }
  function BtoE() {
  var triStep = .90;
    if (turning === 0) {
      GroupA.children[0].position.z -= triStep;
      GroupB.children[0].position.x -= triStep;
      GroupC.children[0].position.z += triStep;
      GroupD.children[0].position.x += triStep;
      GroupE.children[0].position.y += triStep;
      GroupF.children[0].position.y -= triStep;
      if (GroupA.children[0].position.z < -L/2) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(L/2, -L/2, -L/2);
        pos2[0] = new THREE.Vector3(L/2, -L/2, -L/2);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        ///////////////////
        pos1[1] = new THREE.Vector3(-L/2, 0, 0);
        pos2[1] = new THREE.Vector3(-L/2, 0, 0);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ///////////////////
        pos1[2] = new THREE.Vector3(L/2, -L/2, L/2);
        pos2[2] = new THREE.Vector3(L/2, -L/2, L/2);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ///////////////////
        pos1[3] = new THREE.Vector3(L/2, -L, 0);
        pos2[3] = new THREE.Vector3(L/2,-L, 0);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(L/2,0, 0);
        pos2[4] = new THREE.Vector3(L/2,0, 0);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(L/2,-L, 0);
        pos2[5] = new THREE.Vector3(L/2,-L, 0);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
    
      if (GroupA.children[0].position.x < 0){
        
        if(GroupA.children[0].rotation.z<Math.PI+Math.PI/2){
          GroupA.children[0].rotation.z += 0.05;
          GroupB.children[0].rotation.y -= 0.05;
          GroupC.children[0].rotation.z -= 0.05;
          GroupD.children[0].rotation.y -= 0.05;
          GroupE.children[0].rotation.y -= 0.05;
          GroupF.children[0].rotation.y -= 0.05;
        }
        else moving = false;
      }
      else{
        GroupA.children[0].position.x -= triStep;
        GroupB.children[0].position.y -= triStep;
        GroupC.children[0].position.x -= triStep;
        GroupD.children[0].position.y += triStep;
        GroupE.children[0].position.x -= triStep;
        GroupF.children[0].position.x -= triStep;
      }
    }
  }
  function BtoA() {
  var triStep = .90;
    if (turning === 0) {
      if(GroupA.children[0].rotation.y<Math.PI){
          GroupA.children[0].rotation.y += 0.05;
          GroupB.children[0].rotation.y += 0.05;
          GroupC.children[0].rotation.y += 0.05;
          GroupD.children[0].rotation.y += 0.05;
          GroupE.children[0].rotation.y += 0.05;
          GroupF.children[0].rotation.y += 0.05;
      }
      else{
        GroupA.children[0].position.y += triStep;
        GroupB.children[0].position.z += triStep;
        GroupC.children[0].position.y -= triStep;
        GroupD.children[0].position.z += triStep;
        GroupE.children[0].position.z += triStep;
        GroupF.children[0].position.z -= triStep;
      }
      if (GroupA.children[0].position.y > 0) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(L/2, 0, 0);
        pos2[0] = new THREE.Vector3(L/2, 0, 0);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        ///////////////////
        pos1[1] = new THREE.Vector3(0, 0, L/2);
        pos2[1] = new THREE.Vector3(0, 0, L/2);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ///////////////////
        pos1[2] = new THREE.Vector3(L/2,-L, 0);
        pos2[2] = new THREE.Vector3(L/2,-L, 0);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ///////////////////
        pos1[3] = new THREE.Vector3(0,-L, L/2);
        pos2[3] = new THREE.Vector3(0,-L, L/2);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(L/2,-L/2, L/2);
        pos2[4] = new THREE.Vector3(L/2,-L/2, L/2);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(L/2,-L/2, -L/2);
        pos2[5] = new THREE.Vector3(L/2,-L/2, -L/2);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
      if (GroupA.children[0].position.x < 0){
        if(GroupA.children[0].rotation.y>Math.PI/2){
          GroupA.children[0].rotation.y -= 0.05;
          GroupB.children[0].rotation.z -= 0.05;
          GroupC.children[0].rotation.y -= 0.05;
          GroupD.children[0].rotation.z -= 0.05;
          GroupE.children[0].rotation.z -= 0.05;
          GroupF.children[0].rotation.z += 0.05;
        }
        else moving = false;
      }
      else{
      GroupA.children[0].position.x -= triStep;
      GroupB.children[0].position.y -= triStep;
      GroupC.children[0].position.x -= triStep;
      GroupD.children[0].position.y += triStep;
      GroupE.children[0].position.x -= triStep;
      GroupF.children[0].position.x -= triStep;
      }
    }
  }
  function BtoF() {
  var triStep = .90;
    if (turning === 0) {
      if(GroupA.children[0].rotation.y>-Math.PI/2){
        GroupA.children[0].rotation.y -= 0.05;
        GroupB.children[0].rotation.y -= 0.05;
        GroupC.children[0].rotation.y -= 0.05;
        GroupD.children[0].rotation.y -= 0.05;
        GroupE.children[0].rotation.y -= 0.05;
        GroupF.children[0].rotation.y -= 0.05;
      }
      else{
        GroupA.children[0].position.z += triStep;
        GroupB.children[0].position.x += triStep;
        GroupC.children[0].position.z -= triStep;
        GroupD.children[0].position.x -= triStep;
        GroupE.children[0].position.y -= triStep;
        GroupF.children[0].position.y += triStep;
      }
      if (GroupA.children[0].position.z > L/2-L/kk) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(L/2, -L/2, L/2-L/kk);
        pos2[0] = new THREE.Vector3(L/2, -L/2, L/2);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        ///////////////////
        pos1[1] = new THREE.Vector3(L/2-L/kk, 0, 0);
        pos2[1] = new THREE.Vector3(L/2, 0, 0);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ///////////////////
        pos1[2] = new THREE.Vector3(L/2, -L/2, -L/2+L/kk);
        pos2[2] = new THREE.Vector3(L/2, -L/2, -L/2);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ///////////////////
        pos1[3] = new THREE.Vector3(-L/2+L/kk, -L, 0);
        pos2[3] = new THREE.Vector3(-L/2,-L, 0);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(L/2,-L+L/kk, 0);
        pos2[4] = new THREE.Vector3(L/2,-L, 0);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(L/2,-L/kk, 0);
        pos2[5] = new THREE.Vector3(L/2,0, 0);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
    
      if (GroupA.children[0].position.x < 0){
        
        if(GroupA.children[0].rotation.z>Math.PI/2){
          GroupA.children[0].rotation.z -= 0.05;
          GroupB.children[0].rotation.y -= 0.05;
          GroupC.children[0].rotation.z += 0.05;
          GroupD.children[0].rotation.y -= 0.05;
          GroupE.children[0].rotation.y -= 0.05;
          GroupF.children[0].rotation.y -= 0.05;
        }
        else moving = false;
      }
      else{
        GroupA.children[0].position.x -= triStep;
        GroupB.children[0].position.y -= triStep;
        GroupC.children[0].position.x -= triStep;
        GroupD.children[0].position.y += triStep;
        GroupE.children[0].position.x -= triStep;
        GroupF.children[0].position.x -= triStep;
      }
    }
  }

  function CtoD() {
  var triStep = .90;
    if (turning === 0) {
      if(GroupA.children[0].rotation.y>0){
        GroupA.children[0].rotation.y -= 0.05;
        GroupB.children[0].rotation.z += 0.05;
        GroupC.children[0].rotation.y -= 0.05;
        GroupD.children[0].rotation.z += 0.05;
        GroupE.children[0].rotation.z += 0.05;
        GroupF.children[0].rotation.z -= 0.05;
      }
      else{
        GroupA.children[0].position.x -= triStep;
        GroupB.children[0].position.y -= triStep;
        GroupC.children[0].position.x -= triStep;
        GroupD.children[0].position.y += triStep;
        GroupE.children[0].position.x -= triStep;
        GroupF.children[0].position.x -= triStep;
      }
      if (GroupA.children[0].position.x < -L/2+L/kk) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(-L/2+L/kk,-L, 0);
        pos2[0] = new THREE.Vector3(-L/2,-L, 0);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        ///////////////////
        pos1[1] = new THREE.Vector3(0,-L+L/kk, -L/2);
        pos2[1] = new THREE.Vector3(0,-L, -L/2);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ///////////////////
        pos1[2] = new THREE.Vector3(-L/2+L/kk,0, 0);
        pos2[2] = new THREE.Vector3(-L/2,0, 0);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ///////////////////
        pos1[3] = new THREE.Vector3(0,-L/kk, -L/2);
        pos2[3] = new THREE.Vector3(0,0, -L/2);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(-L/2+L/kk,-L/2, -L/2);
        pos2[4] = new THREE.Vector3(-L/2,-L/2, -L/2);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(-L/2+L/kk,-L/2, L/2);
        pos2[5] = new THREE.Vector3(-L/2,-L/2, L/2);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
    
      if (GroupA.children[0].position.y > -L/2){
        
        if(GroupA.children[0].rotation.y<Math.PI/2){
          GroupA.children[0].rotation.y += 0.05;
          GroupB.children[0].rotation.y += 0.05;
          GroupC.children[0].rotation.y += 0.05;
          GroupD.children[0].rotation.y += 0.05;
          GroupE.children[0].rotation.y += 0.05;
          GroupF.children[0].rotation.y += 0.05;
        }
        else moving = false;
      }
      else{
        GroupA.children[0].position.y += triStep;
        GroupB.children[0].position.z += triStep;
        GroupC.children[0].position.y -= triStep;
        GroupD.children[0].position.z += triStep;
        GroupE.children[0].position.z += triStep;
        GroupF.children[0].position.z -= triStep;
      }
    }
  }
  function CtoB() {
  var triStep = .90;
    if (turning === 0) {
      if(GroupA.children[0].rotation.y<Math.PI){
        GroupA.children[0].rotation.y += 0.05;
        GroupB.children[0].rotation.z -= 0.05;
        GroupC.children[0].rotation.y += 0.05;
        GroupD.children[0].rotation.z -= 0.05;
        GroupE.children[0].rotation.z -= 0.05;
        GroupF.children[0].rotation.z += 0.05;
      }
      else{
        GroupA.children[0].position.x += triStep;
        GroupB.children[0].position.y += triStep;
        GroupC.children[0].position.x += triStep;
        GroupD.children[0].position.y -= triStep;
        GroupE.children[0].position.x += triStep;
        GroupF.children[0].position.x += triStep;
      }
      if (GroupA.children[0].position.x > L/2-L/kk) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(L/2-L/kk,-L, 0);
        pos2[0] = new THREE.Vector3(L/2,-L, 0);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        ///////////////////
        pos1[1] = new THREE.Vector3(0,-L/kk, -L/2);
        pos2[1] = new THREE.Vector3(0,0, -L/2);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ///////////////////
        pos1[2] = new THREE.Vector3(L/2-L/kk,0, 0);
        pos2[2] = new THREE.Vector3(L/2,0, 0);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ///////////////////
        pos1[3] = new THREE.Vector3(0,-L+L/kk, -L/2);
        pos2[3] = new THREE.Vector3(0,-L, -L/2);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(L/2-L/kk,-L/2, -L/2);
        pos2[4] = new THREE.Vector3(L/2,-L/2, -L/2);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(L/2-L/kk,-L/2, L/2);
        pos2[5] = new THREE.Vector3(L/2,-L/2, L/2);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
    
      if (GroupA.children[0].position.y > -L/2){
        
        if(GroupA.children[0].rotation.y > Math.PI/2){
          GroupA.children[0].rotation.y -= 0.05;
          GroupB.children[0].rotation.y -= 0.05;
          GroupC.children[0].rotation.y -= 0.05;
          GroupD.children[0].rotation.y -= 0.05;
          GroupE.children[0].rotation.y -= 0.05;
          GroupF.children[0].rotation.y -= 0.05;
        }
        else moving = false;
      }
      else{
        GroupA.children[0].position.y += triStep;
        GroupB.children[0].position.z += triStep;
        GroupC.children[0].position.y -= triStep;
        GroupD.children[0].position.z += triStep;
        GroupE.children[0].position.z += triStep;
        GroupF.children[0].position.z -= triStep;
      }
    }
  }
  function CtoE() {
  var triStep = .90;
    if (turning === 0) {
      GroupA.children[0].position.z -= triStep;
      GroupB.children[0].position.x -= triStep;
      GroupC.children[0].position.z += triStep;
      GroupD.children[0].position.x += triStep;
      GroupE.children[0].position.y += triStep;
      GroupF.children[0].position.y -= triStep;
      if (GroupA.children[0].position.z < -L/2) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(0,-L, -L/2);
        pos2[0] = new THREE.Vector3(0,-L, -L/2);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        ///////////////////
        pos1[1] = new THREE.Vector3(-L/2,-L/2, -L/2);
        pos2[1] = new THREE.Vector3(-L/2,-L/2, -L/2);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ///////////////////
        pos1[2] = new THREE.Vector3(0,0,L/2);
        pos2[2] = new THREE.Vector3(0,0,L/2);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ///////////////////
        pos1[3] = new THREE.Vector3(L/2,-L/2, -L/2);
        pos2[3] = new THREE.Vector3(L/2,-L/2, -L/2);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(0,0, -L/2);
        pos2[4] = new THREE.Vector3(0,0, -L/2);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(0,-L, L/2);
        pos2[5] = new THREE.Vector3(0,-L, L/2);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
    
      if (GroupA.children[0].position.y > -L/2){
        
        if(GroupA.children[0].rotation.z < Math.PI + Math.PI/2){
          GroupA.children[0].rotation.z += 0.05;
          GroupB.children[0].rotation.y -= 0.05;
          GroupC.children[0].rotation.z -= 0.05;
          GroupD.children[0].rotation.y -= 0.05;
          GroupE.children[0].rotation.y -= 0.05;
          GroupF.children[0].rotation.y -= 0.05;
        }
        else moving = false;
      }
      else{
        GroupA.children[0].position.y += triStep;
        GroupB.children[0].position.z += triStep;
        GroupC.children[0].position.y -= triStep;
        GroupD.children[0].position.z += triStep;
        GroupE.children[0].position.z += triStep;
        GroupF.children[0].position.z -= triStep;
      }
    }
  }
  function CtoF() {
  var triStep = .90;
    if (turning === 0) {
      if(GroupA.children[0].rotation.y>-Math.PI/2){
        GroupA.children[0].rotation.y -= 0.05;
        GroupB.children[0].rotation.z += 0.05;
        GroupC.children[0].rotation.y -= 0.05;
        GroupD.children[0].rotation.z += 0.05;
        GroupE.children[0].rotation.z += 0.05;
        GroupF.children[0].rotation.z -= 0.05;
      }
      else{
        GroupA.children[0].position.z += triStep;
        GroupB.children[0].position.x += triStep;
        GroupC.children[0].position.z -= triStep;
        GroupD.children[0].position.x -= triStep;
        GroupE.children[0].position.y -= triStep;
        GroupF.children[0].position.y += triStep;
      }
      if (GroupA.children[0].position.z > L/2) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(0,-L, L/2);
        pos2[0] = new THREE.Vector3(0,-L, L/2);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        ///////////////////
        pos1[1] = new THREE.Vector3(L/2,-L/2, -L/2);
        pos2[1] = new THREE.Vector3(L/2,-L/2, -L/2);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ///////////////////
        pos1[2] = new THREE.Vector3(0,0,-L/2);
        pos2[2] = new THREE.Vector3(0,0,-L/2);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ///////////////////
        pos1[3] = new THREE.Vector3(-L/2,-L/2, -L/2);
        pos2[3] = new THREE.Vector3(-L/2,-L/2, -L/2);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(0,-L, -L/2);
        pos2[4] = new THREE.Vector3(0,-L, -L/2);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(0,0, L/2);
        pos2[5] = new THREE.Vector3(0,0, L/2);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
    
      if (GroupA.children[0].position.y > -L/2){
          moving = false;
      }
      else{
        GroupA.children[0].position.y += triStep;
        GroupB.children[0].position.z += triStep;
        GroupC.children[0].position.y -= triStep;
        GroupD.children[0].position.z += triStep;
        GroupE.children[0].position.z += triStep;
        GroupF.children[0].position.z -= triStep;
      }
    }
  }

  function DtoA() {
  var triStep = .90;
    if (turning === 0) {
      if(GroupA.children[0].rotation.y > 0){
          GroupA.children[0].rotation.y -= 0.05;
          GroupB.children[0].rotation.y -= 0.05;
          GroupC.children[0].rotation.y -= 0.05;
          GroupD.children[0].rotation.y -= 0.05;
          GroupE.children[0].rotation.y -= 0.05;
          GroupF.children[0].rotation.y -= 0.05;
      }
      else{
        GroupA.children[0].position.y += triStep;
        GroupB.children[0].position.z += triStep;
        GroupC.children[0].position.y -= triStep;
        GroupD.children[0].position.z += triStep;
        GroupE.children[0].position.z += triStep;
        GroupF.children[0].position.z -= triStep;
      }
      if (GroupA.children[0].position.y > -L/kk) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(-L/2,-L/kk, 0);
        pos2[0] = new THREE.Vector3(-L/2,0, 0);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        ///////////////////
        pos1[1] = new THREE.Vector3(0,-L, L/2-L/kk);
        pos2[1] = new THREE.Vector3(0,-L, L/2);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ///////////////////
        pos1[2] = new THREE.Vector3(-L/2,-L+L/kk, 0);
        pos2[2] = new THREE.Vector3(-L/2,-L, 0);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ///////////////////
        pos1[3] = new THREE.Vector3(0,0, L/2-L/kk);
        pos2[3] = new THREE.Vector3(0,0, L/2);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(-L/2,-L/2, L/2-L/kk);
        pos2[4] = new THREE.Vector3(-L/2,-L/2, L/2);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(-L/2,-L/2, -L/2+L/kk);
        pos2[5] = new THREE.Vector3(-L/2,-L/2, -L/2);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
    
      if (GroupA.children[0].position.x > 0){
        
        if(GroupA.children[0].rotation.y < Math.PI/2){
          GroupA.children[0].rotation.y += 0.05;
          GroupB.children[0].rotation.z += 0.05;
          GroupC.children[0].rotation.y -= 0.05;
          GroupD.children[0].rotation.z += 0.05;
          GroupE.children[0].rotation.z += 0.05;
          GroupF.children[0].rotation.z -= 0.05;
        }
        else moving = false;
      }
      else{
        GroupA.children[0].position.x += triStep;
        GroupB.children[0].position.y += triStep;
        GroupC.children[0].position.x += triStep;
        GroupD.children[0].position.y -= triStep;
        GroupE.children[0].position.x += triStep;
        GroupF.children[0].position.x += triStep;
      }
    }
  }
  function DtoC() {
  var triStep = .90;
    if (turning === 0) {
      if(GroupA.children[0].rotation.y < Math.PI){
          GroupA.children[0].rotation.y += 0.05;
          GroupB.children[0].rotation.y += 0.05;
          GroupC.children[0].rotation.y += 0.05;
          GroupD.children[0].rotation.y += 0.05;
          GroupE.children[0].rotation.y += 0.05;
          GroupF.children[0].rotation.y += 0.05;
      }
      else{
        GroupA.children[0].position.y -= triStep;
        GroupB.children[0].position.z -= triStep;
        GroupC.children[0].position.y += triStep;
        GroupD.children[0].position.z -= triStep;
        GroupE.children[0].position.z -= triStep;
        GroupF.children[0].position.z += triStep;
      }
      if (GroupA.children[0].position.y < -L +L/kk) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(-L/2,-L+L/kk, 0);
        pos2[0] = new THREE.Vector3(-L/2,-L, 0);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        ///////////////////
        pos1[1] = new THREE.Vector3(0,-L, -L/2+L/kk);
        pos2[1] = new THREE.Vector3(0,-L, -L/2);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ///////////////////
        pos1[2] = new THREE.Vector3(-L/2,-L/kk, 0);
        pos2[2] = new THREE.Vector3(-L/2,0, 0);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ///////////////////
        pos1[3] = new THREE.Vector3(0,0, -L/2+L/kk);
        pos2[3] = new THREE.Vector3(0,0, -L/2);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(-L/2,-L/2, -L/2+L/kk);
        pos2[4] = new THREE.Vector3(-L/2,-L/2, -L/2);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(-L/2,-L/2, L/2-L/kk);
        pos2[5] = new THREE.Vector3(-L/2,-L/2, L/2);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
    
      if (GroupA.children[0].position.x > 0){
        
        if(GroupA.children[0].rotation.y < Math.PI/2){
          GroupA.children[0].rotation.y += 0.05;
          GroupB.children[0].rotation.z += 0.05;
          GroupC.children[0].rotation.y -= 0.05;
          GroupD.children[0].rotation.z += 0.05;
          GroupE.children[0].rotation.z += 0.05;
          GroupF.children[0].rotation.z -= 0.05;
        }
        else moving = false;
      }
      else{
        GroupA.children[0].position.x += triStep;
        GroupB.children[0].position.y += triStep;
        GroupC.children[0].position.x += triStep;
        GroupD.children[0].position.y -= triStep;
        GroupE.children[0].position.x += triStep;
        GroupF.children[0].position.x += triStep;
      }
    }
  }
  function DtoE() {
  var triStep = .90;
    if (turning === 0) {
      GroupA.children[0].position.z -= triStep;
      GroupB.children[0].position.x -= triStep;
      GroupC.children[0].position.z += triStep;
      GroupD.children[0].position.x += triStep;
      GroupE.children[0].position.y += triStep;
      GroupF.children[0].position.y -= triStep;
      if (GroupA.children[0].position.z < -L/2) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(-L/2,-L/2, -L/2);
        pos2[0] = new THREE.Vector3(-L/2,-L/2, -L/2);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        ///////////////////
        pos1[1] = new THREE.Vector3(-L/2,-L, 0);
        pos2[1] = new THREE.Vector3(-L/2,-L, 0);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ///////////////////
        pos1[2] = new THREE.Vector3(-L/2,-L/2, L/2);
        pos2[2] = new THREE.Vector3(-L/2,-L/2, L/2);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ///////////////////
        pos1[3] = new THREE.Vector3(L/2,0,0);
        pos2[3] = new THREE.Vector3(L/2,0,0);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(-L/2,0, 0);
        pos2[4] = new THREE.Vector3(-L/2,0, 0);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(-L/2,-L, 0);
        pos2[5] = new THREE.Vector3(-L/2,-L, 0);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
    
      if (GroupA.children[0].position.x > 0){
        
        if(GroupA.children[0].rotation.z > -Math.PI/2){
          GroupA.children[0].rotation.z -= 0.05;
          GroupB.children[0].rotation.y += 0.05;
          GroupC.children[0].rotation.z += 0.05;
          GroupD.children[0].rotation.y += 0.05;
          GroupE.children[0].rotation.y += 0.05;
          GroupF.children[0].rotation.y -= 0.05;
        }
        else moving = false;
      }
      else{
        GroupA.children[0].position.x += triStep;
        GroupB.children[0].position.y += triStep;
        GroupC.children[0].position.x += triStep;
        GroupD.children[0].position.y -= triStep;
        GroupE.children[0].position.x += triStep;
        GroupF.children[0].position.x += triStep;
      }
    }
  }
  function DtoF() {
  var triStep = .90;
    if (turning === 0) {
      if(GroupA.children[0].rotation.y > -Math.PI/2){
        GroupA.children[0].rotation.y -= 0.05;
        GroupB.children[0].rotation.y -= 0.05;
        GroupC.children[0].rotation.y -= 0.05;
        GroupD.children[0].rotation.y -= 0.05;
        GroupE.children[0].rotation.y -= 0.05;
        GroupF.children[0].rotation.y -= 0.05;
      }
      else{
        GroupA.children[0].position.z += triStep;
        GroupB.children[0].position.x += triStep;
        GroupC.children[0].position.z -= triStep;
        GroupD.children[0].position.x -= triStep;
        GroupE.children[0].position.y -= triStep;
        GroupF.children[0].position.y += triStep;
      }
      if (GroupA.children[0].position.z > L/2) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(-L/2,-L/2, L/2);
        pos2[0] = new THREE.Vector3(-L/2,-L/2, L/2);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        ///////////////////
        pos1[1] = new THREE.Vector3(L/2,-L, 0);
        pos2[1] = new THREE.Vector3(L/2,-L, 0);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ///////////////////
        pos1[2] = new THREE.Vector3(-L/2,-L/2, -L/2);
        pos2[2] = new THREE.Vector3(-L/2,-L/2, -L/2);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ///////////////////
        pos1[3] = new THREE.Vector3(-L/2,0,0);
        pos2[3] = new THREE.Vector3(-L/2,0,0);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(-L/2,-L, 0);
        pos2[4] = new THREE.Vector3(-L/2,-L, 0);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(-L/2,0, 0);
        pos2[5] = new THREE.Vector3(-L/2,0, 0);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
    
      if (GroupA.children[0].position.x > 0){
        
        if(GroupA.children[0].rotation.z < Math.PI/2){
          GroupA.children[0].rotation.z += 0.05;
          GroupB.children[0].rotation.y -= 0.05;
          GroupC.children[0].rotation.z -= 0.05;
          GroupD.children[0].rotation.y += 0.05;
          GroupE.children[0].rotation.y -= 0.05;
          GroupF.children[0].rotation.y += 0.05;
        }
        else moving = false;
      }
      else{
        GroupA.children[0].position.x += triStep;
        GroupB.children[0].position.y += triStep;
        GroupC.children[0].position.x += triStep;
        GroupD.children[0].position.y -= triStep;
        GroupE.children[0].position.x += triStep;
        GroupF.children[0].position.x += triStep;
      }
    }
  }

  function EtoA() {
  var triStep = .90;
    if (turning === 0) {
      if(GroupA.children[0].rotation.z <Math.PI/2){
        GroupA.children[0].rotation.z += 0.05;
        GroupB.children[0].rotation.y -= 0.05;
        GroupC.children[0].rotation.z -= 0.05;
        GroupD.children[0].rotation.y -= 0.05;
        GroupE.children[0].rotation.y -= 0.05;
        GroupF.children[0].rotation.y -= 0.05;
      }
      else{
        GroupA.children[0].position.y += triStep;
        GroupB.children[0].position.z += triStep;
        GroupC.children[0].position.y -= triStep;
        GroupD.children[0].position.z += triStep;
        GroupE.children[0].position.z += triStep;
        GroupF.children[0].position.z -= triStep;
      }
      if (GroupA.children[0].position.y > 0) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(0,0, -L/2);
        pos2[0] = new THREE.Vector3(0,0, -L/2);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        ///////////////////
        pos1[1] = new THREE.Vector3(-L/2,-L/2, L/2);
        pos2[1] = new THREE.Vector3(-L/2,-L/2, L/2);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ///////////////////
        pos1[2] = new THREE.Vector3(0,-L, L/2);
        pos2[2] = new THREE.Vector3(0,-L, L/2);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ///////////////////
        pos1[3] = new THREE.Vector3(L/2,-L/2, L/2);
        pos2[3] = new THREE.Vector3(L/2,-L/2, L/2);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(0,0,L/2);
        pos2[4] = new THREE.Vector3(0,0,L/2);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(0,-L, -L/2);
        pos2[5] = new THREE.Vector3(0,-L, -L/2);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
    
      if (GroupA.children[0].position.z > 0){
        
        if(GroupA.children[0].rotation.y < Math.PI/2){
          GroupA.children[0].rotation.y += 0.05;
          GroupB.children[0].rotation.z += 0.05;
          GroupC.children[0].rotation.y += 0.05;
          GroupD.children[0].rotation.z += 0.05;
          GroupE.children[0].rotation.z += 0.05;
          GroupF.children[0].rotation.z -= 0.05;
        }
        else moving = false;
      }
      else{
        GroupA.children[0].position.z += triStep;
        GroupB.children[0].position.x += triStep;
        GroupC.children[0].position.z -= triStep;
        GroupD.children[0].position.x -= triStep;
        GroupE.children[0].position.y -= triStep;
        GroupF.children[0].position.y += triStep;
      }
    }
  }
  function EtoC() {
  var triStep = .90;
    if (turning === 0) {
      GroupA.children[0].position.y -= triStep;
      GroupB.children[0].position.z -= triStep;
      GroupC.children[0].position.y += triStep;
      GroupD.children[0].position.z -= triStep;
      GroupE.children[0].position.z -= triStep;
      GroupF.children[0].position.z += triStep;
      if (GroupA.children[0].position.y < -L) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(0,-L, -L/2);
        pos2[0] = new THREE.Vector3(0,-L, -L/2);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        ///////////////////
        pos1[1] = new THREE.Vector3(-L/2,-L/2, -L/2);
        pos2[1] = new THREE.Vector3(-L/2,-L/2, -L/2);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ///////////////////
        pos1[2] = new THREE.Vector3(0,0, L/2);
        pos2[2] = new THREE.Vector3(0,0, L/2);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ///////////////////
        pos1[3] = new THREE.Vector3(L/2,-L/2, -L/2);
        pos2[3] = new THREE.Vector3(L/2,-L/2, -L/2);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(0,0,-L/2);
        pos2[4] = new THREE.Vector3(0,0,-L/2);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(0,-L, L/2);
        pos2[5] = new THREE.Vector3(0,-L, L/2);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
    
      if (GroupA.children[0].position.z > 0){
        
        if(GroupA.children[0].rotation.y > -Math.PI/2-Math.PI){
          GroupA.children[0].rotation.y -= 0.05;
          GroupB.children[0].rotation.z -= 0.05;
          GroupC.children[0].rotation.y += 0.05;
          GroupD.children[0].rotation.z -= 0.05;
          GroupE.children[0].rotation.z -= 0.05;
          GroupF.children[0].rotation.z += 0.05;
        }
        else moving = false;
      }
      else{
        GroupA.children[0].position.z += triStep;
        GroupB.children[0].position.x += triStep;
        GroupC.children[0].position.z -= triStep;
        GroupD.children[0].position.x -= triStep;
        GroupE.children[0].position.y -= triStep;
        GroupF.children[0].position.y += triStep;
      }
    }
  }
  function EtoB() {
  var triStep = .90;
    if (turning === 0) {
      if(GroupA.children[0].rotation.z < 0){
        GroupA.children[0].rotation.z += 0.05;
        GroupB.children[0].rotation.y -= 0.05;
        GroupC.children[0].rotation.z -= 0.05;
        GroupD.children[0].rotation.y -= 0.05;
        GroupE.children[0].rotation.y -= 0.05;
        GroupF.children[0].rotation.y -= 0.05;
      }
      else{
        GroupA.children[0].position.x += triStep;
        GroupB.children[0].position.y += triStep;
        GroupC.children[0].position.x += triStep;
        GroupD.children[0].position.y -= triStep;
        GroupE.children[0].position.x += triStep;
        GroupF.children[0].position.x += triStep;
      }
      if (GroupA.children[0].position.x > L/2) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(L/2,-L/2, -L/2);
        pos2[0] = new THREE.Vector3(L/2,-L/2, -L/2);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        ///////////////////
        pos1[1] = new THREE.Vector3(-L/2,0, 0);
        pos2[1] = new THREE.Vector3(-L/2,0, 0);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ///////////////////
        pos1[2] = new THREE.Vector3(L/2,-L/2, L/2);
        pos2[2] = new THREE.Vector3(L/2,-L/2, L/2);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ///////////////////
        pos1[3] = new THREE.Vector3(L/2,-L, 0);
        pos2[3] = new THREE.Vector3(L/2,-L, 0);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(L/2,0, 0);
        pos2[4] = new THREE.Vector3(L/2,0, 0);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(L/2,-L, 0);
        pos2[5] = new THREE.Vector3(L/2,-L, 0);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
    
      if (GroupA.children[0].position.z > 0){
        
        if(GroupA.children[0].rotation.y < Math.PI/2){
          GroupA.children[0].rotation.y += 0.05;
          GroupB.children[0].rotation.y += 0.05;
          GroupC.children[0].rotation.y += 0.05;
          GroupD.children[0].rotation.y += 0.05;
          GroupE.children[0].rotation.y += 0.05;
          GroupF.children[0].rotation.y += 0.05;
        }
        else moving = false;
      }
      else{
        GroupA.children[0].position.z += triStep;
        GroupB.children[0].position.x += triStep;
        GroupC.children[0].position.z -= triStep;
        GroupD.children[0].position.x -= triStep;
        GroupE.children[0].position.y -= triStep;
        GroupF.children[0].position.y += triStep;
      }
    }
  }
  function EtoD() {
  var triStep = .90;
    if (turning === 0) {
      if(GroupA.children[0].rotation.z > -Math.PI){
        GroupA.children[0].rotation.z -= 0.05;
        GroupB.children[0].rotation.y += 0.05;
        GroupC.children[0].rotation.z += 0.05;
        GroupD.children[0].rotation.y += 0.05;
        GroupE.children[0].rotation.y += 0.05;
        GroupF.children[0].rotation.y += 0.05;
      }
      else{
        GroupA.children[0].position.x -= triStep;
        GroupB.children[0].position.y -= triStep;
        GroupC.children[0].position.x -= triStep;
        GroupD.children[0].position.y += triStep;
        GroupE.children[0].position.x -= triStep;
        GroupF.children[0].position.x -= triStep;
      }
      if (GroupA.children[0].position.x < -L/2) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(-L/2,-L/2, -L/2);
        pos2[0] = new THREE.Vector3(-L/2,-L/2, -L/2);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        ///////////////////
        pos1[1] = new THREE.Vector3(-L/2,-L, 0);
        pos2[1] = new THREE.Vector3(-L/2,-L, 0);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ///////////////////
        pos1[2] = new THREE.Vector3(-L/2,-L/2, L/2);
        pos2[2] = new THREE.Vector3(-L/2,-L/2, L/2);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ///////////////////
        pos1[3] = new THREE.Vector3(L/2,0, 0);
        pos2[3] = new THREE.Vector3(L/2,0, 0);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(-L/2,0, 0);
        pos2[4] = new THREE.Vector3(-L/2,0, 0);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(-L/2,-L, 0);
        pos2[5] = new THREE.Vector3(-L/2,-L, 0);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
    
      if (GroupA.children[0].position.z > 0){
        
        if(GroupA.children[0].rotation.y < Math.PI/2){
          GroupA.children[0].rotation.y += 0.05;
          GroupB.children[0].rotation.y += 0.05;
          GroupC.children[0].rotation.y += 0.05;
          GroupD.children[0].rotation.y += 0.05;
          GroupE.children[0].rotation.y += 0.05;
          GroupF.children[0].rotation.y += 0.05;
        }
        else moving = false;
      }
      else{
        GroupA.children[0].position.z += triStep;
        GroupB.children[0].position.x += triStep;
        GroupC.children[0].position.z -= triStep;
        GroupD.children[0].position.x -= triStep;
        GroupE.children[0].position.y -= triStep;
        GroupF.children[0].position.y += triStep;
      }
    }
  }

  function FtoA() {
  var triStep = .90;
    if (turning === 0) {
      GroupA.children[0].position.y += triStep;
      GroupB.children[0].position.z += triStep;
      GroupC.children[0].position.y -= triStep;
      GroupD.children[0].position.z += triStep;
      GroupE.children[0].position.z += triStep;
      GroupF.children[0].position.z -= triStep;
      if (GroupA.children[0].position.y > 0) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(0,0, L/2);
        pos2[0] = new THREE.Vector3(0,0, L/2);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        ///////////////////
        pos1[1] = new THREE.Vector3(L/2,-L/2, L/2);
        pos2[1] = new THREE.Vector3(L/2,-L/2, L/2);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ///////////////////
        pos1[2] = new THREE.Vector3(0,-L,-L/2);
        pos2[2] = new THREE.Vector3(0,-L,-L/2);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ///////////////////
        pos1[3] = new THREE.Vector3(-L/2,-L/2, L/2);
        pos2[3] = new THREE.Vector3(-L/2,-L/2, L/2);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(0,-L, L/2);
        pos2[4] = new THREE.Vector3(0,-L, L/2);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(0,0, -L/2);
        pos2[5] = new THREE.Vector3(0,0, -L/2);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
      GroupA.children[0].position.z -= triStep;
      GroupB.children[0].position.x -= triStep;
      GroupC.children[0].position.z += triStep;
      GroupD.children[0].position.x += triStep;
      GroupE.children[0].position.y += triStep;
      GroupF.children[0].position.y -= triStep;
      
      if (GroupA.children[0].position.z < 0){
        moving = false;
      }
    }
  }
  function FtoC() {
  var triStep = .90;
    if (turning === 0) {
      if(GroupA.children[0].rotation.z <Math.PI+Math.PI/2){
        GroupA.children[0].rotation.z += 0.05;
        GroupB.children[0].rotation.y += 0.05;
        GroupC.children[0].rotation.z -= 0.05;
        GroupD.children[0].rotation.y += 0.05;
        GroupE.children[0].rotation.y += 0.05;
        GroupF.children[0].rotation.y += 0.05;
      }
      else{
        GroupA.children[0].position.y -= triStep;
        GroupB.children[0].position.z -= triStep;
        GroupC.children[0].position.y += triStep;
        GroupD.children[0].position.z -= triStep;
        GroupE.children[0].position.z -= triStep;
        GroupF.children[0].position.z += triStep;
      }
      if (GroupA.children[0].position.y < -L) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(0,-L, L/2);
        pos2[0] = new THREE.Vector3(0,-L, L/2);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        ///////////////////
        pos1[1] = new THREE.Vector3(L/2,-L/2, -L/2);
        pos2[1] = new THREE.Vector3(L/2,-L/2, -L/2);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ///////////////////
        pos1[2] = new THREE.Vector3(0,0,-L/2);
        pos2[2] = new THREE.Vector3(0,0,-L/2);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ///////////////////
        pos1[3] = new THREE.Vector3(-L/2,-L/2, -L/2);
        pos2[3] = new THREE.Vector3(-L/2,-L/2, -L/2);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(0,-L, -L/2);
        pos2[4] = new THREE.Vector3(0,-L, -L/2);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(0,0, L/2);
        pos2[5] = new THREE.Vector3(0,0, L/2);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
      GroupA.children[0].position.z -= triStep;
      GroupB.children[0].position.x -= triStep;
      GroupC.children[0].position.z += triStep;
      GroupD.children[0].position.x += triStep;
      GroupE.children[0].position.y += triStep;
      GroupF.children[0].position.y -= triStep;
      
      if (GroupA.children[0].position.z < 0){
        moving = false;
      }
    }
  }
  function FtoB() {
  var triStep = .90;
    if (turning === 0) {
      if(GroupA.children[0].rotation.z >0){
        GroupA.children[0].rotation.z -= 0.05;
        GroupB.children[0].rotation.y -= 0.05;
        GroupC.children[0].rotation.z += 0.05;
        GroupD.children[0].rotation.y -= 0.05;
        GroupE.children[0].rotation.y -= 0.05;
        GroupF.children[0].rotation.y -= 0.05;
      }
      else{
        GroupA.children[0].position.x += triStep;
        GroupB.children[0].position.y += triStep;
        GroupC.children[0].position.x += triStep;
        GroupD.children[0].position.y -= triStep;
        GroupE.children[0].position.x += triStep;
        GroupF.children[0].position.x += triStep;
      }
      if (GroupA.children[0].position.x > L/2) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(L/2,-L/2, L/2);
        pos2[0] = new THREE.Vector3(L/2,-L/2, L/2);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        ///////////////////
        pos1[1] = new THREE.Vector3(L/2,0,0);
        pos2[1] = new THREE.Vector3(L/2,0,0);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ///////////////////
        pos1[2] = new THREE.Vector3(L/2,-L/2, -L/2);
        pos2[2] = new THREE.Vector3(L/2,-L/2, -L/2);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ///////////////////
        pos1[3] = new THREE.Vector3(-L/2,-L, 0);
        pos2[3] = new THREE.Vector3(-L/2,-L, 0);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(L/2,-L, 0);
        pos2[4] = new THREE.Vector3(L/2,-L, 0);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(L/2,0, 0);
        pos2[5] = new THREE.Vector3(L/2,0, 0);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
      GroupA.children[0].position.z -= triStep;
      GroupB.children[0].position.x -= triStep;
      GroupC.children[0].position.z += triStep;
      GroupD.children[0].position.x += triStep;
      GroupE.children[0].position.y += triStep;
      GroupF.children[0].position.y -= triStep;
      
      if (GroupA.children[0].position.z < 0){
        moving = false;
      }
    }
  }
  function FtoD() {
  var triStep = .90;
    if (turning === 0) {
      if(GroupA.children[0].rotation.z <Math.PI){
        GroupA.children[0].rotation.z += 0.05;
        GroupB.children[0].rotation.y += 0.05;
        GroupC.children[0].rotation.z -= 0.05;
        GroupD.children[0].rotation.y += 0.05;
        GroupE.children[0].rotation.y += 0.05;
        GroupF.children[0].rotation.y += 0.05;
      }
      else{
        GroupA.children[0].position.x -= triStep;
        GroupB.children[0].position.y -= triStep;
        GroupC.children[0].position.x -= triStep;
        GroupD.children[0].position.y += triStep;
        GroupE.children[0].position.x -= triStep;
        GroupF.children[0].position.x -= triStep;
      }
      if (GroupA.children[0].position.x < -L/2) {// ready to cross
        turning = 1;
        pos1[0] = new THREE.Vector3(-L/2,-L/2, L/2);
        pos2[0] = new THREE.Vector3(-L/2,-L/2, L/2);
        quat1[0] = new THREE.Quaternion();
        quat1[0].setFromEuler(euler1[0]);
        quat2[0] = new THREE.Quaternion();
        quat2[0].setFromEuler(euler2[0]);
        ///////////////////
        pos1[1] = new THREE.Vector3(L/2,-L,0);
        pos2[1] = new THREE.Vector3(L/2,-L,0);
        quat1[1] = new THREE.Quaternion();
        quat1[1].setFromEuler(euler1[1]);
        quat2[1] = new THREE.Quaternion();
        quat2[1].setFromEuler(euler2[1]);
        ///////////////////
        pos1[2] = new THREE.Vector3(-L/2,-L/2, -L/2);
        pos2[2] = new THREE.Vector3(-L/2,-L/2, -L/2);
        quat1[2] = new THREE.Quaternion();
        quat1[2].setFromEuler(euler1[2]);
        quat2[2] = new THREE.Quaternion();
        quat2[2].setFromEuler(euler2[2]);
        ///////////////////
        pos1[3] = new THREE.Vector3(-L/2,0, 0);
        pos2[3] = new THREE.Vector3(-L/2,0, 0);
        quat1[3] = new THREE.Quaternion();
        quat1[3].setFromEuler(euler1[3]);
        quat2[3] = new THREE.Quaternion();
        quat2[3].setFromEuler(euler2[3]);
        ///////////////////
        pos1[4] = new THREE.Vector3(-L/2,-L, 0);
        pos2[4] = new THREE.Vector3(-L/2,-L, 0);
        quat1[4] = new THREE.Quaternion();
        quat1[4].setFromEuler(euler1[4]);
        quat2[4] = new THREE.Quaternion();
        quat2[4].setFromEuler(euler2[4]);
        ///////////////////
        pos1[5] = new THREE.Vector3(-L/2,0, 0);
        pos2[5] = new THREE.Vector3(-L/2,0, 0);
        quat1[5] = new THREE.Quaternion();
        quat1[5].setFromEuler(euler1[5]);
        quat2[5] = new THREE.Quaternion();
        quat2[5].setFromEuler(euler2[5]);
        ///////////////////
        alpha[0] = 0;
        alpha[1] = 0;
        alpha[2] = 0;
        alpha[3] = 0;
        alpha[4] = 0;
        alpha[5] = 0;
      }  

    } else if (turning === 1) { // in crossing
      alpha[0] = Cross(GroupA,pos1[0],pos2[0],quat1[0],quat2[0],alpha[0]);
      alpha[1] = Cross(GroupB,pos1[1],pos2[1],quat1[1],quat2[1],alpha[1]);
      alpha[2] = Cross(GroupC,pos1[2],pos2[2],quat1[2],quat2[2],alpha[2]);
      alpha[3] = Cross(GroupD,pos1[3],pos2[3],quat1[3],quat2[3],alpha[3]);
      alpha[4] = Cross(GroupE,pos1[4],pos2[4],quat1[4],quat2[4],alpha[4]);
      alpha[5] = Cross(GroupF,pos1[5],pos2[5],quat1[5],quat2[5],alpha[5]);
      GroupA.children[0].position.copy(pos2[0])
      GroupA.children[0].rotation.copy(euler2[0])
      GroupB.children[0].position.copy(pos2[1])
      GroupB.children[0].rotation.copy(euler2[1])
      GroupC.children[0].position.copy(pos2[2])
      GroupC.children[0].rotation.copy(euler2[2])
      GroupD.children[0].position.copy(pos2[3])
      GroupD.children[0].rotation.copy(euler2[3])
      GroupE.children[0].position.copy(pos2[4])
      GroupE.children[0].rotation.copy(euler2[4])
      GroupF.children[0].position.copy(pos2[5])
      GroupF.children[0].rotation.copy(euler2[5])// update alpha
    } else { // turning == 2: finish crossing ... always a straight line
      GroupA.children[0].position.z -= triStep;
      GroupB.children[0].position.x -= triStep;
      GroupC.children[0].position.z += triStep;
      GroupD.children[0].position.x += triStep;
      GroupE.children[0].position.y += triStep;
      GroupF.children[0].position.y -= triStep;
      
      if (GroupA.children[0].position.z < 0){
        moving = false;
      }
    }
  }

  function Cross(Group,pos1,pos2,quat1,quat2,alpha){
    alpha += 0.01;
      
    var qm = quat1.clone().slerp(quat2, alpha);
    Group.children[0].matrix.makeRotationFromQuaternion (qm);
    
    var pp = pos1.clone().lerp(pos2, alpha);
    Group.children[0].matrix.setPosition(pp);
    Group.children[0].matrixAutoUpdate = false;
    
    if (alpha > 1.0) {
      turning = 2; // done turning
      
      Group.children[0].position.setFromMatrixPosition (Group.children[0].matrixWorld);
      Group.children[0].quaternion.setFromRotationMatrix (Group.children[0].matrixWorld); 
      
      Group.children[0].matrixAutoUpdate = true;
    }
    return alpha;
  }
  function render() {

  renderer.render(scene, camera);

}

	</script>
	</body>
</html>
